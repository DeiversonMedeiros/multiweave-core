--
-- PostgreSQL database cluster dump
--

\restrict DIfRUToaK2kA467Xp6zeqdfHXdVMNlebH9GuCE0sUkRl8vdEnfgomtQNQipOMtP

SET default_transaction_read_only = off;

SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;

--
-- Roles
--

CREATE ROLE anon;
ALTER ROLE anon WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE authenticated;
ALTER ROLE authenticated WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE authenticator;
ALTER ROLE authenticator WITH NOSUPERUSER NOINHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE dashboard_user;
ALTER ROLE dashboard_user WITH NOSUPERUSER INHERIT CREATEROLE CREATEDB NOLOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE pgbouncer;
ALTER ROLE pgbouncer WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE postgres;
ALTER ROLE postgres WITH NOSUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS;
CREATE ROLE service_role;
ALTER ROLE service_role WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION BYPASSRLS;
CREATE ROLE supabase_admin;
ALTER ROLE supabase_admin WITH SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS;
CREATE ROLE supabase_auth_admin;
ALTER ROLE supabase_auth_admin WITH NOSUPERUSER NOINHERIT CREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE supabase_etl_admin;
ALTER ROLE supabase_etl_admin WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE supabase_read_only_user;
ALTER ROLE supabase_read_only_user WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION BYPASSRLS;
CREATE ROLE supabase_realtime_admin;
ALTER ROLE supabase_realtime_admin WITH NOSUPERUSER NOINHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE supabase_replication_admin;
ALTER ROLE supabase_replication_admin WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN REPLICATION NOBYPASSRLS;
CREATE ROLE supabase_storage_admin;
ALTER ROLE supabase_storage_admin WITH NOSUPERUSER NOINHERIT CREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS;

--
-- User Configurations
--

--
-- User Config "anon"
--

ALTER ROLE anon SET statement_timeout TO '3s';

--
-- User Config "authenticated"
--

ALTER ROLE authenticated SET statement_timeout TO '8s';

--
-- User Config "authenticator"
--

ALTER ROLE authenticator SET session_preload_libraries TO 'safeupdate';
ALTER ROLE authenticator SET statement_timeout TO '8s';
ALTER ROLE authenticator SET lock_timeout TO '8s';

--
-- User Config "postgres"
--

ALTER ROLE postgres SET search_path TO E'\\$user', 'public', 'extensions';

--
-- User Config "supabase_admin"
--

ALTER ROLE supabase_admin SET search_path TO '$user', 'public', 'auth', 'extensions';
ALTER ROLE supabase_admin SET log_statement TO 'none';

--
-- User Config "supabase_auth_admin"
--

ALTER ROLE supabase_auth_admin SET search_path TO 'auth';
ALTER ROLE supabase_auth_admin SET idle_in_transaction_session_timeout TO '60000';
ALTER ROLE supabase_auth_admin SET log_statement TO 'none';

--
-- User Config "supabase_read_only_user"
--

ALTER ROLE supabase_read_only_user SET default_transaction_read_only TO 'on';

--
-- User Config "supabase_storage_admin"
--

ALTER ROLE supabase_storage_admin SET search_path TO 'storage';
ALTER ROLE supabase_storage_admin SET log_statement TO 'none';


--
-- Role memberships
--

GRANT anon TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT anon TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticated TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT authenticated TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticator TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT authenticator TO supabase_storage_admin WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT pg_create_subscription TO postgres WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_monitor TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO supabase_etl_admin WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_read_all_data TO supabase_read_only_user WITH INHERIT TRUE GRANTED BY supabase_admin;
GRANT pg_signal_backend TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT service_role TO authenticator WITH INHERIT FALSE GRANTED BY supabase_admin;
GRANT service_role TO postgres WITH ADMIN OPTION, INHERIT TRUE GRANTED BY supabase_admin;
GRANT supabase_realtime_admin TO postgres WITH INHERIT TRUE GRANTED BY supabase_admin;






\unrestrict DIfRUToaK2kA467Xp6zeqdfHXdVMNlebH9GuCE0sUkRl8vdEnfgomtQNQipOMtP

--
-- Databases
--

--
-- Database "template1" dump
--

\connect template1

--
-- PostgreSQL database dump
--

\restrict cX5oiTTUfnJKN4f6yg7Eqz9rr4Gka0elbfkYb8f5T9lsPlzzMAgKj4b5c0KHar6

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.6 (Debian 17.6-2.pgdg12+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- PostgreSQL database dump complete
--

\unrestrict cX5oiTTUfnJKN4f6yg7Eqz9rr4Gka0elbfkYb8f5T9lsPlzzMAgKj4b5c0KHar6

--
-- Database "postgres" dump
--

\connect postgres

--
-- PostgreSQL database dump
--

\restrict lqGbnxpX7o51weGhpvaad4aqwRekvf2ptUlvVTSiNdtaWm6vXWqfh8n5ZUj0vrn

-- Dumped from database version 17.6
-- Dumped by pg_dump version 17.6 (Debian 17.6-2.pgdg12+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: almoxarifado; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA almoxarifado;


ALTER SCHEMA almoxarifado OWNER TO postgres;

--
-- Name: SCHEMA almoxarifado; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA almoxarifado IS 'Schema para controle de almoxarifado e estoque';


--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA auth;


ALTER SCHEMA auth OWNER TO supabase_admin;

--
-- Name: compras; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA compras;


ALTER SCHEMA compras OWNER TO postgres;

--
-- Name: SCHEMA compras; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA compras IS 'MÃ³dulo de Compras com trigger de estoque mÃ­nimo implementado';


--
-- Name: extensions; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA extensions;


ALTER SCHEMA extensions OWNER TO postgres;

--
-- Name: financeiro; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA financeiro;


ALTER SCHEMA financeiro OWNER TO postgres;

--
-- Name: SCHEMA financeiro; Type: COMMENT; Schema: -; Owner: postgres
--

COMMENT ON SCHEMA financeiro IS 'MÃ³dulo Financeiro implementado com sucesso - Contas a Pagar/Receber, Tesouraria, Fiscal e Contabilidade com sistema de aprovaÃ§Ã£o por valor, centro de custo, departamento, classe financeira e usuÃ¡rio';


--
-- Name: graphql; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql;


ALTER SCHEMA graphql OWNER TO supabase_admin;

--
-- Name: graphql_public; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql_public;


ALTER SCHEMA graphql_public OWNER TO supabase_admin;

--
-- Name: pgbouncer; Type: SCHEMA; Schema: -; Owner: pgbouncer
--

CREATE SCHEMA pgbouncer;


ALTER SCHEMA pgbouncer OWNER TO pgbouncer;

--
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA realtime;


ALTER SCHEMA realtime OWNER TO supabase_admin;

--
-- Name: rh; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA rh;


ALTER SCHEMA rh OWNER TO postgres;

--
-- Name: storage; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA storage;


ALTER SCHEMA storage OWNER TO supabase_admin;

--
-- Name: supabase_migrations; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA supabase_migrations;


ALTER SCHEMA supabase_migrations OWNER TO postgres;

--
-- Name: vault; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA vault;


ALTER SCHEMA vault OWNER TO supabase_admin;

--
-- Name: pg_graphql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_graphql WITH SCHEMA graphql;


--
-- Name: EXTENSION pg_graphql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_graphql IS 'pg_graphql: GraphQL support';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track planning and execution statistics of all SQL statements executed';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: supabase_vault; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS supabase_vault WITH SCHEMA vault;


--
-- Name: EXTENSION supabase_vault; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION supabase_vault IS 'Supabase Vault Extension';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: aal_level; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.aal_level AS ENUM (
    'aal1',
    'aal2',
    'aal3'
);


ALTER TYPE auth.aal_level OWNER TO supabase_auth_admin;

--
-- Name: code_challenge_method; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.code_challenge_method AS ENUM (
    's256',
    'plain'
);


ALTER TYPE auth.code_challenge_method OWNER TO supabase_auth_admin;

--
-- Name: factor_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_status AS ENUM (
    'unverified',
    'verified'
);


ALTER TYPE auth.factor_status OWNER TO supabase_auth_admin;

--
-- Name: factor_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_type AS ENUM (
    'totp',
    'webauthn',
    'phone'
);


ALTER TYPE auth.factor_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_authorization_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_authorization_status AS ENUM (
    'pending',
    'approved',
    'denied',
    'expired'
);


ALTER TYPE auth.oauth_authorization_status OWNER TO supabase_auth_admin;

--
-- Name: oauth_client_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_client_type AS ENUM (
    'public',
    'confidential'
);


ALTER TYPE auth.oauth_client_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_registration_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_registration_type AS ENUM (
    'dynamic',
    'manual'
);


ALTER TYPE auth.oauth_registration_type OWNER TO supabase_auth_admin;

--
-- Name: oauth_response_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.oauth_response_type AS ENUM (
    'code'
);


ALTER TYPE auth.oauth_response_type OWNER TO supabase_auth_admin;

--
-- Name: one_time_token_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.one_time_token_type AS ENUM (
    'confirmation_token',
    'reauthentication_token',
    'recovery_token',
    'email_change_token_new',
    'email_change_token_current',
    'phone_change_token'
);


ALTER TYPE auth.one_time_token_type OWNER TO supabase_auth_admin;

--
-- Name: metodo_envio; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.metodo_envio AS ENUM (
    'email',
    'link_externo',
    'presencial',
    'telefone',
    'whatsapp'
);


ALTER TYPE compras.metodo_envio OWNER TO postgres;

--
-- Name: prioridade; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.prioridade AS ENUM (
    'baixa',
    'normal',
    'alta',
    'urgente'
);


ALTER TYPE compras.prioridade OWNER TO postgres;

--
-- Name: status_cotacao; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.status_cotacao AS ENUM (
    'rascunho',
    'enviada',
    'recebida',
    'aprovada',
    'rejeitada',
    'vencida'
);


ALTER TYPE compras.status_cotacao OWNER TO postgres;

--
-- Name: status_pedido; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.status_pedido AS ENUM (
    'rascunho',
    'aprovado',
    'enviado',
    'confirmado',
    'parcialmente_entregue',
    'entregue',
    'cancelado'
);


ALTER TYPE compras.status_pedido OWNER TO postgres;

--
-- Name: status_requisicao; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.status_requisicao AS ENUM (
    'rascunho',
    'pendente_aprovacao',
    'aprovada',
    'em_cotacao',
    'cotada',
    'em_pedido',
    'finalizada',
    'cancelada'
);


ALTER TYPE compras.status_requisicao OWNER TO postgres;

--
-- Name: tipo_reajuste; Type: TYPE; Schema: compras; Owner: postgres
--

CREATE TYPE compras.tipo_reajuste AS ENUM (
    'ipca',
    'igpm',
    'inpc',
    'fixo',
    'livre'
);


ALTER TYPE compras.tipo_reajuste OWNER TO postgres;

--
-- Name: payment_status; Type: TYPE; Schema: financeiro; Owner: postgres
--

CREATE TYPE financeiro.payment_status AS ENUM (
    'pendente',
    'aprovado',
    'pago',
    'cancelado'
);


ALTER TYPE financeiro.payment_status OWNER TO postgres;

--
-- Name: receivable_status; Type: TYPE; Schema: financeiro; Owner: postgres
--

CREATE TYPE financeiro.receivable_status AS ENUM (
    'pendente',
    'recebido',
    'cancelado'
);


ALTER TYPE financeiro.receivable_status OWNER TO postgres;

--
-- Name: sefaz_status; Type: TYPE; Schema: financeiro; Owner: postgres
--

CREATE TYPE financeiro.sefaz_status AS ENUM (
    'autorizada',
    'rejeitada',
    'cancelada',
    'pendente'
);


ALTER TYPE financeiro.sefaz_status OWNER TO postgres;

--
-- Name: transaction_type; Type: TYPE; Schema: financeiro; Owner: postgres
--

CREATE TYPE financeiro.transaction_type AS ENUM (
    'pagamento',
    'recebimento',
    'transferencia'
);


ALTER TYPE financeiro.transaction_type OWNER TO postgres;

--
-- Name: partner_type; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.partner_type AS ENUM (
    'cliente',
    'fornecedor',
    'transportador'
);


ALTER TYPE public.partner_type OWNER TO postgres;

--
-- Name: user_role; Type: TYPE; Schema: public; Owner: postgres
--

CREATE TYPE public.user_role AS ENUM (
    'admin',
    'user',
    'manager'
);


ALTER TYPE public.user_role OWNER TO postgres;

--
-- Name: action; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE',
    'ERROR'
);


ALTER TYPE realtime.action OWNER TO supabase_admin;

--
-- Name: equality_op; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.equality_op AS ENUM (
    'eq',
    'neq',
    'lt',
    'lte',
    'gt',
    'gte',
    'in'
);


ALTER TYPE realtime.equality_op OWNER TO supabase_admin;

--
-- Name: user_defined_filter; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.user_defined_filter AS (
	column_name text,
	op realtime.equality_op,
	value text
);


ALTER TYPE realtime.user_defined_filter OWNER TO supabase_admin;

--
-- Name: wal_column; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_column AS (
	name text,
	type_name text,
	type_oid oid,
	value jsonb,
	is_pkey boolean,
	is_selectable boolean
);


ALTER TYPE realtime.wal_column OWNER TO supabase_admin;

--
-- Name: wal_rls; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_rls AS (
	wal jsonb,
	is_rls_enabled boolean,
	subscription_ids uuid[],
	errors text[]
);


ALTER TYPE realtime.wal_rls OWNER TO supabase_admin;

--
-- Name: buckettype; Type: TYPE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TYPE storage.buckettype AS ENUM (
    'STANDARD',
    'ANALYTICS'
);


ALTER TYPE storage.buckettype OWNER TO supabase_storage_admin;

--
-- Name: audit_trigger_function(); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.audit_trigger_function() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    old_data JSONB;
    new_data JSONB;
    operation_type TEXT;
BEGIN
    -- Determinar tipo de operaÃ§Ã£o
    IF TG_OP = 'DELETE' THEN
        operation_type := 'DELETE';
        old_data := to_jsonb(OLD);
        new_data := NULL;
    ELSIF TG_OP = 'UPDATE' THEN
        operation_type := 'UPDATE';
        old_data := to_jsonb(OLD);
        new_data := to_jsonb(NEW);
    ELSIF TG_OP = 'INSERT' THEN
        operation_type := 'INSERT';
        old_data := NULL;
        new_data := to_jsonb(NEW);
    END IF;

    -- Inserir log de auditoria
    INSERT INTO rh.audit_logs (
        table_name,
        operation_type,
        old_data,
        new_data,
        user_id,
        company_id,
        created_at
    ) VALUES (
        TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        operation_type,
        old_data,
        new_data,
        auth.uid(),
        COALESCE(
            current_setting('app.current_company_id', true)::uuid,
            (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
        ),
        NOW()
    );

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION almoxarifado.audit_trigger_function() OWNER TO postgres;

--
-- Name: FUNCTION audit_trigger_function(); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.audit_trigger_function() IS 'FunÃ§Ã£o de trigger para auditoria de operaÃ§Ãµes no mÃ³dulo almoxarifado';


--
-- Name: can_create_entity(text); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.can_create_entity(entity_name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := false;
BEGIN
    -- Obter perfil do usuÃ¡rio na empresa atual
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = auth.uid()
    AND uc.company_id = COALESCE(
        current_setting('app.current_company_id', true)::uuid,
        (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
    )
    AND uc.ativo = true
    LIMIT 1;

    IF user_profile_id IS NULL THEN
        RETURN false;
    END IF;

    -- Verificar permissÃ£o na entidade especÃ­fica
    SELECT ep.can_create INTO has_permission
    FROM public.entity_permissions ep
    WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = entity_name;

    RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION almoxarifado.can_create_entity(entity_name text) OWNER TO postgres;

--
-- Name: FUNCTION can_create_entity(entity_name text); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.can_create_entity(entity_name text) IS 'Verifica se o usuÃ¡rio pode criar registros na entidade especificada';


--
-- Name: can_delete_entity(text); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.can_delete_entity(entity_name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := false;
BEGIN
    -- Obter perfil do usuÃ¡rio na empresa atual
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = auth.uid()
    AND uc.company_id = COALESCE(
        current_setting('app.current_company_id', true)::uuid,
        (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
    )
    AND uc.ativo = true
    LIMIT 1;

    IF user_profile_id IS NULL THEN
        RETURN false;
    END IF;

    -- Verificar permissÃ£o na entidade especÃ­fica
    SELECT ep.can_delete INTO has_permission
    FROM public.entity_permissions ep
    WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = entity_name;

    RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION almoxarifado.can_delete_entity(entity_name text) OWNER TO postgres;

--
-- Name: FUNCTION can_delete_entity(entity_name text); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.can_delete_entity(entity_name text) IS 'Verifica se o usuÃ¡rio pode excluir registros da entidade especificada';


--
-- Name: can_edit_entity(text); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.can_edit_entity(entity_name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := false;
BEGIN
    -- Obter perfil do usuÃ¡rio na empresa atual
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = auth.uid()
    AND uc.company_id = COALESCE(
        current_setting('app.current_company_id', true)::uuid,
        (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
    )
    AND uc.ativo = true
    LIMIT 1;

    IF user_profile_id IS NULL THEN
        RETURN false;
    END IF;

    -- Verificar permissÃ£o na entidade especÃ­fica
    SELECT ep.can_edit INTO has_permission
    FROM public.entity_permissions ep
    WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = entity_name;

    RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION almoxarifado.can_edit_entity(entity_name text) OWNER TO postgres;

--
-- Name: FUNCTION can_edit_entity(entity_name text); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.can_edit_entity(entity_name text) IS 'Verifica se o usuÃ¡rio pode editar registros na entidade especificada';


--
-- Name: can_read_entity(text); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.can_read_entity(entity_name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := false;
BEGIN
    -- Obter perfil do usuÃ¡rio na empresa atual
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = auth.uid()
    AND uc.company_id = COALESCE(
        current_setting('app.current_company_id', true)::uuid,
        (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
    )
    AND uc.ativo = true
    LIMIT 1;

    IF user_profile_id IS NULL THEN
        RETURN false;
    END IF;

    -- Verificar permissÃ£o na entidade especÃ­fica
    SELECT ep.can_read INTO has_permission
    FROM public.entity_permissions ep
    WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = entity_name;

    RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION almoxarifado.can_read_entity(entity_name text) OWNER TO postgres;

--
-- Name: FUNCTION can_read_entity(entity_name text); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.can_read_entity(entity_name text) IS 'Verifica se o usuÃ¡rio pode ler a entidade especificada';


--
-- Name: check_module_permission(text); Type: FUNCTION; Schema: almoxarifado; Owner: postgres
--

CREATE FUNCTION almoxarifado.check_module_permission(permission_type text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := false;
BEGIN
    -- Obter perfil do usuÃ¡rio na empresa atual
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = auth.uid()
    AND uc.company_id = COALESCE(
        current_setting('app.current_company_id', true)::uuid,
        (SELECT company_id FROM public.user_companies WHERE user_id = auth.uid() LIMIT 1)
    )
    AND uc.ativo = true
    LIMIT 1;

    IF user_profile_id IS NULL THEN
        RETURN false;
    END IF;

    -- Verificar permissÃ£o no mÃ³dulo almoxarifado
    SELECT 
        CASE permission_type
            WHEN 'read' THEN mp.can_read
            WHEN 'create' THEN mp.can_create
            WHEN 'edit' THEN mp.can_edit
            WHEN 'delete' THEN mp.can_delete
            ELSE false
        END INTO has_permission
    FROM public.module_permissions mp
    WHERE mp.profile_id = user_profile_id
    AND mp.module_name = 'almoxarifado'
    AND mp.can_read = true;

    RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION almoxarifado.check_module_permission(permission_type text) OWNER TO postgres;

--
-- Name: FUNCTION check_module_permission(permission_type text); Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON FUNCTION almoxarifado.check_module_permission(permission_type text) IS 'Verifica permissÃµes do usuÃ¡rio no mÃ³dulo almoxarifado';


--
-- Name: email(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.email() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$$;


ALTER FUNCTION auth.email() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION email(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.email() IS 'Deprecated. Use auth.jwt() -> ''email'' instead.';


--
-- Name: jwt(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$$;


ALTER FUNCTION auth.jwt() OWNER TO supabase_auth_admin;

--
-- Name: role(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$$;


ALTER FUNCTION auth.role() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION role(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.role() IS 'Deprecated. Use auth.jwt() -> ''role'' instead.';


--
-- Name: uid(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.uid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$$;


ALTER FUNCTION auth.uid() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION uid(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.uid() IS 'Deprecated. Use auth.jwt() -> ''sub'' instead.';


--
-- Name: atualizar_avaliacao_fornecedor(uuid, uuid, numeric, numeric, numeric, numeric, text); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.atualizar_avaliacao_fornecedor(p_pedido_id uuid, p_avaliador_id uuid, p_nota_prazo numeric, p_nota_qualidade numeric, p_nota_preco numeric, p_nota_atendimento numeric, p_observacoes text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_avaliacao_id UUID;
    v_pedido compras.pedidos_compra%ROWTYPE;
    v_media DECIMAL;
BEGIN
    -- Buscar dados do pedido
    SELECT * INTO v_pedido
    FROM compras.pedidos_compra
    WHERE id = p_pedido_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Pedido nÃ£o encontrado';
    END IF;
    
    -- Calcular mÃ©dia
    v_media := (p_nota_prazo + p_nota_qualidade + p_nota_preco + p_nota_atendimento) / 4;
    
    -- Criar avaliaÃ§Ã£o
    INSERT INTO compras.avaliacoes_fornecedor (
        id, fornecedor_id, pedido_id, avaliador_id, company_id,
        nota_prazo, nota_qualidade, nota_preco, nota_atendimento,
        observacoes, data_avaliacao
    ) VALUES (
        gen_random_uuid(), v_pedido.fornecedor_id, p_pedido_id, p_avaliador_id,
        v_pedido.company_id, p_nota_prazo, p_nota_qualidade, p_nota_preco,
        p_nota_atendimento, p_observacoes, CURRENT_DATE
    ) RETURNING id INTO v_avaliacao_id;
    
    -- Atualizar mÃ©dia do fornecedor
    UPDATE compras.fornecedores_dados
    SET 
        nota_media = (
            SELECT AVG(media_geral) 
            FROM compras.avaliacoes_fornecedor 
            WHERE fornecedor_id = v_pedido.fornecedor_id
        ),
        total_avaliacoes = (
            SELECT COUNT(*) 
            FROM compras.avaliacoes_fornecedor 
            WHERE fornecedor_id = v_pedido.fornecedor_id
        ),
        updated_at = NOW()
    WHERE id = v_pedido.fornecedor_id;
    
    RETURN v_avaliacao_id;
END;
$$;


ALTER FUNCTION compras.atualizar_avaliacao_fornecedor(p_pedido_id uuid, p_avaliador_id uuid, p_nota_prazo numeric, p_nota_qualidade numeric, p_nota_preco numeric, p_nota_atendimento numeric, p_observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION atualizar_avaliacao_fornecedor(p_pedido_id uuid, p_avaliador_id uuid, p_nota_prazo numeric, p_nota_qualidade numeric, p_nota_preco numeric, p_nota_atendimento numeric, p_observacoes text); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.atualizar_avaliacao_fornecedor(p_pedido_id uuid, p_avaliador_id uuid, p_nota_prazo numeric, p_nota_qualidade numeric, p_nota_preco numeric, p_nota_atendimento numeric, p_observacoes text) IS 'Atualiza avaliaÃ§Ã£o de fornecedor apÃ³s entrega do pedido';


--
-- Name: atualizar_historico_precos(uuid, uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.atualizar_historico_precos(p_cotacao_id uuid, p_company_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cotacao compras.cotacoes%ROWTYPE;
    v_item compras.cotacao_itens%ROWTYPE;
BEGIN
    -- Buscar dados da cotaÃ§Ã£o
    SELECT * INTO v_cotacao
    FROM compras.cotacoes
    WHERE id = p_cotacao_id AND status = 'aprovada';
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'CotaÃ§Ã£o aprovada nÃ£o encontrada';
    END IF;
    
    -- Inserir preÃ§os no histÃ³rico
    FOR v_item IN 
        SELECT ci.*
        FROM compras.cotacao_itens ci
        WHERE ci.cotacao_id = p_cotacao_id
    LOOP
        INSERT INTO compras.historico_precos (
            id, material_id, fornecedor_id, company_id, valor_unitario,
            quantidade, cotacao_id, data_cotacao, observacoes
        ) VALUES (
            gen_random_uuid(), v_item.material_id, v_cotacao.fornecedor_id,
            p_company_id, v_item.valor_unitario, v_item.quantidade,
            p_cotacao_id, v_cotacao.data_cotacao,
            'PreÃ§o da cotaÃ§Ã£o ' || v_cotacao.numero_cotacao
        );
    END LOOP;
END;
$$;


ALTER FUNCTION compras.atualizar_historico_precos(p_cotacao_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION atualizar_historico_precos(p_cotacao_id uuid, p_company_id uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.atualizar_historico_precos(p_cotacao_id uuid, p_company_id uuid) IS 'Atualiza histÃ³rico de preÃ§os quando cotaÃ§Ã£o Ã© aprovada';


--
-- Name: atualizar_valor_requisicao(); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.atualizar_valor_requisicao() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_valor_total DECIMAL(15,2);
BEGIN
    -- Calcular valor total dos itens
    SELECT COALESCE(SUM(quantidade * COALESCE(valor_unitario_estimado, 0)), 0)
    INTO v_valor_total
    FROM compras.requisicao_itens
    WHERE requisicao_id = COALESCE(NEW.requisicao_id, OLD.requisicao_id);
    
    -- Atualizar valor total da requisiÃ§Ã£o
    UPDATE compras.requisicoes_compra
    SET 
        valor_total_estimado = v_valor_total,
        updated_at = NOW()
    WHERE id = COALESCE(NEW.requisicao_id, OLD.requisicao_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION compras.atualizar_valor_requisicao() OWNER TO postgres;

--
-- Name: configurar_estoque_minimo(uuid, uuid, numeric, uuid, uuid, compras.prioridade, text); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.configurar_estoque_minimo(p_material_id uuid, p_company_id uuid, p_quantidade_minima numeric, p_centro_custo_id uuid DEFAULT NULL::uuid, p_projeto_id uuid DEFAULT NULL::uuid, p_prioridade compras.prioridade DEFAULT 'normal'::compras.prioridade, p_observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Atualizar configuraÃ§Ã£o no material
    UPDATE almoxarifado.materiais_equipamentos
    SET 
        quantidade_minima = p_quantidade_minima,
        centro_custo_id = p_centro_custo_id,
        projeto_id = p_projeto_id,
        prioridade_requisicao = p_prioridade,
        observacoes_requisicao = p_observacoes,
        updated_at = NOW()
    WHERE id = p_material_id AND company_id = p_company_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Material nÃ£o encontrado';
    END IF;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION compras.configurar_estoque_minimo(p_material_id uuid, p_company_id uuid, p_quantidade_minima numeric, p_centro_custo_id uuid, p_projeto_id uuid, p_prioridade compras.prioridade, p_observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION configurar_estoque_minimo(p_material_id uuid, p_company_id uuid, p_quantidade_minima numeric, p_centro_custo_id uuid, p_projeto_id uuid, p_prioridade compras.prioridade, p_observacoes text); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.configurar_estoque_minimo(p_material_id uuid, p_company_id uuid, p_quantidade_minima numeric, p_centro_custo_id uuid, p_projeto_id uuid, p_prioridade compras.prioridade, p_observacoes text) IS 'Configura estoque mÃ­nimo para um material';


--
-- Name: consolidar_requisicoes_similares(uuid, uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.consolidar_requisicoes_similares(p_material_id uuid, p_company_id uuid) RETURNS TABLE(requisicao_id uuid, solicitante_id uuid, quantidade_total numeric, data_necessidade date, observacoes text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ri.requisicao_id,
        rc.solicitante_id,
        SUM(ri.quantidade) as quantidade_total,
        MIN(rc.data_necessidade) as data_necessidade,
        STRING_AGG(ri.observacoes, '; ') as observacoes
    FROM compras.requisicao_itens ri
    JOIN compras.requisicoes_compra rc ON rc.id = ri.requisicao_id
    WHERE ri.material_id = p_material_id
    AND rc.company_id = p_company_id
    AND rc.status IN ('aprovada', 'em_cotacao')
    AND ri.status = 'pendente'
    GROUP BY ri.requisicao_id, rc.solicitante_id
    ORDER BY MIN(rc.data_necessidade);
END;
$$;


ALTER FUNCTION compras.consolidar_requisicoes_similares(p_material_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION consolidar_requisicoes_similares(p_material_id uuid, p_company_id uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.consolidar_requisicoes_similares(p_material_id uuid, p_company_id uuid) IS 'Consolida requisiÃ§Ãµes com o mesmo material para cotaÃ§Ã£o conjunta';


--
-- Name: criar_conta_pagar(uuid, uuid, uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.criar_conta_pagar(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_conta_id UUID;
    v_pedido compras.pedidos_compra%ROWTYPE;
    v_fornecedor compras.fornecedores_dados%ROWTYPE;
    v_partner public.partners%ROWTYPE;
BEGIN
    -- Buscar dados do pedido
    SELECT * INTO v_pedido
    FROM compras.pedidos_compra
    WHERE id = p_pedido_id AND company_id = p_company_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Pedido nÃ£o encontrado';
    END IF;
    
    -- Buscar dados do fornecedor
    SELECT * INTO v_fornecedor
    FROM compras.fornecedores_dados
    WHERE id = v_pedido.fornecedor_id;
    
    -- Buscar dados do partner
    SELECT * INTO v_partner
    FROM public.partners
    WHERE id = v_fornecedor.partner_id;
    
    -- Criar conta a pagar
    INSERT INTO financeiro.contas_pagar (
        id, company_id, fornecedor_id, descricao, valor_original,
        valor_atual, data_vencimento, status, observacoes, created_by
    ) VALUES (
        gen_random_uuid(), p_company_id, v_partner.id,
        'Pedido de Compra ' || v_pedido.numero_pedido,
        v_pedido.valor_final, v_pedido.valor_final,
        CURRENT_DATE + INTERVAL '30 days', 'pendente',
        'Conta gerada automaticamente do pedido ' || v_pedido.numero_pedido,
        p_created_by
    ) RETURNING id INTO v_conta_id;
    
    RETURN v_conta_id;
END;
$$;


ALTER FUNCTION compras.criar_conta_pagar(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) OWNER TO postgres;

--
-- Name: FUNCTION criar_conta_pagar(p_pedido_id uuid, p_company_id uuid, p_created_by uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.criar_conta_pagar(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) IS 'Cria conta a pagar automaticamente quando pedido Ã© aprovado';


--
-- Name: criar_entrada_almoxarifado(uuid, uuid, uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.criar_entrada_almoxarifado(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_entrada_id UUID;
    v_pedido compras.pedidos_compra%ROWTYPE;
    v_item compras.pedido_itens%ROWTYPE;
BEGIN
    -- Buscar dados do pedido
    SELECT * INTO v_pedido
    FROM compras.pedidos_compra
    WHERE id = p_pedido_id AND company_id = p_company_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Pedido nÃ£o encontrado';
    END IF;
    
    -- Criar entrada de material
    INSERT INTO almoxarifado.entradas_materiais (
        id, company_id, fornecedor_id, numero_documento, data_entrada,
        tipo_entrada, status, observacoes, created_by
    ) VALUES (
        gen_random_uuid(), p_company_id, v_pedido.fornecedor_id, 
        v_pedido.numero_pedido, CURRENT_DATE, 'compra', 'pendente',
        'Entrada automÃ¡tica do pedido ' || v_pedido.numero_pedido, p_created_by
    ) RETURNING id INTO v_entrada_id;
    
    -- Criar itens da entrada
    FOR v_item IN 
        SELECT pi.*, pi.quantidade as quantidade_entrada
        FROM compras.pedido_itens pi
        WHERE pi.pedido_id = p_pedido_id
    LOOP
        INSERT INTO almoxarifado.entrada_itens (
            id, entrada_id, material_id, quantidade, valor_unitario,
            valor_total, observacoes, created_by
        ) VALUES (
            gen_random_uuid(), v_entrada_id, v_item.material_id,
            v_item.quantidade, v_item.valor_unitario, v_item.valor_total,
            'Item do pedido ' || v_pedido.numero_pedido, p_created_by
        );
    END LOOP;
    
    -- Atualizar status do pedido
    UPDATE compras.pedidos_compra
    SET status = 'confirmado', updated_at = NOW()
    WHERE id = p_pedido_id;
    
    RETURN v_entrada_id;
END;
$$;


ALTER FUNCTION compras.criar_entrada_almoxarifado(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) OWNER TO postgres;

--
-- Name: FUNCTION criar_entrada_almoxarifado(p_pedido_id uuid, p_company_id uuid, p_created_by uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.criar_entrada_almoxarifado(p_pedido_id uuid, p_company_id uuid, p_created_by uuid) IS 'Cria entrada automÃ¡tica no almoxarifado quando pedido Ã© aprovado';


--
-- Name: gerar_link_cotacao(uuid, text); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.gerar_link_cotacao(p_cotacao_id uuid, p_base_url text DEFAULT 'https://app.estrategicengenharia.com.br'::text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_cotacao compras.cotacoes%ROWTYPE;
    v_link TEXT;
BEGIN
    -- Buscar dados da cotaÃ§Ã£o
    SELECT * INTO v_cotacao
    FROM compras.cotacoes
    WHERE id = p_cotacao_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'CotaÃ§Ã£o nÃ£o encontrada';
    END IF;
    
    -- Gerar link Ãºnico
    v_link := p_base_url || '/compras/cotacao/' || p_cotacao_id || '?token=' || 
              encode(gen_random_bytes(32), 'hex');
    
    -- Atualizar link na cotaÃ§Ã£o
    UPDATE compras.cotacoes
    SET link_fornecedor = v_link, updated_at = NOW()
    WHERE id = p_cotacao_id;
    
    RETURN v_link;
END;
$$;


ALTER FUNCTION compras.gerar_link_cotacao(p_cotacao_id uuid, p_base_url text) OWNER TO postgres;

--
-- Name: FUNCTION gerar_link_cotacao(p_cotacao_id uuid, p_base_url text); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.gerar_link_cotacao(p_cotacao_id uuid, p_base_url text) IS 'Gera link Ãºnico para fornecedor preencher cotaÃ§Ã£o';


--
-- Name: gerar_numero_pedido(uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.gerar_numero_pedido(p_company_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    proximo_numero INTEGER;
    numero_formatado VARCHAR(50);
BEGIN
    -- Buscar prÃ³ximo nÃºmero
    SELECT COALESCE(MAX(CAST(SUBSTRING(numero_pedido FROM '[0-9]+') AS INTEGER)), 0) + 1
    INTO proximo_numero
    FROM compras.pedidos_compra
    WHERE company_id = p_company_id;
    
    -- Formatar nÃºmero
    numero_formatado := 'PED-' || LPAD(proximo_numero::TEXT, 6, '0');
    
    RETURN numero_formatado;
END;
$$;


ALTER FUNCTION compras.gerar_numero_pedido(p_company_id uuid) OWNER TO postgres;

--
-- Name: gerar_numero_requisicao(uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.gerar_numero_requisicao(p_company_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    proximo_numero INTEGER;
    numero_formatado VARCHAR(50);
BEGIN
    -- Buscar prÃ³ximo nÃºmero
    SELECT COALESCE(MAX(CAST(SUBSTRING(numero_requisicao FROM '[0-9]+') AS INTEGER)), 0) + 1
    INTO proximo_numero
    FROM compras.requisicoes_compra
    WHERE company_id = p_company_id;
    
    -- Formatar nÃºmero
    numero_formatado := 'REQ-' || LPAD(proximo_numero::TEXT, 6, '0');
    
    RETURN numero_formatado;
END;
$$;


ALTER FUNCTION compras.gerar_numero_requisicao(p_company_id uuid) OWNER TO postgres;

--
-- Name: sugerir_fornecedores_uf(character varying, uuid, uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.sugerir_fornecedores_uf(p_uf character varying, p_company_id uuid, p_material_id uuid DEFAULT NULL::uuid) RETURNS TABLE(fornecedor_id uuid, partner_id uuid, nome text, email_cotacao character varying, telefone character varying, cidade character varying, nota_media numeric, total_avaliacoes integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        fd.id as fornecedor_id,
        fd.partner_id,
        COALESCE(p.nome_fantasia, p.razao_social) as nome,
        fd.email_cotacao,
        fd.telefone,
        fd.cidade,
        fd.nota_media,
        fd.total_avaliacoes
    FROM compras.fornecedores_dados fd
    JOIN public.partners p ON p.id = fd.partner_id
    WHERE fd.uf = p_uf 
    AND fd.company_id = p_company_id
    AND fd.status = 'ativo'
    AND (p_material_id IS NULL OR EXISTS (
        SELECT 1 FROM compras.historico_precos hp
        WHERE hp.fornecedor_id = fd.id 
        AND hp.material_id = p_material_id
    ))
    ORDER BY fd.nota_media DESC, fd.total_avaliacoes DESC;
END;
$$;


ALTER FUNCTION compras.sugerir_fornecedores_uf(p_uf character varying, p_company_id uuid, p_material_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION sugerir_fornecedores_uf(p_uf character varying, p_company_id uuid, p_material_id uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.sugerir_fornecedores_uf(p_uf character varying, p_company_id uuid, p_material_id uuid) IS 'Sugere fornecedores por UF e material especÃ­fico - TIPOS CORRIGIDOS';


--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION compras.update_updated_at_column() OWNER TO postgres;

--
-- Name: verificar_estoque_minimo(); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.verificar_estoque_minimo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_material_id UUID;
    v_quantidade_atual DECIMAL(10,3);
    v_quantidade_minima DECIMAL(10,3);
    v_almoxarifado_id UUID;
    v_company_id UUID;
    v_requisicao_id UUID;
    v_item_id UUID;
    v_centro_custo_id UUID;
    v_projeto_id UUID;
    v_prioridade compras.prioridade;
    v_observacoes TEXT;
BEGIN
    -- Verificar se Ã© uma operaÃ§Ã£o de saÃ­da (reduÃ§Ã£o do estoque)
    IF TG_OP = 'UPDATE' AND OLD.quantidade_atual > NEW.quantidade_atual THEN
        v_material_id := NEW.material_id;
        v_quantidade_atual := NEW.quantidade_atual;
        v_almoxarifado_id := NEW.almoxarifado_id;
        v_company_id := NEW.company_id;
    ELSIF TG_OP = 'INSERT' AND NEW.tipo_movimentacao = 'saida' THEN
        v_material_id := NEW.material_id;
        v_quantidade_atual := NEW.quantidade_atual;
        v_almoxarifado_id := NEW.almoxarifado_id;
        v_company_id := NEW.company_id;
    ELSE
        RETURN COALESCE(NEW, OLD);
    END IF;

    -- Buscar quantidade mÃ­nima do material
    SELECT 
        me.quantidade_minima,
        me.centro_custo_id,
        me.projeto_id,
        me.prioridade_requisicao,
        me.observacoes_requisicao
    INTO 
        v_quantidade_minima,
        v_centro_custo_id,
        v_projeto_id,
        v_prioridade,
        v_observacoes
    FROM almoxarifado.materiais_equipamentos me
    WHERE me.id = v_material_id
    AND me.company_id = v_company_id
    AND me.quantidade_minima IS NOT NULL
    AND me.quantidade_minima > 0;

    -- Se nÃ£o encontrou configuraÃ§Ã£o de estoque mÃ­nimo, nÃ£o faz nada
    IF NOT FOUND OR v_quantidade_minima IS NULL THEN
        RETURN COALESCE(NEW, OLD);
    END IF;

    -- Verificar se estoque estÃ¡ abaixo do mÃ­nimo
    IF v_quantidade_atual <= v_quantidade_minima THEN
        -- Verificar se jÃ¡ existe requisiÃ§Ã£o pendente para este material
        IF NOT EXISTS (
            SELECT 1 
            FROM compras.requisicoes_compra rc
            JOIN compras.requisicao_itens ri ON ri.requisicao_id = rc.id
            WHERE ri.material_id = v_material_id
            AND rc.company_id = v_company_id
            AND rc.status IN ('rascunho', 'pendente_aprovacao', 'aprovada', 'em_cotacao')
            AND ri.almoxarifado_id = v_almoxarifado_id
        ) THEN
            -- Criar requisiÃ§Ã£o automÃ¡tica
            INSERT INTO compras.requisicoes_compra (
                id, company_id, solicitante_id, centro_custo_id, projeto_id,
                numero_requisicao, data_solicitacao, data_necessidade,
                status, prioridade, valor_total_estimado, observacoes,
                justificativa, created_by
            ) VALUES (
                gen_random_uuid(), v_company_id, 
                (SELECT id FROM public.users WHERE company_id = v_company_id LIMIT 1),
                v_centro_custo_id, v_projeto_id,
                compras.gerar_numero_requisicao(v_company_id),
                CURRENT_DATE, CURRENT_DATE + INTERVAL '7 days',
                'rascunho', COALESCE(v_prioridade, 'normal'),
                0, COALESCE(v_observacoes, 'RequisiÃ§Ã£o automÃ¡tica - Estoque mÃ­nimo atingido'),
                'RequisiÃ§Ã£o gerada automaticamente pelo sistema devido ao estoque mÃ­nimo',
                (SELECT id FROM public.users WHERE company_id = v_company_id LIMIT 1)
            ) RETURNING id INTO v_requisicao_id;

            -- Adicionar item Ã  requisiÃ§Ã£o
            INSERT INTO compras.requisicao_itens (
                id, requisicao_id, material_id, almoxarifado_id,
                quantidade, unidade_medida, valor_unitario_estimado,
                valor_total_estimado, especificacao_tecnica, observacoes, status
            ) VALUES (
                gen_random_uuid(), v_requisicao_id, v_material_id, v_almoxarifado_id,
                v_quantidade_minima * 2, -- Solicitar 2x a quantidade mÃ­nima
                (SELECT unidade_medida FROM almoxarifado.materiais_equipamentos WHERE id = v_material_id),
                (SELECT valor_unitario_estimado FROM almoxarifado.materiais_equipamentos WHERE id = v_material_id),
                (v_quantidade_minima * 2) * COALESCE(
                    (SELECT valor_unitario_estimado FROM almoxarifado.materiais_equipamentos WHERE id = v_material_id), 
                    0
                ),
                'RecomposiÃ§Ã£o automÃ¡tica de estoque',
                'Item adicionado automaticamente devido ao estoque mÃ­nimo',
                'pendente'
            ) RETURNING id INTO v_item_id;

            -- Atualizar valor total da requisiÃ§Ã£o
            UPDATE compras.requisicoes_compra
            SET valor_total_estimado = (
                SELECT SUM(valor_total_estimado) 
                FROM compras.requisicao_itens 
                WHERE requisicao_id = v_requisicao_id
            )
            WHERE id = v_requisicao_id;

            -- Log da aÃ§Ã£o
            INSERT INTO rh.audit_logs (
                table_name, operation_type, new_data, user_id, company_id, created_at
            ) VALUES (
                'compras.requisicoes_compra', 'AUTO_CREATE',
                json_build_object(
                    'requisicao_id', v_requisicao_id,
                    'material_id', v_material_id,
                    'quantidade_atual', v_quantidade_atual,
                    'quantidade_minima', v_quantidade_minima,
                    'almoxarifado_id', v_almoxarifado_id,
                    'motivo', 'estoque_minimo'
                ),
                (SELECT id FROM public.users WHERE company_id = v_company_id LIMIT 1),
                v_company_id,
                NOW()
            );
        END IF;
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION compras.verificar_estoque_minimo() OWNER TO postgres;

--
-- Name: FUNCTION verificar_estoque_minimo(); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.verificar_estoque_minimo() IS 'Verifica estoque mÃ­nimo e cria requisiÃ§Ãµes automÃ¡ticas';


--
-- Name: verificar_todos_estoques_minimos(uuid); Type: FUNCTION; Schema: compras; Owner: postgres
--

CREATE FUNCTION compras.verificar_todos_estoques_minimos(p_company_id uuid DEFAULT NULL::uuid) RETURNS TABLE(material_id uuid, material_nome text, almoxarifado_id uuid, almoxarifado_nome text, quantidade_atual integer, estoque_minimo integer, status text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        ea.material_equipamento_id as material_id,
        me.descricao::TEXT as material_nome,
        ea.almoxarifado_id,
        a.nome::TEXT as almoxarifado_nome,
        ea.quantidade_atual,
        me.estoque_minimo,
        CASE
            WHEN ea.quantidade_atual <= me.estoque_minimo THEN 'CRITICO'::TEXT
            WHEN ea.quantidade_atual <= (me.estoque_minimo * 1.5) THEN 'ATENCAO'::TEXT
            ELSE 'NORMAL'::TEXT
        END as status
    FROM almoxarifado.estoque_atual ea
    JOIN almoxarifado.materiais_equipamentos me ON me.id = ea.material_equipamento_id
    JOIN almoxarifado.almoxarifados a ON a.id = ea.almoxarifado_id
    WHERE (p_company_id IS NULL OR ea.company_id = p_company_id)
    AND me.estoque_minimo IS NOT NULL
    AND me.estoque_minimo > 0
    ORDER BY
        CASE
            WHEN ea.quantidade_atual <= me.estoque_minimo THEN 1
            WHEN ea.quantidade_atual <= (me.estoque_minimo * 1.5) THEN 2
            ELSE 3
        END,
        ea.quantidade_atual::numeric / me.estoque_minimo;
END;
$$;


ALTER FUNCTION compras.verificar_todos_estoques_minimos(p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION verificar_todos_estoques_minimos(p_company_id uuid); Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON FUNCTION compras.verificar_todos_estoques_minimos(p_company_id uuid) IS 'Verifica todos os estoques que estao abaixo do minimo';


--
-- Name: grant_pg_cron_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_cron_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_cron_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_cron_access() IS 'Grants access to pg_cron';


--
-- Name: grant_pg_graphql_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_graphql_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$_$;


ALTER FUNCTION extensions.grant_pg_graphql_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_graphql_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_graphql_access() IS 'Grants access to pg_graphql';


--
-- Name: grant_pg_net_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_net_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_net_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_net_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_net_access() IS 'Grants access to pg_net';


--
-- Name: pgrst_ddl_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_ddl_watch() OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_drop_watch() OWNER TO supabase_admin;

--
-- Name: set_graphql_placeholder(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.set_graphql_placeholder() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$_$;


ALTER FUNCTION extensions.set_graphql_placeholder() OWNER TO supabase_admin;

--
-- Name: FUNCTION set_graphql_placeholder(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.set_graphql_placeholder() IS 'Reintroduces placeholder function for graphql_public.graphql';


--
-- Name: calculate_dpo(uuid, date, date); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    total_pago DECIMAL(15,2);
    media_diaria DECIMAL(15,2);
    dias_periodo INTEGER;
    dpo DECIMAL(10,2);
BEGIN
    -- Calcular dias do perÃ­odo
    dias_periodo := p_data_fim - p_data_inicio + 1;
    
    -- Calcular total pago no perÃ­odo
    SELECT COALESCE(SUM(valor_pago), 0)
    INTO total_pago
    FROM financeiro.contas_pagar
    WHERE company_id = p_company_id
    AND data_pagamento BETWEEN p_data_inicio AND p_data_fim
    AND is_active = true;
    
    -- Calcular mÃ©dia diÃ¡ria
    media_diaria := total_pago / dias_periodo;
    
    -- Calcular saldo pendente
    SELECT COALESCE(SUM(valor_atual), 0)
    INTO total_pago
    FROM financeiro.contas_pagar
    WHERE company_id = p_company_id
    AND status IN ('pendente', 'aprovado')
    AND is_active = true;
    
    -- Calcular DPO
    IF media_diaria > 0 THEN
        dpo := total_pago / media_diaria;
    ELSE
        dpo := 0;
    END IF;
    
    RETURN ROUND(dpo, 2);
END;
$$;


ALTER FUNCTION financeiro.calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date) OWNER TO postgres;

--
-- Name: calculate_dso(uuid, date, date); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    total_recebido DECIMAL(15,2);
    media_diaria DECIMAL(15,2);
    dias_periodo INTEGER;
    dso DECIMAL(10,2);
BEGIN
    -- Calcular dias do perÃ­odo
    dias_periodo := p_data_fim - p_data_inicio + 1;
    
    -- Calcular total recebido no perÃ­odo
    SELECT COALESCE(SUM(valor_recebido), 0)
    INTO total_recebido
    FROM financeiro.contas_receber
    WHERE company_id = p_company_id
    AND data_recebimento BETWEEN p_data_inicio AND p_data_fim
    AND is_active = true;
    
    -- Calcular mÃ©dia diÃ¡ria
    media_diaria := total_recebido / dias_periodo;
    
    -- Calcular saldo pendente
    SELECT COALESCE(SUM(valor_atual), 0)
    INTO total_recebido
    FROM financeiro.contas_receber
    WHERE company_id = p_company_id
    AND status IN ('pendente', 'confirmado')
    AND is_active = true;
    
    -- Calcular DSO
    IF media_diaria > 0 THEN
        dso := total_recebido / media_diaria;
    ELSE
        dso := 0;
    END IF;
    
    RETURN ROUND(dso, 2);
END;
$$;


ALTER FUNCTION financeiro.calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date) OWNER TO postgres;

--
-- Name: calculate_valor_atual(numeric, date, date, numeric, numeric); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date DEFAULT CURRENT_DATE, p_taxa_juros numeric DEFAULT 0, p_taxa_multa numeric DEFAULT 0) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    dias_atraso INTEGER;
    valor_juros DECIMAL;
    valor_multa DECIMAL;
    valor_atual DECIMAL;
BEGIN
    -- Calcular dias de atraso
    dias_atraso := GREATEST(0, p_data_calculo - p_data_vencimento);
    
    -- Calcular multa (aplicada uma vez)
    IF dias_atraso > 0 THEN
        valor_multa := p_valor_original * (p_taxa_multa / 100);
    ELSE
        valor_multa := 0;
    END IF;
    
    -- Calcular juros (aplicados por dia)
    IF dias_atraso > 0 THEN
        valor_juros := p_valor_original * (p_taxa_juros / 100) * (dias_atraso / 30.0);
    ELSE
        valor_juros := 0;
    END IF;
    
    -- Calcular valor atual
    valor_atual := p_valor_original + valor_multa + valor_juros;
    
    RETURN ROUND(valor_atual, 2);
END;
$$;


ALTER FUNCTION financeiro.calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date, p_taxa_juros numeric, p_taxa_multa numeric) OWNER TO postgres;

--
-- Name: check_approval_permission(uuid, uuid, numeric, uuid, text, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid DEFAULT NULL::uuid, p_departamento text DEFAULT NULL::text, p_classe_financeira text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_profile_id UUID;
    has_permission BOOLEAN := FALSE;
BEGIN
    -- Verificar se Ã© super admin
    IF public.is_admin(p_user_id) THEN
        RETURN TRUE;
    END IF;
    
    -- Obter profile_id do usuÃ¡rio
    SELECT uc.profile_id INTO user_profile_id
    FROM public.user_companies uc
    WHERE uc.user_id = p_user_id
    AND uc.company_id = p_company_id
    AND uc.ativo = true
    LIMIT 1;
    
    -- Se nÃ£o encontrou perfil, retorna false
    IF user_profile_id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Verificar se tem permissÃ£o de aprovaÃ§Ã£o
    SELECT EXISTS(
        SELECT 1 FROM public.module_permissions mp
        WHERE mp.profile_id = user_profile_id
        AND mp.module_name = 'financeiro'
        AND mp.can_edit = true
    ) INTO has_permission;
    
    -- Se nÃ£o tem permissÃ£o bÃ¡sica, retorna false
    IF NOT has_permission THEN
        RETURN FALSE;
    END IF;
    
    -- Verificar configuraÃ§Ãµes especÃ­ficas de aprovaÃ§Ã£o
    -- Por valor
    IF EXISTS(
        SELECT 1 FROM financeiro.configuracoes_aprovacao ca
        WHERE ca.company_id = p_company_id
        AND ca.tipo_aprovacao = 'conta_pagar'
        AND ca.valor_limite >= p_valor
        AND (ca.centro_custo_id IS NULL OR ca.centro_custo_id = p_centro_custo_id)
        AND (ca.departamento IS NULL OR ca.departamento = p_departamento)
        AND (ca.classe_financeira IS NULL OR ca.classe_financeira = p_classe_financeira)
        AND (ca.usuario_id IS NULL OR ca.usuario_id = p_user_id)
        AND ca.is_active = true
    ) THEN
        RETURN TRUE;
    END IF;
    
    RETURN FALSE;
END;
$$;


ALTER FUNCTION financeiro.check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) OWNER TO postgres;

--
-- Name: check_financial_permission(uuid, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.check_financial_permission(p_user_id uuid, p_permission text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Verificar se Ã© super admin
    IF public.is_admin(p_user_id) THEN
        RETURN TRUE;
    END IF;
    
    -- Verificar permissÃ£o especÃ­fica do mÃ³dulo financeiro
    RETURN public.check_module_permission(p_user_id, 'financeiro', p_permission);
END;
$$;


ALTER FUNCTION financeiro.check_financial_permission(p_user_id uuid, p_permission text) OWNER TO postgres;

--
-- Name: create_approvals_trigger(); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.create_approvals_trigger() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    required_level INTEGER;
    current_level INTEGER := 1;
    approver_id UUID;
BEGIN
    -- Obter nÃ­vel de aprovaÃ§Ã£o necessÃ¡rio
    SELECT financeiro.get_required_approval_level(
        NEW.company_id,
        NEW.valor_original,
        NEW.centro_custo_id,
        NEW.departamento,
        NEW.classe_financeira
    ) INTO required_level;
    
    -- Criar aprovaÃ§Ãµes para cada nÃ­vel
    WHILE current_level <= required_level LOOP
        -- Buscar aprovador para o nÃ­vel atual
        SELECT ca.usuario_id INTO approver_id
        FROM financeiro.configuracoes_aprovacao ca
        WHERE ca.company_id = NEW.company_id
        AND ca.tipo_aprovacao = 'conta_pagar'
        AND ca.nivel_aprovacao = current_level
        AND ca.valor_limite >= NEW.valor_original
        AND (ca.centro_custo_id IS NULL OR ca.centro_custo_id = NEW.centro_custo_id)
        AND (ca.departamento IS NULL OR ca.departamento = NEW.departamento)
        AND (ca.classe_financeira IS NULL OR ca.classe_financeira = NEW.classe_financeira)
        AND ca.is_active = true
        LIMIT 1;
        
        -- Se encontrou aprovador, criar aprovaÃ§Ã£o
        IF approver_id IS NOT NULL THEN
            INSERT INTO financeiro.aprovacoes (
                company_id,
                entidade_tipo,
                entidade_id,
                nivel_aprovacao,
                aprovador_id,
                status
            ) VALUES (
                NEW.company_id,
                'conta_pagar',
                NEW.id,
                current_level,
                approver_id,
                'pendente'
            );
        END IF;
        
        current_level := current_level + 1;
    END LOOP;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION financeiro.create_approvals_trigger() OWNER TO postgres;

--
-- Name: generate_remittance_file(uuid, uuid); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.generate_remittance_file(p_company_id uuid, p_borderos_id uuid) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    remittance_data TEXT := '';
    bordero_record RECORD;
    conta_record RECORD;
BEGIN
    -- Obter dados do borderÃ´
    SELECT * INTO bordero_record
    FROM financeiro.borderos
    WHERE id = p_borderos_id
    AND company_id = p_company_id;
    
    -- Aqui seria implementada a geraÃ§Ã£o do arquivo CNAB
    -- Por enquanto, apenas um placeholder
    
    -- Exemplo de estrutura:
    -- 1. Header do arquivo
    -- 2. Registros de tÃ­tulos
    -- 3. Trailer do arquivo
    
    RETURN remittance_data;
END;
$$;


ALTER FUNCTION financeiro.generate_remittance_file(p_company_id uuid, p_borderos_id uuid) OWNER TO postgres;

--
-- Name: generate_titulo_number(uuid, character varying); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.generate_titulo_number(p_company_id uuid, p_tipo character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    next_number INTEGER;
    titulo_number VARCHAR(50);
BEGIN
    -- Obter prÃ³ximo nÃºmero sequencial
    IF p_tipo = 'PAGAR' THEN
        SELECT COALESCE(MAX(CAST(SUBSTRING(numero_titulo FROM '^[0-9]+') AS INTEGER)), 0) + 1
        INTO next_number
        FROM financeiro.contas_pagar
        WHERE company_id = p_company_id
        AND numero_titulo ~ '^[0-9]+';
    ELSE
        SELECT COALESCE(MAX(CAST(SUBSTRING(numero_titulo FROM '^[0-9]+') AS INTEGER)), 0) + 1
        INTO next_number
        FROM financeiro.contas_receber
        WHERE company_id = p_company_id
        AND numero_titulo ~ '^[0-9]+';
    END IF;
    
    -- Formatar nÃºmero do tÃ­tulo
    titulo_number := LPAD(next_number::TEXT, 6, '0') || '/' || EXTRACT(YEAR FROM NOW());
    
    RETURN titulo_number;
END;
$$;


ALTER FUNCTION financeiro.generate_titulo_number(p_company_id uuid, p_tipo character varying) OWNER TO postgres;

--
-- Name: get_aging_report(uuid, date); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.get_aging_report(p_company_id uuid, p_data_corte date DEFAULT CURRENT_DATE) RETURNS TABLE(fornecedor_nome character varying, total_pendente numeric, vencido_1_30 numeric, vencido_31_60 numeric, vencido_61_90 numeric, vencido_mais_90 numeric, a_vencer_1_30 numeric, a_vencer_31_60 numeric, a_vencer_mais_60 numeric)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cp.fornecedor_nome,
        SUM(cp.valor_atual) as total_pendente,
        SUM(CASE 
            WHEN cp.data_vencimento < p_data_corte - INTERVAL '30 days' 
            AND cp.data_vencimento >= p_data_corte - INTERVAL '60 days'
            THEN cp.valor_atual ELSE 0 END) as vencido_1_30,
        SUM(CASE 
            WHEN cp.data_vencimento < p_data_corte - INTERVAL '60 days' 
            AND cp.data_vencimento >= p_data_corte - INTERVAL '90 days'
            THEN cp.valor_atual ELSE 0 END) as vencido_31_60,
        SUM(CASE 
            WHEN cp.data_vencimento < p_data_corte - INTERVAL '90 days' 
            AND cp.data_vencimento >= p_data_corte - INTERVAL '120 days'
            THEN cp.valor_atual ELSE 0 END) as vencido_61_90,
        SUM(CASE 
            WHEN cp.data_vencimento < p_data_corte - INTERVAL '120 days'
            THEN cp.valor_atual ELSE 0 END) as vencido_mais_90,
        SUM(CASE 
            WHEN cp.data_vencimento >= p_data_corte 
            AND cp.data_vencimento <= p_data_corte + INTERVAL '30 days'
            THEN cp.valor_atual ELSE 0 END) as a_vencer_1_30,
        SUM(CASE 
            WHEN cp.data_vencimento > p_data_corte + INTERVAL '30 days' 
            AND cp.data_vencimento <= p_data_corte + INTERVAL '60 days'
            THEN cp.valor_atual ELSE 0 END) as a_vencer_31_60,
        SUM(CASE 
            WHEN cp.data_vencimento > p_data_corte + INTERVAL '60 days'
            THEN cp.valor_atual ELSE 0 END) as a_vencer_mais_60
    FROM financeiro.contas_pagar cp
    WHERE cp.company_id = p_company_id
    AND cp.status IN ('pendente', 'aprovado')
    AND cp.is_active = true
    GROUP BY cp.fornecedor_nome
    ORDER BY total_pendente DESC;
END;
$$;


ALTER FUNCTION financeiro.get_aging_report(p_company_id uuid, p_data_corte date) OWNER TO postgres;

--
-- Name: get_required_approval_level(uuid, numeric, uuid, text, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid DEFAULT NULL::uuid, p_departamento text DEFAULT NULL::text, p_classe_financeira text DEFAULT NULL::text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    max_level INTEGER := 0;
BEGIN
    -- Encontrar o maior nÃ­vel de aprovaÃ§Ã£o necessÃ¡rio
    SELECT COALESCE(MAX(ca.nivel_aprovacao), 1)
    INTO max_level
    FROM financeiro.configuracoes_aprovacao ca
    WHERE ca.company_id = p_company_id
    AND ca.tipo_aprovacao = 'conta_pagar'
    AND ca.valor_limite >= p_valor
    AND (ca.centro_custo_id IS NULL OR ca.centro_custo_id = p_centro_custo_id)
    AND (ca.departamento IS NULL OR ca.departamento = p_departamento)
    AND (ca.classe_financeira IS NULL OR ca.classe_financeira = p_classe_financeira)
    AND ca.is_active = true;
    
    RETURN COALESCE(max_level, 1);
END;
$$;


ALTER FUNCTION financeiro.get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) OWNER TO postgres;

--
-- Name: process_bank_return(uuid, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.process_bank_return(p_company_id uuid, p_arquivo_retorno text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    return_record RECORD;
    conta_pagar_record RECORD;
BEGIN
    -- Aqui seria implementada a lÃ³gica de processamento do arquivo CNAB
    -- Por enquanto, apenas um placeholder
    
    -- Exemplo de processamento:
    -- 1. Parse do arquivo CNAB
    -- 2. IdentificaÃ§Ã£o dos tÃ­tulos
    -- 3. AtualizaÃ§Ã£o dos status
    -- 4. CriaÃ§Ã£o de lanÃ§amentos contÃ¡beis
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION financeiro.process_bank_return(p_company_id uuid, p_arquivo_retorno text) OWNER TO postgres;

--
-- Name: testar_conectividade_bancaria(text, character varying); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.testar_conectividade_bancaria(p_base_url text, p_banco_codigo character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Aqui seria implementado o teste real de conectividade
    -- Por enquanto, retorna true se ambos os parÃ¢metros nÃ£o sÃ£o nulos
    RETURN p_base_url IS NOT NULL AND p_banco_codigo IS NOT NULL;
END;
$$;


ALTER FUNCTION financeiro.testar_conectividade_bancaria(p_base_url text, p_banco_codigo character varying) OWNER TO postgres;

--
-- Name: testar_conectividade_sefaz(text, character varying); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.testar_conectividade_sefaz(p_webservice_url text, p_uf character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Aqui seria implementado o teste real de conectividade
    -- Por enquanto, retorna true se a URL nÃ£o Ã© nula
    RETURN p_webservice_url IS NOT NULL AND p_uf IS NOT NULL;
END;
$$;


ALTER FUNCTION financeiro.testar_conectividade_sefaz(p_webservice_url text, p_uf character varying) OWNER TO postgres;

--
-- Name: update_approval_status(character varying, uuid, uuid, character varying, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    approval_record RECORD;
    all_approved BOOLEAN := FALSE;
    entity_company_id UUID;
BEGIN
    -- Obter registro de aprovaÃ§Ã£o
    SELECT * INTO approval_record
    FROM financeiro.aprovacoes
    WHERE entidade_tipo = p_entidade_tipo
    AND entidade_id = p_entidade_id
    AND aprovador_id = p_aprovador_id
    AND status = 'pendente';
    
    -- Se nÃ£o encontrou, retorna false
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Atualizar status da aprovaÃ§Ã£o
    UPDATE financeiro.aprovacoes
    SET status = p_status,
        data_aprovacao = CASE WHEN p_status = 'aprovado' THEN NOW() ELSE NULL END,
        observacoes = p_observacoes,
        updated_at = NOW()
    WHERE id = approval_record.id;
    
    -- Se foi aprovado, verificar se todas as aprovaÃ§Ãµes foram concluÃ­das
    IF p_status = 'aprovado' THEN
        -- Verificar se todas as aprovaÃ§Ãµes foram aprovadas
        SELECT NOT EXISTS(
            SELECT 1 FROM financeiro.aprovacoes
            WHERE entidade_tipo = p_entidade_tipo
            AND entidade_id = p_entidade_id
            AND status = 'pendente'
        ) INTO all_approved;
        
        -- Se todas foram aprovadas, atualizar status da entidade
        IF all_approved THEN
            -- Obter company_id da entidade
            IF p_entidade_tipo = 'conta_pagar' THEN
                SELECT company_id INTO entity_company_id
                FROM financeiro.contas_pagar
                WHERE id = p_entidade_id;
                
                -- Atualizar status para aprovado
                UPDATE financeiro.contas_pagar
                SET status = 'aprovado',
                    data_aprovacao = NOW(),
                    aprovado_por = p_aprovador_id,
                    updated_at = NOW()
                WHERE id = p_entidade_id;
            END IF;
        END IF;
    END IF;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION financeiro.update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text) OWNER TO postgres;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION financeiro.update_updated_at_column() OWNER TO postgres;

--
-- Name: validar_certificado_digital(text, text); Type: FUNCTION; Schema: financeiro; Owner: postgres
--

CREATE FUNCTION financeiro.validar_certificado_digital(p_certificado text, p_senha text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Aqui seria implementada a validaÃ§Ã£o real do certificado
    -- Por enquanto, retorna true se ambos os parÃ¢metros nÃ£o sÃ£o nulos
    RETURN p_certificado IS NOT NULL AND p_senha IS NOT NULL;
END;
$$;


ALTER FUNCTION financeiro.validar_certificado_digital(p_certificado text, p_senha text) OWNER TO postgres;

--
-- Name: get_auth(text); Type: FUNCTION; Schema: pgbouncer; Owner: supabase_admin
--

CREATE FUNCTION pgbouncer.get_auth(p_usename text) RETURNS TABLE(username text, password text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
begin
    raise debug 'PgBouncer auth request: %', p_usename;

    return query
    select 
        rolname::text, 
        case when rolvaliduntil < now() 
            then null 
            else rolpassword::text 
        end 
    from pg_authid 
    where rolname=$1 and rolcanlogin;
end;
$_$;


ALTER FUNCTION pgbouncer.get_auth(p_usename text) OWNER TO supabase_admin;

--
-- Name: adjust_bank_hours_balance(uuid, uuid, numeric, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN rh.adjust_bank_hours_balance(p_employee_id, p_company_id, p_hours_amount, p_description);
END;
$$;


ALTER FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) OWNER TO postgres;

--
-- Name: FUNCTION adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) IS 'Wrapper para rh.adjust_bank_hours_balance - permite chamada via RPC do Supabase';


--
-- Name: approve_attendance_correction(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_correction RECORD;
    v_time_record_id UUID;
BEGIN
    -- Buscar a correÃ§Ã£o
    SELECT * INTO v_correction
    FROM rh.attendance_corrections
    WHERE id = p_correction_id;
    
    IF v_correction IS NULL THEN
        RETURN false;
    END IF;
    
    -- Atualizar status da correÃ§Ã£o
    UPDATE rh.attendance_corrections
    SET 
        status = 'aprovado',
        aprovado_por = p_approved_by,
        aprovado_em = NOW(),
        observacoes = COALESCE(p_observacoes, observacoes),
        updated_at = NOW()
    WHERE id = p_correction_id;
    
    -- Buscar ou criar registro de ponto
    SELECT id INTO v_time_record_id
    FROM rh.time_records
    WHERE employee_id = v_correction.employee_id
    AND data_registro = v_correction.data_original;
    
    IF v_time_record_id IS NULL THEN
        -- Criar novo registro
        INSERT INTO rh.time_records (
            employee_id,
            company_id,
            data_registro,
            entrada,
            saida,
            status,
            observacoes,
            created_at,
            updated_at
        ) VALUES (
            v_correction.employee_id,
            v_correction.company_id,
            v_correction.data_original,
            v_correction.entrada_corrigida,
            v_correction.saida_corrigida,
            'aprovado',
            'Registro corrigido e aprovado',
            NOW(),
            NOW()
        ) RETURNING id INTO v_time_record_id;
    ELSE
        -- Atualizar registro existente
        UPDATE rh.time_records
        SET 
            entrada = v_correction.entrada_corrigida,
            saida = v_correction.saida_corrigida,
            status = 'aprovado',
            observacoes = COALESCE(observacoes, '') || ' | Registro corrigido e aprovado',
            updated_at = NOW()
        WHERE id = v_time_record_id;
    END IF;
    
    -- Registrar no histÃ³rico
    INSERT INTO rh.correction_history (
        correction_id,
        action,
        new_values,
        changed_by,
        reason
    ) VALUES (
        p_correction_id,
        'approved',
        jsonb_build_object(
            'aprovado_por', p_approved_by,
            'aprovado_em', NOW(),
            'observacoes', p_observacoes
        ),
        p_approved_by,
        'CorreÃ§Ã£o aprovada'
    );
    
    RETURN true;
END;
$$;


ALTER FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text) IS 'Aprova uma correÃ§Ã£o de ponto e atualiza o registro original';


--
-- Name: approve_compensation(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.compensation_requests 
    SET 
        status = 'aprovado',
        aprovado_por = approved_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = compensation_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_compensation(compensation_id uuid, approved_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text) IS 'Aprova uma solicitaÃ§Ã£o de compensaÃ§Ã£o';


--
-- Name: approve_equipment(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.equipment_rental_approvals 
    SET 
        status = 'aprovado',
        aprovado_por = approved_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = equipment_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_equipment(equipment_id uuid, approved_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text) IS 'Aprova uma solicitaÃ§Ã£o de equipamento';


--
-- Name: approve_medical_certificate(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.medical_certificates 
    SET 
        status = 'aprovado',
        aprovado_por = approved_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = certificate_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text) IS 'Aprova um atestado mÃ©dico';


--
-- Name: approve_reimbursement(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.reimbursement_requests 
    SET 
        status = 'aprovado',
        aprovado_por = approved_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = reimbursement_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text) IS 'Aprova uma solicitaÃ§Ã£o de reembolso';


--
-- Name: approve_vacation(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.vacations 
    SET 
        status = 'aprovado',
        aprovado_por = approved_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = vacation_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION approve_vacation(vacation_id uuid, approved_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text) IS 'Aprova uma solicitaÃ§Ã£o de fÃ©rias';


--
-- Name: atualizar_dias_gozados(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    dias_atuais INTEGER;
    dias_restantes INTEGER;
BEGIN
    -- Buscar dias atuais
    SELECT ve.dias_gozados, ve.dias_restantes
    INTO dias_atuais, dias_restantes
    FROM rh.vacation_entitlements ve
    WHERE ve.employee_id = employee_id_param
      AND ve.ano_aquisitivo = ano_param
      AND ve.status IN ('ativo', 'parcialmente_gozado');
    
    -- Verificar se hÃ¡ dias suficientes
    IF dias_restantes < dias_usados THEN
        RETURN false;
    END IF;
    
    -- Atualizar dias gozados
    UPDATE rh.vacation_entitlements
    SET 
        dias_gozados = dias_atuais + dias_usados,
        dias_restantes = dias_restantes - dias_usados,
        status = CASE 
            WHEN (dias_restantes - dias_usados) = 0 THEN 'gozado'
            ELSE 'parcialmente_gozado'
        END,
        updated_at = NOW()
    WHERE employee_id = employee_id_param
      AND ano_aquisitivo = ano_param
      AND status IN ('ativo', 'parcialmente_gozado');
    
    RETURN true;
END;
$$;


ALTER FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) OWNER TO postgres;

--
-- Name: FUNCTION atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) IS 'Atualiza os dias de fÃ©rias gozados por um funcionÃ¡rio';


--
-- Name: audit_approval_levels(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.audit_approval_levels() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM audit_log(
            NEW.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'create',
            'approval_levels',
            NEW.id,
            NULL,
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM audit_log(
            NEW.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'update',
            'approval_levels',
            NEW.id,
            row_to_json(OLD),
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM audit_log(
            OLD.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'delete',
            'approval_levels',
            OLD.id,
            row_to_json(OLD),
            NULL,
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION public.audit_approval_levels() OWNER TO postgres;

--
-- Name: audit_compensation_approvals(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.audit_compensation_approvals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_company_id UUID;
BEGIN
    -- Buscar company_id da solicitaÃ§Ã£o relacionada
    SELECT company_id INTO v_company_id
    FROM rh.compensation_requests
    WHERE id = COALESCE(NEW.compensation_request_id, OLD.compensation_request_id);
    
    IF TG_OP = 'INSERT' THEN
        PERFORM audit_log(
            v_company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'approve',
            'compensation_approvals',
            NEW.id,
            NULL,
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM audit_log(
            v_company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            CASE 
                WHEN OLD.status = 'pending' AND NEW.status = 'approved' THEN 'approve'
                WHEN OLD.status = 'pending' AND NEW.status = 'rejected' THEN 'reject'
                ELSE 'update'
            END,
            'compensation_approvals',
            NEW.id,
            row_to_json(OLD),
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION public.audit_compensation_approvals() OWNER TO postgres;

--
-- Name: audit_compensation_requests(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.audit_compensation_requests() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM audit_log(
            NEW.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'create',
            'compensation_requests',
            NEW.id,
            NULL,
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM audit_log(
            NEW.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'update',
            'compensation_requests',
            NEW.id,
            row_to_json(OLD),
            row_to_json(NEW),
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM audit_log(
            OLD.company_id,
            COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::UUID),
            'delete',
            'compensation_requests',
            OLD.id,
            row_to_json(OLD),
            NULL,
            inet_client_addr(),
            current_setting('request.headers', true)::json->>'user-agent',
            current_setting('request.headers', true)::json->>'x-session-id'
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$;


ALTER FUNCTION public.audit_compensation_requests() OWNER TO postgres;

--
-- Name: audit_log(uuid, uuid, character varying, character varying, uuid, jsonb, jsonb, inet, text, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb DEFAULT NULL::jsonb, p_new_values jsonb DEFAULT NULL::jsonb, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_session_id character varying DEFAULT NULL::character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_config RECORD;
    v_should_log BOOLEAN := false;
BEGIN
    -- Verificar se auditoria estÃ¡ habilitada para esta entidade
    SELECT * INTO v_config
    FROM rh.audit_config
    WHERE company_id = p_company_id
    AND entity_type = p_entity_type
    AND is_enabled = true;
    
    -- Se nÃ£o hÃ¡ configuraÃ§Ã£o especÃ­fica, usar configuraÃ§Ã£o padrÃ£o
    IF NOT FOUND THEN
        v_should_log := true; -- Log por padrÃ£o
    ELSE
        -- Verificar nÃ­vel de log
        CASE v_config.log_level
            WHEN 'all' THEN
                v_should_log := true;
            WHEN 'changes' THEN
                v_should_log := (p_old_values IS NOT NULL OR p_new_values IS NOT NULL);
            WHEN 'critical' THEN
                v_should_log := p_action IN ('create', 'delete', 'approve', 'reject');
            ELSE
                v_should_log := true;
        END CASE;
    END IF;
    
    -- Registrar log se necessÃ¡rio
    IF v_should_log THEN
        INSERT INTO rh.audit_logs (
            company_id,
            user_id,
            action,
            entity_type,
            entity_id,
            old_values,
            new_values,
            ip_address,
            user_agent,
            session_id
        ) VALUES (
            p_company_id,
            p_user_id,
            p_action,
            p_entity_type,
            p_entity_id,
            p_old_values,
            p_new_values,
            p_ip_address,
            p_user_agent,
            p_session_id
        );
    END IF;
END;
$$;


ALTER FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying) OWNER TO postgres;

--
-- Name: FUNCTION audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying) IS 'FunÃ§Ã£o para registrar logs de auditoria';


--
-- Name: buscar_anos_ferias_disponiveis(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) RETURNS TABLE(ano integer, dias_disponiveis integer, dias_gozados integer, dias_restantes integer, status character varying, data_vencimento date)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ve.ano_aquisitivo as ano,
        ve.dias_disponiveis,
        ve.dias_gozados,
        ve.dias_restantes,
        ve.status,
        ve.data_vencimento
    FROM rh.vacation_entitlements ve
    WHERE ve.employee_id = employee_id_param
      AND ve.status IN ('ativo', 'parcialmente_gozado')
    ORDER BY ve.ano_aquisitivo DESC;
END;
$$;


ALTER FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION buscar_anos_ferias_disponiveis(employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) IS 'Busca anos de fÃ©rias disponÃ­veis para um funcionÃ¡rio';


--
-- Name: calcular_dias_ferias_disponiveis(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    dias_disponiveis INTEGER;
BEGIN
    SELECT ve.dias_restantes
    INTO dias_disponiveis
    FROM rh.vacation_entitlements ve
    WHERE ve.employee_id = employee_id_param
      AND ve.ano_aquisitivo = ano_param
      AND ve.status IN ('ativo', 'parcialmente_gozado');
    
    RETURN COALESCE(dias_disponiveis, 0);
END;
$$;


ALTER FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) OWNER TO postgres;

--
-- Name: FUNCTION calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) IS 'Calcula dias disponÃ­veis de fÃ©rias para um funcionÃ¡rio em um ano especÃ­fico';


--
-- Name: calculate_medical_certificate_days(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_medical_certificate_days() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Calcular dias de afastamento automaticamente
  NEW.dias_afastamento = EXTRACT(DAY FROM (NEW.data_fim - NEW.data_inicio)) + 1;
  
  -- Atualizar data_aprovacao quando status for aprovado
  IF NEW.status = 'aprovado' AND OLD.status != 'aprovado' THEN
    NEW.data_aprovacao = NOW();
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.calculate_medical_certificate_days() OWNER TO postgres;

--
-- Name: calculate_medical_plan_benefits_total(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  total_benefits DECIMAL(10,2) := 0;
BEGIN
  SELECT COALESCE(SUM(emp.valor_mensal), 0)
  INTO total_benefits
  FROM rh.employee_medical_plans emp
  INNER JOIN rh.medical_plans mp ON emp.plan_id = mp.id
  INNER JOIN rh.medical_agreements ma ON mp.agreement_id = ma.id
  WHERE emp.company_id = company_id_param
    AND emp.employee_id = employee_id_param
    AND emp.entra_no_calculo_folha = true
    AND mp.entra_no_calculo_folha = true
    AND mp.tipo_folha = 'provento'
    AND emp.status = 'ativo'
    AND mp.ativo = true
    AND ma.ativo = true
    AND (emp.data_fim IS NULL OR emp.data_fim >= CURRENT_DATE)
    AND emp.data_inicio <= CURRENT_DATE;
    
  RETURN total_benefits;
END;
$$;


ALTER FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) IS 'Calcula o total de benefÃ­cios de convÃªnios mÃ©dicos para um funcionÃ¡rio';


--
-- Name: calculate_medical_plan_discounts_total(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  total_discounts DECIMAL(10,2) := 0;
BEGIN
  SELECT COALESCE(SUM(emp.valor_mensal), 0)
  INTO total_discounts
  FROM rh.employee_medical_plans emp
  INNER JOIN rh.medical_plans mp ON emp.plan_id = mp.id
  INNER JOIN rh.medical_agreements ma ON mp.agreement_id = ma.id
  WHERE emp.company_id = company_id_param
    AND emp.employee_id = employee_id_param
    AND emp.entra_no_calculo_folha = true
    AND mp.entra_no_calculo_folha = true
    AND mp.tipo_folha = 'desconto'
    AND emp.status = 'ativo'
    AND mp.ativo = true
    AND ma.ativo = true
    AND (emp.data_fim IS NULL OR emp.data_fim >= CURRENT_DATE)
    AND emp.data_inicio <= CURRENT_DATE;
    
  RETURN total_discounts;
END;
$$;


ALTER FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) IS 'Calcula o total de descontos de convÃªnios mÃ©dicos para um funcionÃ¡rio';


--
-- Name: calculate_payroll_benefits_total(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  total_benefits DECIMAL(10,2) := 0;
BEGIN
  SELECT COALESCE(SUM(COALESCE(eba.custom_value, bc.base_value, 0)), 0)
  INTO total_benefits
  FROM rh.employee_benefit_assignments eba
  INNER JOIN rh.benefit_configurations bc ON eba.benefit_config_id = bc.id
  WHERE eba.company_id = company_id_param
    AND eba.employee_id = employee_id_param
    AND eba.is_active = true
    AND bc.is_active = true
    AND bc.entra_no_calculo_folha = true
    AND (eba.end_date IS NULL OR eba.end_date >= CURRENT_DATE)
    AND eba.start_date <= CURRENT_DATE;
    
  RETURN total_benefits;
END;
$$;


ALTER FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) IS 'Calcula o total de benefÃ­cios que entram na folha de pagamento para um funcionÃ¡rio';


--
-- Name: calculate_work_hours(time without time zone, time without time zone, time without time zone, time without time zone); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone DEFAULT NULL::time without time zone, p_saida_almoco time without time zone DEFAULT NULL::time without time zone) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_horas_trabalhadas DECIMAL(4,2) := 0;
    v_horas_manha DECIMAL(4,2) := 0;
    v_horas_tarde DECIMAL(4,2) := 0;
    v_horas_almoco DECIMAL(4,2) := 0;
BEGIN
    -- Verificar se entrada e saÃ­da sÃ£o vÃ¡lidas
    IF p_entrada IS NULL OR p_saida IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Verificar se entrada Ã© anterior Ã  saÃ­da
    IF p_entrada >= p_saida THEN
        RETURN 0;
    END IF;
    
    -- Calcular horas totais do perÃ­odo
    v_horas_trabalhadas := EXTRACT(EPOCH FROM (p_saida - p_entrada)) / 3600;
    
    -- Se hÃ¡ horÃ¡rio de almoÃ§o, subtrair
    IF p_entrada_almoco IS NOT NULL AND p_saida_almoco IS NOT NULL THEN
        -- Verificar se horÃ¡rio de almoÃ§o estÃ¡ dentro do perÃ­odo de trabalho
        IF p_entrada_almoco >= p_entrada AND p_saida_almoco <= p_saida THEN
            v_horas_almoco := EXTRACT(EPOCH FROM (p_saida_almoco - p_entrada_almoco)) / 3600;
            v_horas_trabalhadas := v_horas_trabalhadas - v_horas_almoco;
        END IF;
    END IF;
    
    -- Arredondar para 2 casas decimais
    RETURN ROUND(v_horas_trabalhadas, 2);
END;
$$;


ALTER FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone) OWNER TO postgres;

--
-- Name: FUNCTION calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone) IS 'Calcula as horas trabalhadas considerando entrada, saÃ­da e horÃ¡rio de almoÃ§o';


--
-- Name: can_edit_solicitation(character varying, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    entity_status VARCHAR(20);
BEGIN
    -- Verificar status da entidade baseado no tipo
    CASE p_processo_tipo
        WHEN 'conta_pagar' THEN
            SELECT status INTO entity_status
            FROM financeiro.contas_pagar
            WHERE id = p_processo_id;
            
        WHEN 'requisicao_compra' THEN
            SELECT status INTO entity_status
            FROM compras.requisicoes_compra
            WHERE id = p_processo_id;
            
        WHEN 'cotacao_compra' THEN
            SELECT status INTO entity_status
            FROM compras.cotacoes
            WHERE id = p_processo_id;
            
        WHEN 'solicitacao_saida_material' THEN
            SELECT status INTO entity_status
            FROM public.solicitacoes_saida_materiais
            WHERE id = p_processo_id;
            
        WHEN 'solicitacao_transferencia_material' THEN
            SELECT status INTO entity_status
            FROM almoxarifado.transferencias
            WHERE id = p_processo_id;
    END CASE;
    
    -- Retorna true se nÃ£o estiver cancelado
    RETURN entity_status IS NOT NULL AND entity_status != 'cancelado';
END;
$$;


ALTER FUNCTION public.can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid) OWNER TO postgres;

--
-- Name: check_access_permission(text, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_access_permission(schema_name text, table_name text, action text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN 
  -- Por enquanto, sempre retorna true para permitir acesso
  -- TODO: Implementar verificaÃ§Ã£o de permissÃµes quando necessÃ¡rio
  RETURN true;
END;
$$;


ALTER FUNCTION public.check_access_permission(schema_name text, table_name text, action text) OWNER TO postgres;

--
-- Name: check_company_access(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_company_access(p_user_id uuid, p_company_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM user_companies uc
    WHERE uc.user_id = p_user_id 
    AND uc.company_id = p_company_id
    AND uc.ativo = true
  );
END;
$$;


ALTER FUNCTION public.check_company_access(p_user_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: check_compensation_approval_status(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_total_approvals INTEGER;
    v_approved_count INTEGER;
    v_rejected_count INTEGER;
BEGIN
    -- Contar total de aprovaÃ§Ãµes necessÃ¡rias
    SELECT COUNT(*) INTO v_total_approvals
    FROM rh.compensation_approvals
    WHERE compensation_request_id = p_compensation_request_id;
    
    -- Contar aprovaÃ§Ãµes aprovadas
    SELECT COUNT(*) INTO v_approved_count
    FROM rh.compensation_approvals
    WHERE compensation_request_id = p_compensation_request_id
    AND status = 'approved';
    
    -- Contar aprovaÃ§Ãµes rejeitadas
    SELECT COUNT(*) INTO v_rejected_count
    FROM rh.compensation_approvals
    WHERE compensation_request_id = p_compensation_request_id
    AND status = 'rejected';
    
    -- Determinar status
    IF v_rejected_count > 0 THEN
        RETURN 'rejected';
    ELSIF v_approved_count = v_total_approvals THEN
        RETURN 'approved';
    ELSE
        RETURN 'pending';
    END IF;
END;
$$;


ALTER FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION check_compensation_approval_status(p_compensation_request_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) IS 'Verifica o status geral de aprovaÃ§Ã£o de uma solicitaÃ§Ã£o';


--
-- Name: check_edit_permission(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_edit_permission() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    processo_tipo VARCHAR(50);
    processo_id UUID;
    can_edit BOOLEAN;
BEGIN
    -- Determinar o tipo de processo baseado na tabela
    IF TG_TABLE_NAME = 'contas_pagar' THEN
        processo_tipo := 'conta_pagar';
        processo_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_TABLE_NAME = 'requisicoes_compra' THEN
        processo_tipo := 'requisicao_compra';
        processo_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_TABLE_NAME = 'cotacoes' THEN
        processo_tipo := 'cotacao_compra';
        processo_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_TABLE_NAME = 'solicitacoes_saida_materiais' THEN
        processo_tipo := 'solicitacao_saida_material';
        processo_id := COALESCE(NEW.id, OLD.id);
    ELSIF TG_TABLE_NAME = 'transferencias' THEN
        processo_tipo := 'solicitacao_transferencia_material';
        processo_id := COALESCE(NEW.id, OLD.id);
    ELSE
        RETURN COALESCE(NEW, OLD);
    END IF;

    -- Verificar se pode editar
    SELECT public.can_edit_solicitation(processo_tipo, processo_id) INTO can_edit;

    -- Se nÃ£o pode editar, lanÃ§ar erro
    IF NOT can_edit THEN
        RAISE EXCEPTION 'Esta solicitaÃ§Ã£o foi cancelada e nÃ£o pode mais ser editada';
    END IF;

    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION public.check_edit_permission() OWNER TO postgres;

--
-- Name: check_entity_permission(uuid, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_entity_permission(p_user_id uuid, p_entity_name text, p_action text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  has_permission boolean := false;
  user_profile_id uuid;
BEGIN
  -- Verificar se o usuÃ¡rio Ã© admin
  IF public.is_admin_simple(p_user_id) THEN
    RETURN true;
  END IF;

  -- Buscar o perfil do usuÃ¡rio na empresa atual
  SELECT uc.profile_id INTO user_profile_id
  FROM public.user_companies uc
  WHERE uc.user_id = p_user_id 
    AND uc.ativo = true
    AND uc.company_id = (
      SELECT current_setting('app.current_company_id', true)::uuid
    )
  LIMIT 1;

  -- Se nÃ£o encontrou perfil, retorna false
  IF user_profile_id IS NULL THEN
    RETURN false;
  END IF;

  -- Verificar permissÃ£o especÃ­fica da entidade
  SELECT CASE 
    WHEN p_action = 'read' THEN ep.can_read
    WHEN p_action = 'create' THEN ep.can_create
    WHEN p_action = 'edit' THEN ep.can_edit
    WHEN p_action = 'delete' THEN ep.can_delete
    ELSE false
  END INTO has_permission
  FROM public.entity_permissions ep
  WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = p_entity_name;

  -- Se nÃ£o encontrou permissÃ£o especÃ­fica, retorna false
  RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION public.check_entity_permission(p_user_id uuid, p_entity_name text, p_action text) OWNER TO postgres;

--
-- Name: check_entity_permission_v2(uuid, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  has_permission boolean := false;
  user_profile_id uuid;
BEGIN
  -- Verificar se o usuÃ¡rio Ã© admin
  IF public.is_admin_simple(p_user_id) THEN
    RETURN true;
  END IF;

  -- Buscar o perfil do usuÃ¡rio na empresa atual
  SELECT uc.profile_id INTO user_profile_id
  FROM public.user_companies uc
  WHERE uc.user_id = p_user_id 
    AND uc.ativo = true
    AND uc.company_id = (
      SELECT current_setting('app.current_company_id', true)::uuid
    )
  LIMIT 1;

  -- Se nÃ£o encontrou perfil, retorna false
  IF user_profile_id IS NULL THEN
    RETURN false;
  END IF;

  -- Verificar permissÃ£o especÃ­fica da entidade
  SELECT CASE 
    WHEN p_action = 'read' THEN ep.can_read
    WHEN p_action = 'create' THEN ep.can_create
    WHEN p_action = 'edit' THEN ep.can_edit
    WHEN p_action = 'delete' THEN ep.can_delete
    ELSE false
  END INTO has_permission
  FROM public.entity_permissions ep
  WHERE ep.profile_id = user_profile_id
    AND ep.entity_name = p_entity_name;

  -- Se nÃ£o encontrou permissÃ£o especÃ­fica, retorna false
  RETURN COALESCE(has_permission, false);
END;
$$;


ALTER FUNCTION public.check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text) OWNER TO postgres;

--
-- Name: check_module_permission(uuid, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_module_permission(p_user_id uuid, p_module_name text, p_action text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  has_permission BOOLEAN := FALSE;
BEGIN
  -- Verificar se o usuÃ¡rio Ã© admin
  IF is_admin_simple(p_user_id) THEN
    RETURN TRUE;
  END IF;

  -- Verificar permissÃ£o especÃ­fica do mÃ³dulo
  SELECT 
    CASE p_action
      WHEN 'read' THEN mp.can_read
      WHEN 'create' THEN mp.can_create
      WHEN 'edit' THEN mp.can_edit
      WHEN 'delete' THEN mp.can_delete
      ELSE FALSE
    END
  INTO has_permission
  FROM module_permissions mp
  JOIN user_companies uc ON mp.profile_id = uc.profile_id
  WHERE uc.user_id = p_user_id
    AND mp.module_name = p_module_name
    AND uc.ativo = true;

  RETURN COALESCE(has_permission, FALSE);
END;
$$;


ALTER FUNCTION public.check_module_permission(p_user_id uuid, p_module_name text, p_action text) OWNER TO postgres;

--
-- Name: check_user_permission(text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_user_permission(p_module_name text, p_permission text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN 
  RETURN EXISTS (
    SELECT 1 FROM public.user_companies uc 
    JOIN public.profiles p ON uc.profile_id = p.id 
    JOIN public.module_permissions mp ON mp.profile_id = p.id 
    WHERE uc.user_id = auth.uid() 
    AND uc.ativo = true 
    AND mp.module_name = p_module_name 
    AND (
      (p_permission = 'read' AND mp.can_read = true) OR 
      (p_permission = 'create' AND mp.can_create = true) OR 
      (p_permission = 'edit' AND mp.can_edit = true) OR 
      (p_permission = 'delete' AND mp.can_delete = true)
    )
  );
END;
$$;


ALTER FUNCTION public.check_user_permission(p_module_name text, p_permission text) OWNER TO postgres;

--
-- Name: cleanup_old_audit_logs(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cleanup_old_audit_logs() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_config RECORD;
    v_cutoff_date TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Para cada configuraÃ§Ã£o de auditoria
    FOR v_config IN
        SELECT DISTINCT company_id, entity_type, retention_days
        FROM rh.audit_config
        WHERE is_enabled = true
    LOOP
        -- Calcular data de corte
        v_cutoff_date := NOW() - INTERVAL '1 day' * v_config.retention_days;
        
        -- Remover logs antigos
        DELETE FROM rh.audit_logs
        WHERE company_id = v_config.company_id
        AND entity_type = v_config.entity_type
        AND created_at < v_cutoff_date;
    END LOOP;
END;
$$;


ALTER FUNCTION public.cleanup_old_audit_logs() OWNER TO postgres;

--
-- Name: FUNCTION cleanup_old_audit_logs(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.cleanup_old_audit_logs() IS 'FunÃ§Ã£o para limpeza automÃ¡tica de logs antigos';


--
-- Name: create_approvals_for_process(character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    approver_record RECORD;
    approval_created BOOLEAN := false;
BEGIN
    -- Limpar aprovaÃ§Ãµes existentes para este processo
    DELETE FROM public.aprovacoes_unificada 
    WHERE processo_tipo = p_processo_tipo 
    AND processo_id = p_processo_id 
    AND company_id = p_company_id;

    -- Criar novas aprovaÃ§Ãµes baseadas nas configuraÃ§Ãµes
    FOR approver_record IN
        SELECT * FROM public.get_required_approvers(p_processo_tipo, p_processo_id, p_company_id)
        ORDER BY nivel, ordem
    LOOP
        INSERT INTO public.aprovacoes_unificada (
            company_id,
            processo_tipo,
            processo_id,
            nivel_aprovacao,
            aprovador_id,
            aprovador_original_id,
            status
        ) VALUES (
            p_company_id,
            p_processo_tipo,
            p_processo_id,
            approver_record.nivel,
            approver_record.aprovador_id,
            approver_record.aprovador_id,
            'pendente'
        );
        
        approval_created := true;
    END LOOP;

    RETURN approval_created;
END;
$$;


ALTER FUNCTION public.create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: create_approvals_on_insert(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_approvals_on_insert() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    processo_tipo VARCHAR(50);
BEGIN
    -- Determinar o tipo de processo baseado na tabela
    IF TG_TABLE_NAME = 'contas_pagar' THEN
        processo_tipo := 'conta_pagar';
    ELSIF TG_TABLE_NAME = 'requisicoes_compra' THEN
        processo_tipo := 'requisicao_compra';
    ELSIF TG_TABLE_NAME = 'cotacoes' THEN
        processo_tipo := 'cotacao_compra';
    ELSIF TG_TABLE_NAME = 'solicitacoes_saida_materiais' THEN
        processo_tipo := 'solicitacao_saida_material';
    ELSIF TG_TABLE_NAME = 'transferencias' THEN
        processo_tipo := 'solicitacao_transferencia_material';
    ELSE
        RETURN NEW;
    END IF;

    -- Criar aprovaÃ§Ãµes automÃ¡ticas
    PERFORM public.create_approvals_for_process(processo_tipo, NEW.id, NEW.company_id);

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.create_approvals_on_insert() OWNER TO postgres;

--
-- Name: create_calculation_log(uuid, text, text, integer, integer, text, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text DEFAULT NULL::text, usuario_id_param uuid DEFAULT NULL::uuid, usuario_nome_param text DEFAULT NULL::text) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  log_id UUID;
BEGIN
  INSERT INTO rh.calculation_logs (
    company_id,
    processo_id,
    tipo_processo,
    descricao_processo,
    mes_referencia,
    ano_referencia,
    status,
    progresso,
    total_funcionarios,
    funcionarios_processados,
    eventos_calculados,
    erros_encontrados,
    inicio_processamento,
    usuario_id,
    usuario_nome,
    logs_execucao,
    erros_execucao
  ) VALUES (
    company_id_param,
    processo_id_param,
    tipo_processo_param,
    descricao_processo_param,
    mes_referencia_param,
    ano_referencia_param,
    'iniciado',
    0,
    0,
    0,
    0,
    0,
    now(),
    usuario_id_param,
    usuario_nome_param,
    '[]'::jsonb,
    '[]'::jsonb
  ) RETURNING id INTO log_id;
  
  RETURN log_id;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao criar log de cÃ¡lculo: %', SQLERRM;
END;
$$;


ALTER FUNCTION public.create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text, usuario_id_param uuid, usuario_nome_param text) OWNER TO postgres;

--
-- Name: create_compensation_approvals(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_request RECORD;
    v_level_id UUID;
    v_approver RECORD;
BEGIN
    -- Buscar dados da solicitaÃ§Ã£o
    SELECT * INTO v_request
    FROM rh.compensation_requests
    WHERE id = p_compensation_request_id;
    
    -- Determinar nÃ­vel de aprovaÃ§Ã£o necessÃ¡rio
    v_level_id := get_required_approval_level(
        p_company_id,
        v_request.quantidade_horas,
        v_request.valor_total
    );
    
    -- Criar aprovaÃ§Ãµes para cada aprovador do nÃ­vel
    FOR v_approver IN
        SELECT ala.user_id, ala.is_primary
        FROM rh.approval_level_approvers ala
        WHERE ala.approval_level_id = v_level_id
        AND ala.is_active = true
    LOOP
        INSERT INTO rh.compensation_approvals (
            compensation_request_id,
            approval_level_id,
            approver_id,
            status
        ) VALUES (
            p_compensation_request_id,
            v_level_id,
            v_approver.user_id,
            'pending'
        );
    END LOOP;
END;
$$;


ALTER FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) IS 'Cria as aprovaÃ§Ãµes necessÃ¡rias para uma solicitaÃ§Ã£o';


--
-- Name: create_default_signature_config(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_default_signature_config() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO rh.time_record_signature_config (company_id, is_enabled, signature_period_days, reminder_days, require_manager_approval, auto_close_month)
    SELECT 
        id as company_id,
        false as is_enabled,
        5 as signature_period_days,
        3 as reminder_days,
        true as require_manager_approval,
        true as auto_close_month
    FROM companies
    WHERE id NOT IN (SELECT company_id FROM rh.time_record_signature_config)
    ON CONFLICT (company_id) DO NOTHING;
END;
$$;


ALTER FUNCTION public.create_default_signature_config() OWNER TO postgres;

--
-- Name: create_employee(uuid, text, text, date, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text DEFAULT 'ativo'::text, user_id_param uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  result_record record;
  result_json jsonb;
BEGIN
  -- Inserir funcionÃ¡rio
  INSERT INTO rh.employees (
    id,
    company_id,
    nome,
    cpf,
    data_admissao,
    status,
    user_id
  ) VALUES (
    gen_random_uuid(),
    company_id_param,
    nome_param,
    cpf_param,
    data_admissao_param,
    status_param,
    user_id_param
  ) RETURNING * INTO result_record;
  
  -- Converter resultado para JSON
  result_json := to_jsonb(result_record);
  
  RETURN result_json;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao criar funcionÃ¡rio: %', SQLERRM;
END;
$$;


ALTER FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid) OWNER TO postgres;

--
-- Name: create_employee(uuid, text, text, date, text, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text DEFAULT 'ativo'::text, user_id_param uuid DEFAULT NULL::uuid, matricula_param text DEFAULT NULL::text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  result_record record;
  result_json jsonb;
  generated_matricula text;
BEGIN
  -- Gerar matrÃ­cula se nÃ£o fornecida
  IF matricula_param IS NULL OR matricula_param = '' THEN
    generated_matricula := public.generate_employee_matricula(company_id_param);
  ELSE
    generated_matricula := matricula_param;
  END IF;
  
  -- Inserir funcionÃ¡rio
  INSERT INTO rh.employees (
    id,
    company_id,
    nome,
    cpf,
    data_admissao,
    status,
    user_id,
    matricula
  ) VALUES (
    gen_random_uuid(),
    company_id_param,
    nome_param,
    cpf_param,
    data_admissao_param,
    status_param,
    user_id_param,
    generated_matricula
  ) RETURNING * INTO result_record;
  
  -- Converter resultado para JSON
  result_json := to_jsonb(result_record);
  
  RETURN result_json;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao criar funcionÃ¡rio: %', SQLERRM;
END;
$$;


ALTER FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid, matricula_param text) OWNER TO postgres;

--
-- Name: create_entity_data(text, text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  result JSONB;
  sql_query TEXT;
  column_names TEXT;
  placeholders TEXT;
  param_values TEXT[];
  i INTEGER;
  key_value RECORD;
  value_text TEXT;
  param_count INTEGER;
  uuid_columns TEXT[] := ARRAY['employee_id', 'liberado_por', 'user_id', 'profile_id', 'correction_id', 'changed_by'];
  boolean_columns TEXT[] := ARRAY['liberado', 'ativo', 'is_active', 'pago', 'permitir_correcao_futura', 'exigir_justificativa', 'permitir_correcao_apos_aprovacao'];
  timestamp_columns TEXT[] := ARRAY['created_at', 'updated_at', 'liberado_em', 'data_agendamento', 'data_vencimento', 'data_realizacao', 'data_pagamento'];
BEGIN
  -- Log para debug
  RAISE NOTICE 'Creating entity: schema=%, table=%, company_id=%, data=%', 
    schema_name, table_name, company_id_param, data_param;
  
  -- Construir listas de colunas e placeholders
  column_names := '';
  placeholders := '';
  param_values := ARRAY[company_id_param::TEXT];
  i := 2;
  
  -- Iterar sobre os pares chave-valor do JSONB
  FOR key_value IN 
    SELECT key, value 
    FROM jsonb_each(data_param) 
    ORDER BY key
  LOOP
    -- Pular company_id se jÃ¡ estiver nos dados (evitar duplicaÃ§Ã£o)
    IF key_value.key = 'company_id' THEN
      CONTINUE;
    END IF;
    
    -- Adicionar nome da coluna (escapado)
    IF column_names = '' THEN
      column_names := quote_ident(key_value.key);
    ELSE
      column_names := column_names || ', ' || quote_ident(key_value.key);
    END IF;
    
    -- Adicionar placeholder com cast apropriado baseado no tipo da coluna
    IF key_value.key = ANY(uuid_columns) THEN
      IF placeholders = '' THEN
        placeholders := '$' || i || '::uuid';
      ELSE
        placeholders := placeholders || ', $' || i || '::uuid';
      END IF;
    ELSIF key_value.key = ANY(boolean_columns) THEN
      IF placeholders = '' THEN
        placeholders := '$' || i || '::boolean';
      ELSE
        placeholders := placeholders || ', $' || i || '::boolean';
      END IF;
    ELSIF key_value.key = ANY(timestamp_columns) THEN
      IF placeholders = '' THEN
        placeholders := '$' || i || '::timestamp with time zone';
      ELSE
        placeholders := placeholders || ', $' || i || '::timestamp with time zone';
      END IF;
    ELSE
      IF placeholders = '' THEN
        placeholders := '$' || i;
      ELSE
        placeholders := placeholders || ', $' || i;
      END IF;
    END IF;
    
    -- Converter valor para texto apropriado
    IF key_value.value IS NULL THEN
      value_text := 'NULL';
    ELSIF jsonb_typeof(key_value.value) = 'string' THEN
      value_text := key_value.value #>> '{}';
    ELSIF jsonb_typeof(key_value.value) = 'boolean' THEN
      value_text := (key_value.value #>> '{}');
    ELSIF jsonb_typeof(key_value.value) = 'number' THEN
      value_text := (key_value.value #>> '{}');
    ELSE
      value_text := key_value.value #>> '{}';
    END IF;
    
    -- Adicionar valor ao array
    param_values := param_values || value_text;
    i := i + 1;
  END LOOP;
  
  -- Construir query SQL
  sql_query := format('INSERT INTO %I.%I (company_id, %s) VALUES ($1::uuid, %s) RETURNING row_to_json(%I.%I.*)',
    schema_name,
    table_name,
    column_names,
    placeholders,
    schema_name,
    table_name
  );
  
  -- Log da query construÃ­da
  RAISE NOTICE 'SQL Query: %', sql_query;
  RAISE NOTICE 'Parameters: %', param_values;
  
  -- Executar query usando EXECUTE com USING
  param_count := array_length(param_values, 1);
  
  IF param_count = 1 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid;
  ELSIF param_count = 2 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2];
  ELSIF param_count = 3 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3];
  ELSIF param_count = 4 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3], param_values[4];
  ELSIF param_count = 5 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3], param_values[4], param_values[5];
  ELSIF param_count = 6 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3], param_values[4], param_values[5], param_values[6];
  ELSIF param_count = 7 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3], param_values[4], param_values[5], param_values[6], param_values[7];
  ELSIF param_count = 8 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2], param_values[3], param_values[4], param_values[5], param_values[6], param_values[7], param_values[8];
  ELSE
    RAISE EXCEPTION 'Muitos parÃ¢metros: %', param_count;
  END IF;
  
  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao criar dados: %', SQLERRM;
END;
$_$;


ALTER FUNCTION public.create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb) OWNER TO postgres;

--
-- Name: create_monthly_signature_records(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_monthly_signature_records(p_company_id uuid, p_month_year character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    config_record rh.time_record_signature_config%ROWTYPE;
    month_end_date DATE;
    signature_deadline TIMESTAMP WITH TIME ZONE;
    records_created INTEGER := 0;
    employee_record RECORD;
BEGIN
    -- Buscar configuraÃ§Ã£o da empresa
    SELECT * INTO config_record
    FROM rh.time_record_signature_config
    WHERE company_id = p_company_id;
    
    -- Se nÃ£o hÃ¡ configuraÃ§Ã£o ou estÃ¡ desabilitada, retorna 0
    IF NOT FOUND OR NOT config_record.is_enabled THEN
        RETURN 0;
    END IF;
    
    -- Calcular data de fim do mÃªs
    month_end_date := (p_month_year || '-01')::DATE + INTERVAL '1 month' - INTERVAL '1 day';
    
    -- Calcular prazo para assinatura
    signature_deadline := month_end_date + INTERVAL '1 day' + (config_record.signature_period_days || ' days')::INTERVAL;
    
    -- Buscar funcionÃ¡rios ativos que tiveram registros de ponto no mÃªs
    FOR employee_record IN
        SELECT DISTINCT e.id, e.nome
        FROM rh.employees e
        INNER JOIN rh.time_records tr ON tr.employee_id = e.id
        WHERE e.company_id = p_company_id
        AND e.status = 'ativo'
        AND tr.data_registro >= (p_month_year || '-01')::DATE
        AND tr.data_registro <= month_end_date
        AND e.id NOT IN (
            SELECT employee_id 
            FROM rh.time_record_signatures 
            WHERE month_year = p_month_year
        )
    LOOP
        -- Criar registro de assinatura
        INSERT INTO rh.time_record_signatures (
            company_id,
            employee_id,
            month_year,
            status,
            manager_approval_required,
            expires_at
        ) VALUES (
            p_company_id,
            employee_record.id,
            p_month_year,
            'pending',
            config_record.require_manager_approval,
            signature_deadline
        );
        
        records_created := records_created + 1;
    END LOOP;
    
    RETURN records_created;
END;
$$;


ALTER FUNCTION public.create_monthly_signature_records(p_company_id uuid, p_month_year character varying) OWNER TO postgres;

--
-- Name: create_periodic_exam(uuid, uuid, character varying, date, date, character varying, character varying, character varying, text, character varying, text, text[], numeric, boolean, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying DEFAULT 'agendado'::character varying, p_medico_responsavel character varying DEFAULT NULL::character varying, p_clinica_local character varying DEFAULT NULL::character varying, p_observacoes text DEFAULT NULL::text, p_resultado character varying DEFAULT NULL::character varying, p_restricoes text DEFAULT NULL::text, p_anexos text[] DEFAULT NULL::text[], p_custo numeric DEFAULT NULL::numeric, p_pago boolean DEFAULT false, p_data_pagamento date DEFAULT NULL::date) RETURNS TABLE(id uuid, company_id uuid, employee_id uuid, tipo_exame character varying, data_agendamento date, data_realizacao date, data_vencimento date, status character varying, medico_responsavel character varying, clinica_local character varying, observacoes text, resultado character varying, restricoes text, anexos text[], custo numeric, pago boolean, data_pagamento date, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  new_exam_id UUID;
  exam_record RECORD;
BEGIN
  -- Verificar se a empresa existe
  IF NOT EXISTS (SELECT 1 FROM companies WHERE companies.id = p_company_id) THEN
    RAISE EXCEPTION 'Empresa nÃ£o encontrada';
  END IF;

  -- Verificar se o funcionÃ¡rio existe e pertence Ã  empresa
  IF NOT EXISTS (
    SELECT 1 FROM rh.employees 
    WHERE rh.employees.id = p_employee_id AND rh.employees.company_id = p_company_id
  ) THEN
    RAISE EXCEPTION 'FuncionÃ¡rio nÃ£o encontrado ou nÃ£o pertence Ã  empresa';
  END IF;

  -- Inserir o exame
  INSERT INTO rh.periodic_exams (
    company_id,
    employee_id,
    tipo_exame,
    data_agendamento,
    data_vencimento,
    status,
    medico_responsavel,
    clinica_local,
    observacoes,
    resultado,
    restricoes,
    anexos,
    custo,
    pago,
    data_pagamento
  ) VALUES (
    p_company_id,
    p_employee_id,
    p_tipo_exame,
    p_data_agendamento,
    p_data_vencimento,
    p_status,
    p_medico_responsavel,
    p_clinica_local,
    p_observacoes,
    p_resultado,
    p_restricoes,
    p_anexos,
    p_custo,
    p_pago,
    p_data_pagamento
  ) RETURNING * INTO exam_record;

  -- Retornar o exame criado
  RETURN QUERY SELECT * FROM rh.periodic_exams WHERE rh.periodic_exams.id = exam_record.id;
END;
$$;


ALTER FUNCTION public.create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) OWNER TO postgres;

--
-- Name: create_profile(text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_profile(p_nome text, p_descricao text DEFAULT NULL::text, p_is_active boolean DEFAULT true) RETURNS TABLE(id uuid, nome text, descricao text, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  new_profile_id UUID;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para criar perfis
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem criar perfis';
  END IF;
  
  -- Verificar se o nome jÃ¡ existe
  IF EXISTS (SELECT 1 FROM profiles WHERE profiles.nome = p_nome) THEN
    RAISE EXCEPTION 'JÃ¡ existe um perfil com este nome: %', p_nome;
  END IF;
  
  -- Criar novo perfil
  INSERT INTO profiles (nome, descricao, is_active, permissoes)
  VALUES (p_nome, p_descricao, p_is_active, '{}')
  RETURNING profiles.id INTO new_profile_id;
  
  -- Retornar perfil criado
  RETURN QUERY
  SELECT 
    p.id,
    p.nome,
    p.descricao,
    p.is_active,
    p.created_at,
    p.updated_at
  FROM profiles p
  WHERE p.id = new_profile_id;
END;
$$;


ALTER FUNCTION public.create_profile(p_nome text, p_descricao text, p_is_active boolean) OWNER TO postgres;

--
-- Name: create_signature_config_for_new_company(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_signature_config_for_new_company() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO rh.time_record_signature_config (
        company_id,
        is_enabled,
        signature_period_days,
        reminder_days,
        require_manager_approval,
        auto_close_month
    ) VALUES (
        NEW.id,
        false,
        5,
        3,
        true,
        true
    );
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.create_signature_config_for_new_company() OWNER TO postgres;

--
-- Name: criar_periodo_aquisitivo(uuid, uuid, date, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    novo_id UUID;
    data_inicio DATE;
    data_fim DATE;
    data_vencimento DATE;
BEGIN
    -- Calcular datas do perÃ­odo aquisitivo
    data_inicio := data_admissao_param;
    data_fim := data_inicio + INTERVAL '12 months' - INTERVAL '1 day';
    data_vencimento := data_fim + INTERVAL '12 months';
    
    -- Inserir perÃ­odo aquisitivo
    INSERT INTO rh.vacation_entitlements (
        id,
        employee_id,
        company_id,
        ano_aquisitivo,
        data_inicio_periodo,
        data_fim_periodo,
        data_vencimento,
        dias_disponiveis,
        dias_gozados,
        dias_restantes,
        status,
        created_at,
        updated_at
    ) VALUES (
        gen_random_uuid(),
        employee_id_param,
        company_id_param,
        ano_param,
        data_inicio,
        data_fim,
        data_vencimento,
        30, -- 30 dias de fÃ©rias por ano
        0,  -- Nenhum dia gozado inicialmente
        30, -- 30 dias restantes
        'ativo',
        NOW(),
        NOW()
    ) RETURNING id INTO novo_id;
    
    RETURN novo_id;
END;
$$;


ALTER FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) OWNER TO postgres;

--
-- Name: FUNCTION criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) IS 'Cria um novo perÃ­odo aquisitivo de fÃ©rias';


--
-- Name: delete_entity_data(text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  affected_rows INTEGER;
  sql_query TEXT;
BEGIN
  -- Construir query dinÃ¢mica
  sql_query := format('DELETE FROM %I.%I WHERE id = $1 AND company_id = $2',
    schema_name,
    table_name
  );
  
  -- Executar query
  EXECUTE sql_query USING id_param, company_id_param;
  
  GET DIAGNOSTICS affected_rows = ROW_COUNT;
  
  RETURN affected_rows > 0;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao deletar dados: %', SQLERRM;
END;
$_$;


ALTER FUNCTION public.delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid) OWNER TO postgres;

--
-- Name: delete_periodic_exam(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_periodic_exam(p_exam_id uuid, p_company_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verificar se o exame existe e pertence Ã  empresa
  IF NOT EXISTS (
    SELECT 1 FROM rh.periodic_exams 
    WHERE rh.periodic_exams.id = p_exam_id AND rh.periodic_exams.company_id = p_company_id
  ) THEN
    RAISE EXCEPTION 'Exame nÃ£o encontrado ou nÃ£o pertence Ã  empresa';
  END IF;

  -- Deletar o exame
  DELETE FROM rh.periodic_exams 
  WHERE rh.periodic_exams.id = p_exam_id AND rh.periodic_exams.company_id = p_company_id;

  RETURN TRUE;
END;
$$;


ALTER FUNCTION public.delete_periodic_exam(p_exam_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: expire_signatures(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.expire_signatures() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    expired_count INTEGER := 0;
BEGIN
    UPDATE rh.time_record_signatures
    SET status = 'expired'
    WHERE status = 'pending'
    AND expires_at < NOW();
    
    GET DIAGNOSTICS expired_count = ROW_COUNT;
    
    RETURN expired_count;
END;
$$;


ALTER FUNCTION public.expire_signatures() OWNER TO postgres;

--
-- Name: generate_company_number(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_company_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Se numero_empresa nÃ£o foi fornecido, gerar automaticamente
  IF NEW.numero_empresa IS NULL OR NEW.numero_empresa = '' THEN
    NEW.numero_empresa := LPAD(nextval('public.company_number_seq')::text, 2, '0');
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.generate_company_number() OWNER TO postgres;

--
-- Name: generate_employee_matricula(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_employee_matricula(company_id_param uuid) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  company_number text;
  next_sequence integer;
  matricula text;
BEGIN
  -- Buscar nÃºmero da empresa
  SELECT numero_empresa INTO company_number
  FROM public.companies 
  WHERE id = company_id_param;
  
  -- Se nÃ£o encontrou a empresa, retornar erro
  IF company_number IS NULL THEN
    RAISE EXCEPTION 'Empresa nÃ£o encontrada';
  END IF;
  
  -- Buscar prÃ³ximo nÃºmero sequencial para esta empresa
  SELECT COALESCE(MAX(
    CAST(SUBSTRING(e.matricula FROM LENGTH(company_number) + 1) AS INTEGER)
  ), 0) + 1
  INTO next_sequence
  FROM rh.employees e
  WHERE e.company_id = company_id_param 
    AND e.matricula IS NOT NULL 
    AND e.matricula ~ ('^' || company_number || '[0-9]+$');
  
  -- Gerar matrÃ­cula no formato: numero_empresa + numero_sequencial (3 dÃ­gitos)
  matricula := company_number || LPAD(next_sequence::text, 3, '0');
  
  RETURN matricula;
END;
$_$;


ALTER FUNCTION public.generate_employee_matricula(company_id_param uuid) OWNER TO postgres;

--
-- Name: generate_monthly_signatures(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.generate_monthly_signatures(p_company_id uuid, p_month_year character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    config_record rh.time_record_signature_config%ROWTYPE;
    employee_record rh.employees%ROWTYPE;
    signature_expires_at TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Buscar configuraÃ§Ã£o da empresa
    SELECT * INTO config_record 
    FROM rh.time_record_signature_config 
    WHERE company_id = p_company_id AND is_enabled = true;
    
    IF NOT FOUND THEN
        RETURN;
    END IF;
    
    -- Calcular data de expiraÃ§Ã£o
    signature_expires_at := (p_month_year || '-01')::DATE + INTERVAL '1 month' + (config_record.signature_period_days || ' days')::INTERVAL;
    
    -- Gerar assinaturas para todos os funcionÃ¡rios ativos da empresa
    FOR employee_record IN 
        SELECT * FROM rh.employees 
        WHERE company_id = p_company_id 
        AND status = 'ativo'
        AND id NOT IN (
            SELECT employee_id FROM rh.time_record_signatures 
            WHERE month_year = p_month_year
        )
    LOOP
        INSERT INTO rh.time_record_signatures (
            company_id,
            employee_id,
            month_year,
            manager_approval_required,
            expires_at
        ) VALUES (
            p_company_id,
            employee_record.id,
            p_month_year,
            config_record.require_manager_approval,
            signature_expires_at
        );
    END LOOP;
END;
$$;


ALTER FUNCTION public.generate_monthly_signatures(p_company_id uuid, p_month_year character varying) OWNER TO postgres;

--
-- Name: get_audit_logs(uuid, character varying, uuid, character varying, uuid, timestamp with time zone, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying DEFAULT NULL::character varying, p_entity_id uuid DEFAULT NULL::uuid, p_action character varying DEFAULT NULL::character varying, p_user_id uuid DEFAULT NULL::uuid, p_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, company_id uuid, user_id uuid, action character varying, entity_type character varying, entity_id uuid, old_values jsonb, new_values jsonb, ip_address inet, user_agent text, session_id character varying, created_at timestamp with time zone, user_name text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.id,
        al.company_id,
        al.user_id,
        al.action,
        al.entity_type,
        al.entity_id,
        al.old_values,
        al.new_values,
        al.ip_address,
        al.user_agent,
        al.session_id,
        al.created_at,
        p.nome::TEXT
    FROM rh.audit_logs al
    LEFT JOIN profiles p ON p.id = al.user_id
    WHERE al.company_id = p_company_id
    AND (p_entity_type IS NULL OR al.entity_type = p_entity_type)
    AND (p_entity_id IS NULL OR al.entity_id = p_entity_id)
    AND (p_action IS NULL OR al.action = p_action)
    AND (p_user_id IS NULL OR al.user_id = p_user_id)
    AND (p_start_date IS NULL OR al.created_at >= p_start_date)
    AND (p_end_date IS NULL OR al.created_at <= p_end_date)
    ORDER BY al.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


ALTER FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: FUNCTION get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer) IS 'FunÃ§Ã£o para buscar logs de auditoria com filtros';


--
-- Name: get_bank_hours_balance(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) RETURNS TABLE(current_balance numeric, accumulated_hours numeric, compensated_hours numeric, expired_hours numeric, last_calculation_date date, has_bank_hours boolean, max_accumulation_hours numeric, accumulation_period_months integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT * FROM rh.get_bank_hours_balance(p_employee_id, p_company_id);
END;
$$;


ALTER FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_bank_hours_balance(p_employee_id uuid, p_company_id uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) IS 'Wrapper para rh.get_bank_hours_balance - permite chamada via RPC do Supabase';


--
-- Name: get_calculation_logs(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_calculation_logs(company_id_param uuid, filters jsonb DEFAULT '{}'::jsonb) RETURNS TABLE(id uuid, company_id uuid, processo_id text, tipo_processo text, descricao_processo text, mes_referencia integer, ano_referencia integer, status text, progresso integer, total_funcionarios integer, funcionarios_processados integer, eventos_calculados integer, erros_encontrados integer, inicio_processamento timestamp with time zone, fim_processamento timestamp with time zone, tempo_execucao_segundos integer, usuario_id uuid, usuario_nome text, logs_execucao jsonb, erros_execucao jsonb, resumo_calculos jsonb, observacoes text, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  where_clause TEXT := 'WHERE company_id = $1';
  order_clause TEXT := 'ORDER BY created_at DESC';
BEGIN
  -- Construir filtros dinÃ¢micos
  IF filters->>'mes_referencia' IS NOT NULL THEN
    where_clause := where_clause || ' AND mes_referencia = ' || (filters->>'mes_referencia')::text;
  END IF;
  
  IF filters->>'ano_referencia' IS NOT NULL THEN
    where_clause := where_clause || ' AND ano_referencia = ' || (filters->>'ano_referencia')::text;
  END IF;
  
  IF filters->>'status' IS NOT NULL THEN
    where_clause := where_clause || ' AND status = ''' || (filters->>'status')::text || '''';
  END IF;
  
  IF filters->>'tipo_processo' IS NOT NULL THEN
    where_clause := where_clause || ' AND tipo_processo = ''' || (filters->>'tipo_processo')::text || '''';
  END IF;
  
  -- Executar query
  RETURN QUERY EXECUTE format('
    SELECT 
      id, company_id, processo_id, tipo_processo, descricao_processo,
      mes_referencia, ano_referencia, status, progresso,
      total_funcionarios, funcionarios_processados, eventos_calculados, erros_encontrados,
      inicio_processamento, fim_processamento, tempo_execucao_segundos,
      usuario_id, usuario_nome, logs_execucao, erros_execucao, resumo_calculos,
      observacoes, created_at, updated_at
    FROM rh.calculation_logs
    %s
    %s
  ', where_clause, order_clause) USING company_id_param;
  
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao buscar logs de cÃ¡lculo: %', SQLERRM;
END;
$_$;


ALTER FUNCTION public.get_calculation_logs(company_id_param uuid, filters jsonb) OWNER TO postgres;

--
-- Name: get_correction_status(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_mes_ano VARCHAR(7);
    v_permission_record RECORD;
    v_settings RECORD;
    v_result JSONB;
BEGIN
    -- Formatar mÃªs/ano
    v_mes_ano := p_year || '-' || LPAD(p_month::TEXT, 2, '0');
    
    -- Buscar permissÃ£o especÃ­fica do funcionÃ¡rio
    SELECT * INTO v_permission_record
    FROM rh.employee_correction_permissions
    WHERE employee_id = p_employee_id 
    AND mes_ano = v_mes_ano;
    
    -- Buscar configuraÃ§Ãµes da empresa
    SELECT * INTO v_settings
    FROM rh.correction_settings
    WHERE company_id = (SELECT company_id FROM rh.employees WHERE id = p_employee_id)
    AND is_active = true;
    
    -- Se nÃ£o hÃ¡ configuraÃ§Ã£o, usar padrÃµes
    IF v_settings IS NULL THEN
        v_settings.dias_liberacao_correcao := 7;
        v_settings.permitir_correcao_futura := false;
        v_settings.exigir_justificativa := true;
        v_settings.permitir_correcao_apos_aprovacao := false;
        v_settings.dias_limite_correcao := 30;
    END IF;
    
    -- Verificar se estÃ¡ liberado
    IF v_permission_record IS NOT NULL AND v_permission_record.liberado = true THEN
        v_result := jsonb_build_object(
            'liberado', true,
            'liberado_por', v_permission_record.liberado_por,
            'liberado_em', v_permission_record.liberado_em,
            'observacoes', v_permission_record.observacoes
        );
    ELSE
        -- Verificar se estÃ¡ dentro do prazo de liberaÃ§Ã£o automÃ¡tica
        IF (CURRENT_DATE - (p_year || '-' || LPAD(p_month::TEXT, 2, '0') || '-01')::DATE) <= v_settings.dias_liberacao_correcao THEN
            v_result := jsonb_build_object(
                'liberado', true,
                'liberado_por', null,
                'liberado_em', null,
                'observacoes', 'LiberaÃ§Ã£o automÃ¡tica dentro do prazo'
            );
        ELSE
            v_result := jsonb_build_object(
                'liberado', false,
                'liberado_por', null,
                'liberado_em', null,
                'observacoes', 'Prazo de correÃ§Ã£o expirado'
            );
        END IF;
    END IF;
    
    -- Adicionar configuraÃ§Ãµes
    v_result := v_result || jsonb_build_object(
        'configuracoes', jsonb_build_object(
            'dias_liberacao_correcao', v_settings.dias_liberacao_correcao,
            'permitir_correcao_futura', v_settings.permitir_correcao_futura,
            'exigir_justificativa', v_settings.exigir_justificativa,
            'permitir_correcao_apos_aprovacao', v_settings.permitir_correcao_apos_aprovacao,
            'dias_limite_correcao', v_settings.dias_limite_correcao
        )
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) OWNER TO postgres;

--
-- Name: FUNCTION get_correction_status(p_employee_id uuid, p_year integer, p_month integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) IS 'Verifica se um funcionÃ¡rio pode fazer correÃ§Ãµes de ponto em um determinado mÃªs/ano';


--
-- Name: get_employee_all_benefits(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, employee_id uuid, benefit_config_id uuid, benefit_name text, benefit_type text, custom_value numeric, start_date date, end_date date, is_active boolean, entra_no_calculo_folha boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    eba.id,
    eba.employee_id,
    eba.benefit_config_id,
    bc.name as benefit_name,
    bc.benefit_type,
    eba.custom_value,
    eba.start_date,
    eba.end_date,
    eba.is_active,
    bc.entra_no_calculo_folha
  FROM rh.employee_benefit_assignments eba
  INNER JOIN rh.benefit_configurations bc ON eba.benefit_config_id = bc.id
  WHERE eba.company_id = company_id_param
    AND eba.is_active = true
    AND bc.is_active = true
    AND (employee_id_param IS NULL OR eba.employee_id = employee_id_param)
    AND (eba.end_date IS NULL OR eba.end_date >= CURRENT_DATE)
    AND eba.start_date <= CURRENT_DATE
  ORDER BY eba.employee_id, bc.name;
END;
$$;


ALTER FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_employee_all_benefits(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid) IS 'Busca todos os benefÃ­cios de funcionÃ¡rio (incluindo os que nÃ£o entram na folha)';


--
-- Name: get_employee_all_medical_plans(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, employee_id uuid, plan_id uuid, plan_name text, agreement_name text, plan_type text, category text, discount_type text, monthly_value numeric, final_value numeric, start_date date, end_date date, is_active boolean, enters_payroll boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    emp.id,
    emp.employee_id,
    emp.plan_id,
    mp.nome as plan_name,
    ma.nome as agreement_name,
    ma.tipo as plan_type,
    mp.categoria_desconto as category,
    mp.tipo_folha as discount_type,
    emp.valor_mensal as monthly_value,
    emp.valor_mensal as final_value,
    emp.data_inicio as start_date,
    emp.data_fim as end_date,
    (emp.status = 'ativo') as is_active,
    emp.entra_no_calculo_folha as enters_payroll
  FROM rh.employee_medical_plans emp
  INNER JOIN rh.medical_plans mp ON emp.plan_id = mp.id
  INNER JOIN rh.medical_agreements ma ON mp.agreement_id = ma.id
  WHERE emp.company_id = company_id_param
    AND emp.entra_no_calculo_folha = true
    AND mp.entra_no_calculo_folha = true
    AND emp.status = 'ativo'
    AND mp.ativo = true
    AND ma.ativo = true
    AND (employee_id_param IS NULL OR emp.employee_id = employee_id_param)
    AND (emp.data_fim IS NULL OR emp.data_fim >= CURRENT_DATE)
    AND emp.data_inicio <= CURRENT_DATE
  ORDER BY emp.employee_id, mp.tipo_folha, ma.nome, mp.nome;
END;
$$;


ALTER FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid) IS 'Busca todos os convÃªnios mÃ©dicos de funcionÃ¡rio (descontos + benefÃ­cios)';


--
-- Name: get_employee_medical_plan_discounts(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, employee_id uuid, plan_id uuid, plan_name text, agreement_name text, plan_type text, category text, discount_type text, monthly_value numeric, employee_discount_percent numeric, final_value numeric, start_date date, end_date date, is_active boolean, enters_payroll boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    emp.id,
    emp.employee_id,
    emp.plan_id,
    mp.nome as plan_name,
    ma.nome as agreement_name,
    ma.tipo as plan_type,
    mp.categoria_desconto as category,
    mp.tipo_folha as discount_type,
    emp.valor_mensal as monthly_value,
    mp.desconto_funcionario as employee_discount_percent,
    emp.valor_mensal as final_value, -- JÃ¡ vem com desconto aplicado
    emp.data_inicio as start_date,
    emp.data_fim as end_date,
    (emp.status = 'ativo') as is_active,
    emp.entra_no_calculo_folha as enters_payroll
  FROM rh.employee_medical_plans emp
  INNER JOIN rh.medical_plans mp ON emp.plan_id = mp.id
  INNER JOIN rh.medical_agreements ma ON mp.agreement_id = ma.id
  WHERE emp.company_id = company_id_param
    AND emp.entra_no_calculo_folha = true
    AND mp.entra_no_calculo_folha = true
    AND emp.status = 'ativo'
    AND mp.ativo = true
    AND ma.ativo = true
    AND (employee_id_param IS NULL OR emp.employee_id = employee_id_param)
    AND (emp.data_fim IS NULL OR emp.data_fim >= CURRENT_DATE)
    AND emp.data_inicio <= CURRENT_DATE
  ORDER BY emp.employee_id, ma.nome, mp.nome;
END;
$$;


ALTER FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid) IS 'Busca todos os convÃªnios mÃ©dicos de funcionÃ¡rio que entram no cÃ¡lculo da folha';


--
-- Name: get_employee_medical_plan_discounts_only(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, employee_id uuid, plan_id uuid, plan_name text, agreement_name text, plan_type text, category text, monthly_value numeric, final_value numeric, start_date date, end_date date, is_active boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    emp.id,
    emp.employee_id,
    emp.plan_id,
    mp.nome as plan_name,
    ma.nome as agreement_name,
    ma.tipo as plan_type,
    mp.categoria_desconto as category,
    emp.valor_mensal as monthly_value,
    emp.valor_mensal as final_value,
    emp.data_inicio as start_date,
    emp.data_fim as end_date,
    (emp.status = 'ativo') as is_active
  FROM rh.employee_medical_plans emp
  INNER JOIN rh.medical_plans mp ON emp.plan_id = mp.id
  INNER JOIN rh.medical_agreements ma ON mp.agreement_id = ma.id
  WHERE emp.company_id = company_id_param
    AND emp.entra_no_calculo_folha = true
    AND mp.entra_no_calculo_folha = true
    AND mp.tipo_folha = 'desconto'
    AND emp.status = 'ativo'
    AND mp.ativo = true
    AND ma.ativo = true
    AND (employee_id_param IS NULL OR emp.employee_id = employee_id_param)
    AND (emp.data_fim IS NULL OR emp.data_fim >= CURRENT_DATE)
    AND emp.data_inicio <= CURRENT_DATE
  ORDER BY emp.employee_id, ma.nome, mp.nome;
END;
$$;


ALTER FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid) IS 'Busca apenas descontos de convÃªnios mÃ©dicos de funcionÃ¡rio';


--
-- Name: get_employee_payroll_benefits(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, employee_id uuid, benefit_config_id uuid, benefit_name text, benefit_type text, custom_value numeric, start_date date, end_date date, is_active boolean, entra_no_calculo_folha boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    eba.id,
    eba.employee_id,
    eba.benefit_config_id,
    bc.name as benefit_name,
    bc.benefit_type,
    eba.custom_value,
    eba.start_date,
    eba.end_date,
    eba.is_active,
    bc.entra_no_calculo_folha
  FROM rh.employee_benefit_assignments eba
  INNER JOIN rh.benefit_configurations bc ON eba.benefit_config_id = bc.id
  WHERE eba.company_id = company_id_param
    AND eba.is_active = true
    AND bc.is_active = true
    AND bc.entra_no_calculo_folha = true
    AND (employee_id_param IS NULL OR eba.employee_id = employee_id_param)
    AND (eba.end_date IS NULL OR eba.end_date >= CURRENT_DATE)
    AND eba.start_date <= CURRENT_DATE
  ORDER BY eba.employee_id, bc.name;
END;
$$;


ALTER FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid) IS 'Busca benefÃ­cios de funcionÃ¡rio que entram no cÃ¡lculo da folha de pagamento';


--
-- Name: get_entity_data(text, text, text, jsonb, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_entity_data(schema_name text, table_name text, company_id_param text DEFAULT NULL::text, filters jsonb DEFAULT '{}'::jsonb, limit_param integer DEFAULT 100, offset_param integer DEFAULT 0, order_by text DEFAULT 'created_at'::text, order_direction text DEFAULT 'DESC'::text) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    query_text text;
    count_query text;
    where_clause text := '';
    order_clause text;
    total_rows bigint;
    filter_key text;
    filter_value text;
    current_user_id uuid;
    user_companies uuid[];
    has_company_access boolean := false;
    base_field text;
    company_uuid uuid;
    filter_conditions text[] := '{}';
    condition text;
BEGIN
    -- Obter ID do usuario atual
    current_user_id := auth.uid();
    
    -- Se nao ha usuario autenticado, negar acesso
    IF current_user_id IS NULL THEN
        RAISE EXCEPTION 'Usuario nao autenticado';
    END IF;
    
    -- Verificar se o usuario tem permissao para acessar esta entidade
    IF NOT public.check_access_permission(schema_name, table_name, 'read') THEN
        RAISE EXCEPTION 'Acesso negado para %:%.%', schema_name, table_name, 'read';
    END IF;
    
    -- Obter empresas do usuario
    SELECT ARRAY(
        SELECT uc.company_id 
        FROM public.user_companies uc 
        WHERE uc.user_id = current_user_id 
        AND uc.ativo = true
    ) INTO user_companies;
    
    -- Se for super admin, permitir acesso a todas as empresas
    IF public.is_admin_simple(current_user_id) THEN
        has_company_access := true;
    ELSE
        -- Verificar se o usuario tem acesso a empresa especifica
        IF company_id_param IS NOT NULL THEN
            has_company_access := (company_id_param::uuid = ANY(user_companies));
        ELSE
            -- Se nao especificou empresa, permitir se tiver acesso a pelo menos uma
            has_company_access := (array_length(user_companies, 1) > 0);
        END IF;
    END IF;
    
    -- Se nao tem acesso a empresa, negar
    IF NOT has_company_access THEN
        RAISE EXCEPTION 'Acesso negado para empresa %', COALESCE(company_id_param, 'nao especificada');
    END IF;
    
    -- Construir clausula WHERE basica
    where_clause := 'WHERE 1=1';
    
    -- Adicionar filtro de company_id se fornecido
    IF company_id_param IS NOT NULL THEN
        -- Converter para UUID de forma segura
        BEGIN
            company_uuid := company_id_param::uuid;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE EXCEPTION 'company_id_param invalido: %', company_id_param;
        END;
        
        where_clause := where_clause || ' AND company_id = $1';
    ELSE
        -- Se nao especificou empresa, filtrar pelas empresas do usuario
        IF NOT public.is_admin_simple(current_user_id) THEN
            where_clause := where_clause || ' AND company_id = ANY($2)';
        END IF;
    END IF;
    
    -- Adicionar filtros dinamicos do JSON de forma mais segura
    IF filters IS NOT NULL AND jsonb_typeof(filters) = 'object' THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each_text(filters)
        LOOP
            -- Pular filtros vazios ou com valor "all"
            IF filter_value IS NOT NULL AND filter_value != '' AND filter_value != 'all' THEN
                -- Construir condicao de forma mais segura
                condition := '';
                
                -- Verificar se e um campo UUID (termina com _id mas nao e ano_vigencia ou mes_vigencia)
                IF filter_key LIKE '%_id' AND filter_key NOT IN ('ano_vigencia', 'mes_vigencia') THEN
                    condition := filter_key || ' = ''' || filter_value || '''::uuid';
                -- Verificar se e um campo de data com comparacao >=
                ELSIF filter_key LIKE '%_gte' THEN
                    base_field := replace(filter_key, '_gte', '');
                    condition := base_field || ' >= ''' || filter_value || '''::date';
                -- Verificar se e um campo de data com comparacao <=
                ELSIF filter_key LIKE '%_lte' THEN
                    base_field := replace(filter_key, '_lte', '');
                    condition := base_field || ' <= ''' || filter_value || '''::date';
                -- Verificar se e um campo de data simples
                ELSIF filter_key LIKE '%_date' OR filter_key LIKE 'data_%' THEN
                    condition := filter_key || ' = ''' || filter_value || '''::date';
                -- Verificar se e um campo booleano
                ELSIF filter_value IN ('true', 'false') THEN
                    condition := filter_key || ' = ' || filter_value;
                -- Verificar se e um campo numerico (ano_vigencia, mes_vigencia, etc.)
                ELSIF filter_key IN ('ano_vigencia', 'mes_vigencia', 'dias_uteis_mes', 'tolerancia_atraso_minutos') THEN
                    condition := filter_key || ' = ' || filter_value;
                -- Campo de texto com busca
                ELSIF filter_key = 'search' THEN
                    condition := '(nome ILIKE ''%' || filter_value || '%'' OR matricula ILIKE ''%' || filter_value || '%'' OR cpf ILIKE ''%' || filter_value || '%'')';
                -- Outros campos de texto
                ELSE
                    condition := filter_key || ' = ''' || filter_value || '''';
                END IF;
                
                -- Adicionar condicao se foi construida
                IF condition != '' THEN
                    filter_conditions := array_append(filter_conditions, condition);
                END IF;
            END IF;
        END LOOP;
        
        -- Adicionar todas as condicoes de filtro
        IF array_length(filter_conditions, 1) > 0 THEN
            where_clause := where_clause || ' AND ' || array_to_string(filter_conditions, ' AND ');
        END IF;
    END IF;
    
    -- Construir clausula ORDER BY
    order_clause := 'ORDER BY ' || order_by || ' ' || order_direction;
    
    -- Query para contar total de registros
    count_query := format('SELECT COUNT(*) FROM %I.%I %s', schema_name, table_name, where_clause);
    
    -- Executar count query com parametros seguros
    IF company_id_param IS NOT NULL THEN
        EXECUTE count_query USING company_uuid INTO total_rows;
    ELSE
        EXECUTE count_query USING user_companies INTO total_rows;
    END IF;
    
    -- Query principal para buscar dados
    query_text := format('
        SELECT 
            t.id::text,
            to_jsonb(t.*) as data,
            %s::bigint as total_count
        FROM %I.%I t 
        %s 
        %s
        LIMIT %s OFFSET %s
    ', total_rows, schema_name, table_name, where_clause, order_clause, limit_param, offset_param);
    
    -- Executar query principal com parametros seguros
    IF company_id_param IS NOT NULL THEN
        RETURN QUERY EXECUTE query_text USING company_uuid;
    ELSE
        RETURN QUERY EXECUTE query_text USING user_companies;
    END IF;
END;
$_$;


ALTER FUNCTION public.get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) OWNER TO postgres;

--
-- Name: get_entity_data_simple(text, text, text, jsonb, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text DEFAULT NULL::text, filters jsonb DEFAULT '{}'::jsonb, limit_param integer DEFAULT 100, offset_param integer DEFAULT 0, order_by text DEFAULT 'created_at'::text, order_direction text DEFAULT 'DESC'::text) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    query_text text;
    count_query text;
    where_clause text := '';
    order_clause text;
    total_rows bigint;
    filter_key text;
    filter_value text;
BEGIN
    -- Construir clÃ¡usula WHERE
    where_clause := 'WHERE 1=1';
    
    -- Adicionar filtro de company_id se fornecido
    IF company_id_param IS NOT NULL THEN
        where_clause := where_clause || ' AND company_id = ''' || company_id_param || '''::uuid';
    END IF;
    
    -- Adicionar filtros dinÃ¢micos do JSON
    IF filters IS NOT NULL AND jsonb_typeof(filters) = 'object' THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each_text(filters)
        LOOP
            -- Pular filtros vazios ou com valor "all"
            IF filter_value IS NOT NULL AND filter_value != '' AND filter_value != 'all' THEN
                -- Verificar se Ã© um campo UUID
                IF filter_key LIKE '%_id' THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''::uuid';
                -- Verificar se Ã© um campo de data
                ELSIF filter_key LIKE '%_date' OR filter_key LIKE 'data_%' THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''::date';
                -- Verificar se Ã© um campo booleano
                ELSIF filter_value IN ('true', 'false') THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ' || filter_value;
                -- Campo de texto com busca
                ELSIF filter_key = 'search' THEN
                    where_clause := where_clause || ' AND (nome ILIKE ''%' || filter_value || '%'' OR matricula ILIKE ''%' || filter_value || '%'' OR cpf ILIKE ''%' || filter_value || '%'')';
                -- Outros campos de texto
                ELSE
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''';
                END IF;
            END IF;
        END LOOP;
    END IF;
    
    -- Construir clÃ¡usula ORDER BY
    order_clause := 'ORDER BY ' || order_by || ' ' || order_direction;
    
    -- Query para contar total de registros
    count_query := format('SELECT COUNT(*) FROM %I.%I %s', schema_name, table_name, where_clause);
    EXECUTE count_query INTO total_rows;
    
    -- Query principal para buscar dados
    query_text := format('
        SELECT 
            t.id::text,
            to_jsonb(t.*) as data,
            %s::bigint as total_count
        FROM %I.%I t 
        %s 
        %s
        LIMIT %s OFFSET %s
    ', total_rows, schema_name, table_name, where_clause, order_clause, limit_param, offset_param);
    
    RETURN QUERY EXECUTE query_text;
END;
$$;


ALTER FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) OWNER TO postgres;

--
-- Name: FUNCTION get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) IS 'FunÃ§Ã£o simplificada para buscar dados de entidades sem verificaÃ§Ã£o de permissÃµes';


--
-- Name: get_entity_data_with_joins(text, text, text, jsonb, jsonb, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_entity_data_with_joins(schema_name text, table_name text, company_id_param text DEFAULT NULL::text, joins jsonb DEFAULT '[]'::jsonb, filters jsonb DEFAULT '{}'::jsonb, limit_param integer DEFAULT 100, offset_param integer DEFAULT 0) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    query_text text;
    join_clause text := '';
    where_clause text := 'WHERE 1=1';
    i jsonb;
BEGIN
    -- Verificar permissÃµes
    IF NOT public.check_access_permission(schema_name, table_name, 'read') THEN
        RAISE EXCEPTION 'Acesso negado para %:%.%', schema_name, table_name, 'read';
    END IF;
    
    -- Construir JOINs dinÃ¢micos
    IF joins IS NOT NULL AND jsonb_typeof(joins) = 'array' THEN
        FOR i IN SELECT * FROM jsonb_array_elements(joins)
        LOOP
            join_clause := join_clause || ' LEFT JOIN ' || 
                (i->>'schema') || '.' || (i->>'table') || ' ' || (i->>'alias') || 
                ' ON ' || (i->>'condition');
        END LOOP;
    END IF;
    
    -- Construir WHERE (mesma lÃ³gica da funÃ§Ã£o anterior)
    IF company_id_param IS NOT NULL THEN
        where_clause := where_clause || ' AND ' || table_name || '.company_id = ''' || company_id_param || '''::uuid';
    END IF;
    
    -- Query principal
    query_text := format('
        SELECT 
            %I.id::text,
            to_jsonb(%I.*) as data,
            COUNT(*) OVER() as total_count
        FROM %I.%I %I
        %s
        %s
        LIMIT %s OFFSET %s
    ', table_name, table_name, schema_name, table_name, table_name, join_clause, where_clause, limit_param, offset_param);
    
    RETURN QUERY EXECUTE query_text;
END;
$$;


ALTER FUNCTION public.get_entity_data_with_joins(schema_name text, table_name text, company_id_param text, joins jsonb, filters jsonb, limit_param integer, offset_param integer) OWNER TO postgres;

--
-- Name: get_entity_permissions_by_profile(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_entity_permissions_by_profile(p_profile_id uuid) RETURNS TABLE(id uuid, profile_id uuid, entity_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para acessar este perfil
  -- Permitir acesso se auth.uid() for NULL (execuÃ§Ã£o direta) ou se for admin
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem gerenciar permissÃµes';
  END IF;
  
  RETURN QUERY
  SELECT 
    ep.id,
    ep.profile_id,
    ep.entity_name,
    ep.can_read,
    ep.can_create,
    ep.can_edit,
    ep.can_delete,
    ep.created_at,
    ep.updated_at
  FROM entity_permissions ep
  WHERE ep.profile_id = p_profile_id;
END;
$$;


ALTER FUNCTION public.get_entity_permissions_by_profile(p_profile_id uuid) OWNER TO postgres;

--
-- Name: get_gestor_dashboard_stats(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'total_funcionarios', (
            SELECT COUNT(*) 
            FROM rh.employees 
            WHERE company_id = company_uuid 
            AND status = 'ativo'
        ),
        'solicitacoes_pendentes', (
            SELECT COUNT(*) FROM (
                SELECT 1 FROM rh.vacations WHERE company_id = company_uuid AND status = 'pendente'
                UNION ALL
                SELECT 1 FROM rh.compensation_requests WHERE company_id = company_uuid AND status = 'pendente'
                UNION ALL
                SELECT 1 FROM rh.medical_certificates WHERE company_id = company_uuid AND status = 'pendente'
                UNION ALL
                SELECT 1 FROM rh.reimbursement_requests WHERE company_id = company_uuid AND status = 'pendente'
                UNION ALL
                SELECT 1 FROM rh.equipment_rental_approvals WHERE company_id = company_uuid AND status = 'pendente'
                UNION ALL
                SELECT 1 FROM rh.attendance_corrections WHERE company_id = company_uuid AND status = 'pendente'
            ) as total
        ),
        'ferias_pendentes', (
            SELECT COUNT(*) 
            FROM rh.vacations 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        ),
        'compensacoes_pendentes', (
            SELECT COUNT(*) 
            FROM rh.compensation_requests 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        ),
        'atestados_pendentes', (
            SELECT COUNT(*) 
            FROM rh.medical_certificates 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        ),
        'reembolsos_pendentes', (
            SELECT COUNT(*) 
            FROM rh.reimbursement_requests 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        ),
        'equipamentos_pendentes', (
            SELECT COUNT(*) 
            FROM rh.equipment_rental_approvals 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        ),
        'correcoes_pendentes', (
            SELECT COUNT(*) 
            FROM rh.attendance_corrections 
            WHERE company_id = company_uuid 
            AND status = 'pendente'
        )
    ) INTO result;
    
    RETURN result;
END;
$$;


ALTER FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_gestor_dashboard_stats(company_uuid uuid); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) IS 'Retorna estatÃ­sticas do dashboard do gestor para uma empresa';


--
-- Name: get_gestor_recent_activities(uuid, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_gestor_recent_activities(company_uuid uuid, limit_count integer DEFAULT 10) RETURNS TABLE(id uuid, tipo character varying, funcionario_nome character varying, funcionario_matricula character varying, data_solicitacao timestamp with time zone, status character varying, descricao text, dias integer, horas integer, valor numeric, observacoes text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
BEGIN
    RETURN QUERY
    (
        -- FÃ©rias
        SELECT 
            v.id,
            'ferias'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            v.created_at as data_solicitacao,
            v.status,
            CONCAT('SolicitaÃ§Ã£o de fÃ©rias de ', v.dias_solicitados, ' dias') as descricao,
            v.dias_solicitados as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            v.observacoes
        FROM rh.vacations v
        JOIN rh.employees e ON e.id = v.employee_id
        WHERE v.company_id = company_uuid
        
        UNION ALL
        
        -- CompensaÃ§Ãµes (usando quantidade_horas)
        SELECT 
            cr.id,
            'compensacao'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            cr.created_at as data_solicitacao,
            cr.status,
            CONCAT('SolicitaÃ§Ã£o de compensaÃ§Ã£o de ', cr.quantidade_horas, ' horas') as descricao,
            NULL::INTEGER as dias,
            cr.quantidade_horas::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            cr.observacoes
        FROM rh.compensation_requests cr
        JOIN rh.employees e ON e.id = cr.employee_id
        WHERE cr.company_id = company_uuid
        
        UNION ALL
        
        -- Atestados
        SELECT 
            mc.id,
            'atestado'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            mc.created_at as data_solicitacao,
            mc.status,
            CONCAT('Atestado mÃ©dico de ', mc.dias_afastamento, ' dias') as descricao,
            mc.dias_afastamento as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            mc.observacoes
        FROM rh.medical_certificates mc
        JOIN rh.employees e ON e.id = mc.employee_id
        WHERE mc.company_id = company_uuid
        
        UNION ALL
        
        -- Reembolsos
        SELECT 
            rr.id,
            'reembolso'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            rr.created_at as data_solicitacao,
            rr.status,
            CONCAT('SolicitaÃ§Ã£o de reembolso de R$ ', rr.valor_solicitado) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            rr.valor_solicitado as valor,
            rr.observacoes
        FROM rh.reimbursement_requests rr
        JOIN rh.employees e ON e.id = rr.employee_id
        WHERE rr.company_id = company_uuid
        
        UNION ALL
        
        -- Equipamentos
        SELECT 
            era.id,
            'equipamento'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            era.created_at as data_solicitacao,
            era.status,
            CONCAT('SolicitaÃ§Ã£o de equipamento: ', era.tipo_equipamento) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            era.observacoes
        FROM rh.equipment_rental_approvals era
        JOIN rh.employees e ON e.id = era.employee_id
        WHERE era.company_id = company_uuid
        
        UNION ALL
        
        -- CorreÃ§Ãµes de ponto
        SELECT 
            ac.id,
            'correcao_ponto'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            ac.created_at as data_solicitacao,
            ac.status,
            CONCAT('CorreÃ§Ã£o de ponto para ', ac.data_original) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            ac.observacoes
        FROM rh.attendance_corrections ac
        JOIN rh.employees e ON e.id = ac.employee_id
        WHERE ac.company_id = company_uuid
    )
    ORDER BY data_solicitacao DESC
    LIMIT limit_count;
END;
$_$;


ALTER FUNCTION public.get_gestor_recent_activities(company_uuid uuid, limit_count integer) OWNER TO postgres;

--
-- Name: get_module_permissions_by_profile(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_module_permissions_by_profile(p_profile_id uuid) RETURNS TABLE(id uuid, profile_id uuid, module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para acessar este perfil
  -- Permitir acesso se auth.uid() for NULL (execuÃ§Ã£o direta) ou se for admin
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem gerenciar permissÃµes';
  END IF;
  
  RETURN QUERY
  SELECT 
    mp.id,
    mp.profile_id,
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete,
    mp.created_at,
    mp.updated_at
  FROM module_permissions mp
  WHERE mp.profile_id = p_profile_id;
END;
$$;


ALTER FUNCTION public.get_module_permissions_by_profile(p_profile_id uuid) OWNER TO postgres;

--
-- Name: get_pending_approvals_for_user(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid) RETURNS TABLE(id uuid, tipo character varying, funcionario_nome character varying, funcionario_matricula character varying, data_solicitacao timestamp with time zone, status character varying, descricao text, dias integer, horas integer, valor numeric, observacoes text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
BEGIN
    RETURN QUERY
    (
        -- FÃ©rias pendentes
        SELECT 
            v.id,
            'ferias'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            v.created_at as data_solicitacao,
            v.status,
            CONCAT('SolicitaÃ§Ã£o de fÃ©rias de ', v.dias_solicitados, ' dias') as descricao,
            v.dias_solicitados as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            v.observacoes
        FROM rh.vacations v
        JOIN rh.employees e ON e.id = v.employee_id
        WHERE v.company_id = p_company_id
        AND v.status = 'pendente'
        
        UNION ALL
        
        -- CompensaÃ§Ãµes pendentes (usando quantidade_horas)
        SELECT 
            cr.id,
            'compensacao'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            cr.created_at as data_solicitacao,
            cr.status,
            CONCAT('SolicitaÃ§Ã£o de compensaÃ§Ã£o de ', cr.quantidade_horas, ' horas') as descricao,
            NULL::INTEGER as dias,
            cr.quantidade_horas::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            cr.observacoes
        FROM rh.compensation_requests cr
        JOIN rh.employees e ON e.id = cr.employee_id
        WHERE cr.company_id = p_company_id
        AND cr.status = 'pendente'
        
        UNION ALL
        
        -- Atestados pendentes
        SELECT 
            mc.id,
            'atestado'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            mc.created_at as data_solicitacao,
            mc.status,
            CONCAT('Atestado mÃ©dico de ', mc.dias_afastamento, ' dias') as descricao,
            mc.dias_afastamento as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            mc.observacoes
        FROM rh.medical_certificates mc
        JOIN rh.employees e ON e.id = mc.employee_id
        WHERE mc.company_id = p_company_id
        AND mc.status = 'pendente'
        
        UNION ALL
        
        -- Reembolsos pendentes
        SELECT 
            rr.id,
            'reembolso'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            rr.created_at as data_solicitacao,
            rr.status,
            CONCAT('SolicitaÃ§Ã£o de reembolso de R$ ', rr.valor_solicitado) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            rr.valor_solicitado as valor,
            rr.observacoes
        FROM rh.reimbursement_requests rr
        JOIN rh.employees e ON e.id = rr.employee_id
        WHERE rr.company_id = p_company_id
        AND rr.status = 'pendente'
        
        UNION ALL
        
        -- Equipamentos pendentes
        SELECT 
            era.id,
            'equipamento'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            era.created_at as data_solicitacao,
            era.status,
            CONCAT('SolicitaÃ§Ã£o de equipamento: ', era.tipo_equipamento) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            era.observacoes
        FROM rh.equipment_rental_approvals era
        JOIN rh.employees e ON e.id = era.employee_id
        WHERE era.company_id = p_company_id
        AND era.status = 'pendente'
        
        UNION ALL
        
        -- CorreÃ§Ãµes de ponto pendentes
        SELECT 
            ac.id,
            'correcao_ponto'::VARCHAR(50) as tipo,
            e.nome as funcionario_nome,
            e.matricula as funcionario_matricula,
            ac.created_at as data_solicitacao,
            ac.status,
            CONCAT('CorreÃ§Ã£o de ponto para ', ac.data_original) as descricao,
            NULL::INTEGER as dias,
            NULL::INTEGER as horas,
            NULL::DECIMAL(10,2) as valor,
            ac.observacoes
        FROM rh.attendance_corrections ac
        JOIN rh.employees e ON e.id = ac.employee_id
        WHERE ac.company_id = p_company_id
        AND ac.status = 'pendente'
    )
    ORDER BY data_solicitacao DESC;
END;
$_$;


ALTER FUNCTION public.get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: get_periodic_exams(uuid, uuid, character varying, character varying, character varying, date, date, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_periodic_exams(p_company_id uuid, p_employee_id uuid DEFAULT NULL::uuid, p_tipo_exame character varying DEFAULT NULL::character varying, p_status character varying DEFAULT NULL::character varying, p_resultado character varying DEFAULT NULL::character varying, p_data_inicio date DEFAULT NULL::date, p_data_fim date DEFAULT NULL::date, p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, company_id uuid, employee_id uuid, employee_name character varying, tipo_exame character varying, data_agendamento date, data_realizacao date, data_vencimento date, status character varying, medico_responsavel character varying, clinica_local character varying, observacoes text, resultado character varying, restricoes text, anexos text[], custo numeric, pago boolean, data_pagamento date, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pe.id,
    pe.company_id,
    pe.employee_id,
    e.nome as employee_name,
    pe.tipo_exame,
    pe.data_agendamento,
    pe.data_realizacao,
    pe.data_vencimento,
    pe.status,
    pe.medico_responsavel,
    pe.clinica_local,
    pe.observacoes,
    pe.resultado,
    pe.restricoes,
    pe.anexos,
    pe.custo,
    pe.pago,
    pe.data_pagamento,
    pe.created_at,
    pe.updated_at
  FROM rh.periodic_exams pe
  LEFT JOIN rh.employees e ON pe.employee_id = e.id
  WHERE pe.company_id = p_company_id
    AND (p_employee_id IS NULL OR pe.employee_id = p_employee_id)
    AND (p_tipo_exame IS NULL OR pe.tipo_exame = p_tipo_exame)
    AND (p_status IS NULL OR pe.status = p_status)
    AND (p_resultado IS NULL OR pe.resultado = p_resultado)
    AND (p_data_inicio IS NULL OR pe.data_agendamento >= p_data_inicio)
    AND (p_data_fim IS NULL OR pe.data_agendamento <= p_data_fim)
  ORDER BY pe.data_agendamento DESC
  LIMIT p_limit OFFSET p_offset;
END;
$$;


ALTER FUNCTION public.get_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: get_required_approval_level(uuid, numeric, numeric); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric DEFAULT NULL::numeric) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_level_id UUID;
BEGIN
    SELECT id INTO v_level_id
    FROM rh.approval_levels
    WHERE company_id = p_company_id
    AND is_active = true
    AND (
        (max_hours IS NULL OR p_hours <= max_hours) AND
        (max_amount IS NULL OR p_amount IS NULL OR p_amount <= max_amount)
    )
    ORDER BY level_order ASC
    LIMIT 1;
    
    RETURN v_level_id;
END;
$$;


ALTER FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric) OWNER TO postgres;

--
-- Name: FUNCTION get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric) IS 'Determina o nÃ­vel de aprovaÃ§Ã£o necessÃ¡rio baseado em horas e valor';


--
-- Name: get_required_approvers(character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) RETURNS TABLE(nivel integer, aprovador_id uuid, is_primary boolean, ordem integer)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    processo_valor DECIMAL(15,2) := 0;
    processo_centro_custo_id UUID;
    processo_departamento VARCHAR(100);
    processo_classe_financeira VARCHAR(100);
    processo_usuario_id UUID;
    config_record RECORD;
    aprovador_record RECORD;
BEGIN
    -- Obter dados da solicitaÃ§Ã£o baseado no tipo
    CASE p_processo_tipo
        WHEN 'conta_pagar' THEN
            SELECT valor_original, centro_custo_id, departamento, classe_financeira, usuario_id
            INTO processo_valor, processo_centro_custo_id, processo_departamento, processo_classe_financeira, processo_usuario_id
            FROM financeiro.contas_pagar
            WHERE id = p_processo_id AND company_id = p_company_id;
            
        WHEN 'requisicao_compra' THEN
            SELECT valor_total, centro_custo_id, solicitante_id
            INTO processo_valor, processo_centro_custo_id, processo_usuario_id
            FROM compras.requisicoes_compra
            WHERE id = p_processo_id AND company_id = p_company_id;
            
        WHEN 'cotacao_compra' THEN
            SELECT valor_total, centro_custo_id
            INTO processo_valor, processo_centro_custo_id
            FROM compras.cotacoes
            WHERE id = p_processo_id AND company_id = p_company_id;
            
        WHEN 'solicitacao_saida_material' THEN
            SELECT valor_total, centro_custo_id, funcionario_solicitante_id
            INTO processo_valor, processo_centro_custo_id, processo_usuario_id
            FROM public.solicitacoes_saida_materiais
            WHERE id = p_processo_id AND company_id = p_company_id;
            
        WHEN 'solicitacao_transferencia_material' THEN
            SELECT valor_total, centro_custo_id
            INTO processo_valor, processo_centro_custo_id
            FROM almoxarifado.transferencias
            WHERE id = p_processo_id AND company_id = p_company_id;
    END CASE;

    -- Buscar configuraÃ§Ãµes de aprovaÃ§Ã£o que se aplicam
    FOR config_record IN
        SELECT * FROM public.configuracoes_aprovacao_unificada
        WHERE company_id = p_company_id
        AND processo_tipo = p_processo_tipo
        AND ativo = true
        AND (valor_limite IS NULL OR valor_limite >= processo_valor)
        AND (centro_custo_id IS NULL OR centro_custo_id = processo_centro_custo_id)
        AND (departamento IS NULL OR departamento = processo_departamento)
        AND (classe_financeira IS NULL OR classe_financeira = processo_classe_financeira)
        AND (usuario_id IS NULL OR usuario_id = processo_usuario_id)
        ORDER BY nivel_aprovacao, valor_limite DESC
    LOOP
        -- Processar aprovadores do JSONB
        FOR aprovador_record IN
            SELECT 
                (aprovador->>'user_id')::UUID as user_id,
                COALESCE((aprovador->>'is_primary')::BOOLEAN, false) as is_primary,
                COALESCE((aprovador->>'ordem')::INTEGER, 0) as ordem
            FROM jsonb_array_elements(config_record.aprovadores) as aprovador
        LOOP
            nivel := config_record.nivel_aprovacao;
            aprovador_id := aprovador_record.user_id;
            is_primary := aprovador_record.is_primary;
            ordem := aprovador_record.ordem;
            RETURN NEXT;
        END LOOP;
    END LOOP;
END;
$$;


ALTER FUNCTION public.get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: get_signature_stats(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_signature_stats(p_company_id uuid, p_month_year character varying DEFAULT NULL::character varying) RETURNS TABLE(total_signatures bigint, pending_signatures bigint, signed_signatures bigint, expired_signatures bigint, rejected_signatures bigint, approved_signatures bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_signatures,
        COUNT(*) FILTER (WHERE status = 'pending') as pending_signatures,
        COUNT(*) FILTER (WHERE status = 'signed') as signed_signatures,
        COUNT(*) FILTER (WHERE status = 'expired') as expired_signatures,
        COUNT(*) FILTER (WHERE status = 'rejected') as rejected_signatures,
        COUNT(*) FILTER (WHERE status = 'approved') as approved_signatures
    FROM rh.time_record_signatures
    WHERE company_id = p_company_id
    AND (p_month_year IS NULL OR month_year = p_month_year);
END;
$$;


ALTER FUNCTION public.get_signature_stats(p_company_id uuid, p_month_year character varying) OWNER TO postgres;

--
-- Name: get_time_records_simple(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_time_records_simple(company_id_param uuid) RETURNS TABLE(id uuid, employee_id uuid, company_id uuid, data_registro date, entrada time without time zone, saida time without time zone, entrada_almoco time without time zone, saida_almoco time without time zone, entrada_extra1 time without time zone, saida_extra1 time without time zone, horas_trabalhadas numeric, horas_extras numeric, horas_faltas numeric, status character varying, observacoes text, aprovado_por uuid, aprovado_em timestamp with time zone, created_at timestamp with time zone, updated_at timestamp with time zone, employee_nome character varying, employee_matricula character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verificar se o usuÃ¡rio tem acesso Ã  empresa
  IF NOT public.user_has_company_access_new(auth.uid(), company_id_param) THEN
    RAISE EXCEPTION 'UsuÃ¡rio nÃ£o tem acesso a esta empresa';
  END IF;

  -- Retornar registros de ponto da empresa
  RETURN QUERY
  SELECT 
    tr.id,
    tr.employee_id,
    tr.company_id,
    tr.data_registro,
    tr.entrada,
    tr.saida,
    tr.entrada_almoco,
    tr.saida_almoco,
    tr.entrada_extra1,
    tr.saida_extra1,
    tr.horas_trabalhadas,
    tr.horas_extras,
    tr.horas_faltas,
    tr.status,
    tr.observacoes,
    tr.aprovado_por,
    tr.aprovado_em,
    tr.created_at,
    tr.updated_at,
    e.nome as employee_nome,
    e.matricula as employee_matricula
  FROM rh.time_records tr
  LEFT JOIN rh.employees e ON e.id = tr.employee_id
  WHERE tr.company_id = company_id_param
  ORDER BY tr.data_registro DESC, tr.created_at DESC;
END;
$$;


ALTER FUNCTION public.get_time_records_simple(company_id_param uuid) OWNER TO postgres;

--
-- Name: get_user_companies(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_companies() RETURNS uuid[]
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN 
  RETURN ARRAY(
    SELECT uc.company_id 
    FROM public.user_companies uc 
    WHERE uc.user_id = auth.uid() 
    AND uc.ativo = true
  );
END;
$$;


ALTER FUNCTION public.get_user_companies() OWNER TO postgres;

--
-- Name: get_user_permissions(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_permissions(p_user_id uuid DEFAULT auth.uid()) RETURNS TABLE(module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Se for super admin, retorna todas as permissÃµes
  IF is_admin_new(p_user_id) THEN
    RETURN QUERY
    SELECT DISTINCT
      mp.module_name,
      true as can_read,
      true as can_create,
      true as can_edit,
      true as can_delete
    FROM module_permissions mp;
    RETURN;
  END IF;
  
  -- Retorna permissÃµes especÃ­ficas do usuÃ¡rio
  RETURN QUERY
  SELECT 
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete
  FROM user_companies uc
  JOIN module_permissions mp ON uc.profile_id = mp.profile_id
  WHERE uc.user_id = p_user_id
  AND uc.ativo = true;
END;
$$;


ALTER FUNCTION public.get_user_permissions(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_permissions_simple(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_permissions_simple(p_user_id uuid DEFAULT auth.uid()) RETURNS TABLE(module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete
  FROM module_permissions mp
  JOIN user_companies uc ON mp.profile_id = uc.profile_id
  WHERE uc.user_id = p_user_id
    AND uc.ativo = true;
END;
$$;


ALTER FUNCTION public.get_user_permissions_simple(p_user_id uuid) OWNER TO postgres;

--
-- Name: get_user_profile(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_user_profile(user_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN 
  RETURN (
    SELECT json_build_object(
      'profile_id', p.id, 
      'profile_name', p.name, 
      'permissoes_gerais', p.permissions,
      'company_id', uc.company_id,
      'ativo', uc.ativo
    ) 
    FROM public.user_companies uc 
    JOIN public.profiles p ON uc.profile_id = p.id 
    WHERE uc.user_id = get_user_profile.user_id 
    AND uc.ativo = true 
    LIMIT 1
  );
END;
$$;


ALTER FUNCTION public.get_user_profile(user_id uuid) OWNER TO postgres;

--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
BEGIN
  -- Insere na tabela public.users apenas com dados bÃ¡sicos
  INSERT INTO public.users (id, nome, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'nome', NEW.email),
    NEW.email
  );
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.handle_new_user() OWNER TO postgres;

--
-- Name: FUNCTION handle_new_user(); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.handle_new_user() IS 'FunÃ§Ã£o simplificada que apenas cria entrada bÃ¡sica em public.users. 
O vÃ­nculo usuÃ¡rio-funcionÃ¡rio agora Ã© feito manualmente no modal "Novo FuncionÃ¡rio".';


--
-- Name: is_admin(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_admin(user_id uuid DEFAULT auth.uid()) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM user_companies uc
    JOIN profiles p ON uc.profile_id = p.id
    WHERE uc.user_id = user_id 
    AND p.nome = 'Super Admin'
    AND uc.ativo = true
  );
END;
$$;


ALTER FUNCTION public.is_admin(user_id uuid) OWNER TO postgres;

--
-- Name: is_admin_all_production(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_admin_all_production(p_user_id uuid DEFAULT auth.uid()) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  user_profile_id UUID;
  total_production_modules INTEGER;
  user_permissions_count INTEGER;
BEGIN
  -- Obter profile_id do usuÃ¡rio
  SELECT uc.profile_id INTO user_profile_id
  FROM user_companies uc
  WHERE uc.user_id = p_user_id
  AND uc.ativo = true
  LIMIT 1;
  
  -- Se nÃ£o encontrou perfil, retorna false
  IF user_profile_id IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Contar total de mÃ³dulos de produÃ§Ã£o
  SELECT COUNT(DISTINCT module_name) INTO total_production_modules
  FROM module_permissions
  WHERE module_name NOT LIKE 'teste_%';
  
  -- Contar quantos mÃ³dulos de produÃ§Ã£o o usuÃ¡rio tem com todas as permissÃµes
  SELECT COUNT(*) INTO user_permissions_count
  FROM module_permissions mp
  WHERE mp.profile_id = user_profile_id
  AND mp.module_name NOT LIKE 'teste_%'
  AND mp.can_read = true
  AND mp.can_create = true
  AND mp.can_edit = true
  AND mp.can_delete = true;
  
  -- Retorna true se tem todas as permissÃµes dos mÃ³dulos de produÃ§Ã£o
  RETURN user_permissions_count = total_production_modules;
END;
$$;


ALTER FUNCTION public.is_admin_all_production(p_user_id uuid) OWNER TO postgres;

--
-- Name: is_admin_simple(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_admin_simple(p_user_id uuid DEFAULT auth.uid()) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 
    FROM user_companies uc
    JOIN profiles p ON uc.profile_id = p.id
    WHERE uc.user_id = p_user_id 
    AND p.nome = 'Super Admin'
    AND uc.ativo = true
  );
END;
$$;


ALTER FUNCTION public.is_admin_simple(p_user_id uuid) OWNER TO postgres;

--
-- Name: is_month_open_for_signature(uuid, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.is_month_open_for_signature(p_company_id uuid, p_month_year character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    config_record rh.time_record_signature_config%ROWTYPE;
    month_end_date DATE;
    signature_deadline TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Buscar configuraÃ§Ã£o da empresa
    SELECT * INTO config_record
    FROM rh.time_record_signature_config
    WHERE company_id = p_company_id;
    
    -- Se nÃ£o hÃ¡ configuraÃ§Ã£o ou estÃ¡ desabilitada, retorna false
    IF NOT FOUND OR NOT config_record.is_enabled THEN
        RETURN false;
    END IF;
    
    -- Calcular data de fim do mÃªs
    month_end_date := (p_month_year || '-01')::DATE + INTERVAL '1 month' - INTERVAL '1 day';
    
    -- Calcular prazo para assinatura
    signature_deadline := month_end_date + INTERVAL '1 day' + (config_record.signature_period_days || ' days')::INTERVAL;
    
    -- Verificar se ainda estÃ¡ dentro do prazo
    RETURN NOW() <= signature_deadline;
END;
$$;


ALTER FUNCTION public.is_month_open_for_signature(p_company_id uuid, p_month_year character varying) OWNER TO postgres;

--
-- Name: list_periodic_exams(uuid, uuid, character varying, character varying, character varying, date, date, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.list_periodic_exams(p_company_id uuid, p_employee_id uuid DEFAULT NULL::uuid, p_tipo_exame character varying DEFAULT NULL::character varying, p_status character varying DEFAULT NULL::character varying, p_resultado character varying DEFAULT NULL::character varying, p_data_inicio date DEFAULT NULL::date, p_data_fim date DEFAULT NULL::date, p_limit integer DEFAULT 100, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, company_id uuid, employee_id uuid, employee_name character varying, tipo_exame character varying, data_agendamento date, data_realizacao date, data_vencimento date, status character varying, medico_responsavel character varying, clinica_local character varying, observacoes text, resultado character varying, restricoes text, anexos text[], custo numeric, pago boolean, data_pagamento date, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pe.id,
    pe.company_id,
    pe.employee_id,
    e.nome as employee_name,
    pe.tipo_exame,
    pe.data_agendamento,
    pe.data_realizacao,
    pe.data_vencimento,
    pe.status,
    pe.medico_responsavel,
    pe.clinica_local,
    pe.observacoes,
    pe.resultado,
    pe.restricoes,
    pe.anexos,
    pe.custo,
    pe.pago,
    pe.data_pagamento,
    pe.created_at,
    pe.updated_at
  FROM rh.periodic_exams pe
  JOIN rh.employees e ON pe.employee_id = e.id
  WHERE pe.company_id = p_company_id
    AND (p_employee_id IS NULL OR pe.employee_id = p_employee_id)
    AND (p_tipo_exame IS NULL OR pe.tipo_exame = p_tipo_exame)
    AND (p_status IS NULL OR pe.status = p_status)
    AND (p_resultado IS NULL OR pe.resultado = p_resultado)
    AND (p_data_inicio IS NULL OR pe.data_agendamento >= p_data_inicio)
    AND (p_data_fim IS NULL OR pe.data_agendamento <= p_data_fim)
  ORDER BY pe.data_agendamento DESC
  LIMIT p_limit OFFSET p_offset;
END;
$$;


ALTER FUNCTION public.list_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: process_approval(uuid, character varying, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    approval_record RECORD;
    all_approved BOOLEAN := false;
    entity_company_id UUID;
BEGIN
    -- Obter registro de aprovaÃ§Ã£o
    SELECT * INTO approval_record
    FROM public.aprovacoes_unificada
    WHERE id = p_aprovacao_id
    AND aprovador_id = p_aprovador_id
    AND status = 'pendente';
    
    -- Se nÃ£o encontrou, retorna false
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Atualizar status da aprovaÃ§Ã£o
    UPDATE public.aprovacoes_unificada
    SET status = p_status,
        data_aprovacao = CASE WHEN p_status = 'aprovado' THEN NOW() ELSE NULL END,
        observacoes = p_observacoes,
        updated_at = NOW()
    WHERE id = p_aprovacao_id;
    
    -- Se foi aprovado, verificar se todas as aprovaÃ§Ãµes foram concluÃ­das
    IF p_status = 'aprovado' THEN
        -- Verificar se todas as aprovaÃ§Ãµes foram aprovadas
        SELECT NOT EXISTS(
            SELECT 1 FROM public.aprovacoes_unificada
            WHERE processo_tipo = approval_record.processo_tipo
            AND processo_id = approval_record.processo_id
            AND company_id = approval_record.company_id
            AND status = 'pendente'
        ) INTO all_approved;
        
        -- Se todas foram aprovadas, atualizar status da entidade
        IF all_approved THEN
            -- Atualizar status da entidade baseado no tipo
            CASE approval_record.processo_tipo
                WHEN 'conta_pagar' THEN
                    UPDATE financeiro.contas_pagar
                    SET status = 'aprovado',
                        data_aprovacao = NOW(),
                        aprovado_por = p_aprovador_id,
                        updated_at = NOW()
                    WHERE id = approval_record.processo_id;
                    
                WHEN 'requisicao_compra' THEN
                    UPDATE compras.requisicoes_compra
                    SET status = 'aprovado',
                        data_aprovacao = NOW(),
                        aprovado_por = p_aprovador_id,
                        updated_at = NOW()
                    WHERE id = approval_record.processo_id;
                    
                WHEN 'cotacao_compra' THEN
                    UPDATE compras.cotacoes
                    SET status = 'aprovado',
                        data_aprovacao = NOW(),
                        aprovado_por = p_aprovador_id,
                        updated_at = NOW()
                    WHERE id = approval_record.processo_id;
                    
                WHEN 'solicitacao_saida_material' THEN
                    UPDATE public.solicitacoes_saida_materiais
                    SET status = 'aprovado',
                        data_aprovacao = NOW(),
                        updated_at = NOW()
                    WHERE id = approval_record.processo_id;
                    
                WHEN 'solicitacao_transferencia_material' THEN
                    UPDATE almoxarifado.transferencias
                    SET status = 'aprovado',
                        data_aprovacao = NOW(),
                        aprovador_id = p_aprovador_id,
                        updated_at = NOW()
                    WHERE id = approval_record.processo_id;
            END CASE;
        END IF;
    END IF;
    
    -- Se foi rejeitado ou cancelado, atualizar status da entidade
    IF p_status IN ('rejeitado', 'cancelado') THEN
        CASE approval_record.processo_tipo
            WHEN 'conta_pagar' THEN
                UPDATE financeiro.contas_pagar
                SET status = p_status,
                    updated_at = NOW()
                WHERE id = approval_record.processo_id;
                
            WHEN 'requisicao_compra' THEN
                UPDATE compras.requisicoes_compra
                SET status = p_status,
                    updated_at = NOW()
                WHERE id = approval_record.processo_id;
                
            WHEN 'cotacao_compra' THEN
                UPDATE compras.cotacoes
                SET status = p_status,
                    updated_at = NOW()
                WHERE id = approval_record.processo_id;
                
            WHEN 'solicitacao_saida_material' THEN
                UPDATE public.solicitacoes_saida_materiais
                SET status = p_status,
                    updated_at = NOW()
                WHERE id = approval_record.processo_id;
                
            WHEN 'solicitacao_transferencia_material' THEN
                UPDATE almoxarifado.transferencias
                SET status = p_status,
                    updated_at = NOW()
                WHERE id = approval_record.processo_id;
        END CASE;
    END IF;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid) OWNER TO postgres;

--
-- Name: process_expired_signatures(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.process_expired_signatures() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Marcar assinaturas expiradas
    UPDATE rh.time_record_signatures 
    SET status = 'expired'
    WHERE status = 'pending' 
    AND expires_at < NOW();
    
    -- Criar notificaÃ§Ãµes de expiraÃ§Ã£o
    INSERT INTO rh.signature_notifications (
        company_id,
        employee_id,
        signature_id,
        notification_type,
        sent_via
    )
    SELECT 
        company_id,
        employee_id,
        id,
        'expired',
        'system'
    FROM rh.time_record_signatures 
    WHERE status = 'expired' 
    AND id NOT IN (
        SELECT signature_id FROM rh.signature_notifications 
        WHERE notification_type = 'expired'
    );
END;
$$;


ALTER FUNCTION public.process_expired_signatures() OWNER TO postgres;

--
-- Name: record_edit_and_reset_approvals(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.record_edit_and_reset_approvals() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    processo_tipo VARCHAR(50);
    processo_id UUID;
    company_id UUID;
    campos_alterados TEXT[] := '{}';
    valores_anteriores JSONB := '{}';
    valores_novos JSONB := '{}';
    campo TEXT;
    valor_anterior TEXT;
    valor_novo TEXT;
BEGIN
    -- Determinar o tipo de processo baseado na tabela
    IF TG_TABLE_NAME = 'contas_pagar' THEN
        processo_tipo := 'conta_pagar';
        processo_id := COALESCE(NEW.id, OLD.id);
        company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSIF TG_TABLE_NAME = 'requisicoes_compra' THEN
        processo_tipo := 'requisicao_compra';
        processo_id := COALESCE(NEW.id, OLD.id);
        company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSIF TG_TABLE_NAME = 'cotacoes' THEN
        processo_tipo := 'cotacao_compra';
        processo_id := COALESCE(NEW.id, OLD.id);
        company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSIF TG_TABLE_NAME = 'solicitacoes_saida_materiais' THEN
        processo_tipo := 'solicitacao_saida_material';
        processo_id := COALESCE(NEW.id, OLD.id);
        company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSIF TG_TABLE_NAME = 'transferencias' THEN
        processo_tipo := 'solicitacao_transferencia_material';
        processo_id := COALESCE(NEW.id, OLD.id);
        company_id := COALESCE(NEW.company_id, OLD.company_id);
    ELSE
        RETURN COALESCE(NEW, OLD);
    END IF;

    -- Se for INSERT, nÃ£o hÃ¡ ediÃ§Ã£o para registrar
    IF TG_OP = 'INSERT' THEN
        RETURN NEW;
    END IF;

    -- Se for DELETE, nÃ£o resetar aprovaÃ§Ãµes
    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    END IF;

    -- Verificar se houve mudanÃ§as significativas
    -- Campos que nÃ£o devem triggerar reset
    DECLARE
        campos_ignorados TEXT[] := ARRAY['updated_at', 'created_at', 'aprovado_por', 'data_aprovacao', 'status'];
    BEGIN
        -- Comparar campos relevantes
        FOR campo IN 
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = TG_TABLE_NAME 
            AND table_schema = TG_TABLE_SCHEMA
            AND column_name != ALL(campos_ignorados)
        LOOP
            -- Obter valores
            EXECUTE format('SELECT ($1).%I::text', campo) INTO valor_anterior USING OLD;
            EXECUTE format('SELECT ($1).%I::text', campo) INTO valor_novo USING NEW;
            
            -- Se os valores sÃ£o diferentes
            IF valor_anterior IS DISTINCT FROM valor_novo THEN
                campos_alterados := array_append(campos_alterados, campo);
                valores_anteriores := valores_anteriores || jsonb_build_object(campo, valor_anterior);
                valores_novos := valores_novos || jsonb_build_object(campo, valor_novo);
            END IF;
        END LOOP;
    END;

    -- Se nÃ£o houve mudanÃ§as significativas, nÃ£o fazer nada
    IF array_length(campos_alterados, 1) IS NULL THEN
        RETURN NEW;
    END IF;

    -- Registrar a ediÃ§Ã£o no histÃ³rico
    INSERT INTO public.historico_edicoes_solicitacoes (
        company_id,
        processo_tipo,
        processo_id,
        usuario_editor_id,
        data_edicao,
        campos_alterados,
        valores_anteriores,
        valores_novos
    ) VALUES (
        company_id,
        processo_tipo,
        processo_id,
        COALESCE(NEW.updated_by, NEW.created_by, (SELECT current_setting('app.current_user_id', true)::uuid)),
        NOW(),
        campos_alterados,
        valores_anteriores,
        valores_novos
    );

    -- Resetar aprovaÃ§Ãµes se a solicitaÃ§Ã£o nÃ£o estiver cancelada
    IF COALESCE(NEW.status, '') != 'cancelado' THEN
        PERFORM public.reset_approvals_after_edit(processo_tipo, processo_id, company_id);
    END IF;

    RETURN NEW;
END;
$_$;


ALTER FUNCTION public.record_edit_and_reset_approvals() OWNER TO postgres;

--
-- Name: reject_attendance_correction(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Atualizar status da correÃ§Ã£o
    UPDATE rh.attendance_corrections
    SET 
        status = 'rejeitado',
        aprovado_por = p_rejected_by,
        aprovado_em = NOW(),
        observacoes = p_observacoes,
        updated_at = NOW()
    WHERE id = p_correction_id;
    
    -- Registrar no histÃ³rico
    INSERT INTO rh.correction_history (
        correction_id,
        action,
        new_values,
        changed_by,
        reason
    ) VALUES (
        p_correction_id,
        'rejected',
        jsonb_build_object(
            'rejeitado_por', p_rejected_by,
            'rejeitado_em', NOW(),
            'observacoes', p_observacoes
        ),
        p_rejected_by,
        'CorreÃ§Ã£o rejeitada: ' || p_observacoes
    );
    
    RETURN true;
END;
$$;


ALTER FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) IS 'Rejeita uma correÃ§Ã£o de ponto com justificativa';


--
-- Name: reject_compensation(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.compensation_requests 
    SET 
        status = 'rejeitado',
        aprovado_por = rejected_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = compensation_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) IS 'Rejeita uma solicitaÃ§Ã£o de compensaÃ§Ã£o';


--
-- Name: reject_equipment(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.equipment_rental_approvals 
    SET 
        status = 'rejeitado',
        aprovado_por = rejected_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = equipment_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) IS 'Rejeita uma solicitaÃ§Ã£o de equipamento';


--
-- Name: reject_medical_certificate(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.medical_certificates 
    SET 
        status = 'rejeitado',
        aprovado_por = rejected_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = certificate_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) IS 'Rejeita um atestado mÃ©dico';


--
-- Name: reject_reimbursement(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.reimbursement_requests 
    SET 
        status = 'rejeitado',
        aprovado_por = rejected_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = reimbursement_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) IS 'Rejeita uma solicitaÃ§Ã£o de reembolso';


--
-- Name: reject_vacation(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    UPDATE rh.vacations 
    SET 
        status = 'rejeitado',
        aprovado_por = rejected_by,
        data_aprovacao = NOW(),
        observacoes_aprovacao = observacoes,
        updated_at = NOW()
    WHERE id = vacation_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) OWNER TO postgres;

--
-- Name: FUNCTION reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) IS 'Rejeita uma solicitaÃ§Ã£o de fÃ©rias';


--
-- Name: reset_approvals_after_edit(character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Limpar aprovaÃ§Ãµes existentes
    DELETE FROM public.aprovacoes_unificada 
    WHERE processo_tipo = p_processo_tipo 
    AND processo_id = p_processo_id 
    AND company_id = p_company_id;
    
    -- Criar novas aprovaÃ§Ãµes
    PERFORM public.create_approvals_for_process(p_processo_tipo, p_processo_id, p_company_id);
    
    -- Marcar como resetado no histÃ³rico
    UPDATE public.historico_edicoes_solicitacoes
    SET aprovacoes_resetadas = true,
        data_reset = NOW()
    WHERE processo_tipo = p_processo_tipo 
    AND processo_id = p_processo_id 
    AND company_id = p_company_id
    AND aprovacoes_resetadas = false;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: run_bank_hours_calculation(uuid, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN rh.run_bank_hours_calculation(p_company_id, p_calculation_date);
END;
$$;


ALTER FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) OWNER TO postgres;

--
-- Name: FUNCTION run_bank_hours_calculation(p_company_id uuid, p_calculation_date date); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) IS 'Wrapper para rh.run_bank_hours_calculation - permite chamada via RPC do Supabase';


--
-- Name: set_company_context(uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.set_company_context(company_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  PERFORM set_config('app.current_company_id', company_id::text, true);
END;
$$;


ALTER FUNCTION public.set_company_context(company_id uuid) OWNER TO postgres;

--
-- Name: test_auth_context(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_auth_context() RETURNS TABLE(current_user_id uuid, is_admin_result boolean, module_permissions_count bigint, entity_permissions_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    auth.uid() as current_user_id,
    is_admin_simple(auth.uid()) as is_admin_result,
    (SELECT COUNT(*) FROM module_permissions) as module_permissions_count,
    (SELECT COUNT(*) FROM entity_permissions) as entity_permissions_count;
END;
$$;


ALTER FUNCTION public.test_auth_context() OWNER TO postgres;

--
-- Name: test_authenticated_access(uuid, text, text, text, jsonb, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text DEFAULT NULL::text, filters jsonb DEFAULT '{}'::jsonb, limit_param integer DEFAULT 100, offset_param integer DEFAULT 0, order_by text DEFAULT 'created_at'::text, order_direction text DEFAULT 'DESC'::text) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    query_text text;
    count_query text;
    where_clause text := '';
    order_clause text;
    total_rows bigint;
    filter_key text;
    filter_value text;
    user_companies uuid[];
    has_company_access boolean := false;
BEGIN
    -- Verificar se o usuÃ¡rio tem permissÃ£o para acessar esta entidade
    IF NOT public.check_access_permission(schema_name, table_name, 'read') THEN
        RAISE EXCEPTION 'Acesso negado para %:%.%', schema_name, table_name, 'read';
    END IF;
    
    -- Obter empresas do usuÃ¡rio
    SELECT ARRAY(
        SELECT uc.company_id 
        FROM public.user_companies uc 
        WHERE uc.user_id = test_user_id 
        AND uc.ativo = true
    ) INTO user_companies;
    
    -- Se for super admin, permitir acesso a todas as empresas
    IF public.is_admin(test_user_id) THEN
        has_company_access := true;
    ELSE
        -- Verificar se o usuÃ¡rio tem acesso Ã  empresa especÃ­fica
        IF company_id_param IS NOT NULL THEN
            has_company_access := (company_id_param::uuid = ANY(user_companies));
        ELSE
            -- Se nÃ£o especificou empresa, permitir se tiver acesso a pelo menos uma
            has_company_access := (array_length(user_companies, 1) > 0);
        END IF;
    END IF;
    
    -- Se nÃ£o tem acesso Ã  empresa, negar
    IF NOT has_company_access THEN
        RAISE EXCEPTION 'Acesso negado para empresa %', COALESCE(company_id_param, 'nÃ£o especificada');
    END IF;
    
    -- Construir clÃ¡usula WHERE
    where_clause := 'WHERE 1=1';
    
    -- Adicionar filtro de company_id se fornecido
    IF company_id_param IS NOT NULL THEN
        where_clause := where_clause || ' AND company_id = ''' || company_id_param || '''::uuid';
    ELSE
        -- Se nÃ£o especificou empresa, filtrar pelas empresas do usuÃ¡rio
        IF NOT public.is_admin(test_user_id) THEN
            where_clause := where_clause || ' AND company_id = ANY(ARRAY[' || 
                array_to_string(user_companies, ',') || ']::uuid[])';
        END IF;
    END IF;
    
    -- Adicionar filtros dinÃ¢micos do JSON
    IF filters IS NOT NULL AND jsonb_typeof(filters) = 'object' THEN
        FOR filter_key, filter_value IN SELECT * FROM jsonb_each_text(filters)
        LOOP
            -- Pular filtros vazios ou com valor "all"
            IF filter_value IS NOT NULL AND filter_value != '' AND filter_value != 'all' THEN
                -- Verificar se Ã© um campo UUID
                IF filter_key LIKE '%_id' THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''::uuid';
                -- Verificar se Ã© um campo de data
                ELSIF filter_key LIKE '%_date' OR filter_key LIKE 'data_%' THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''::date';
                -- Verificar se Ã© um campo booleano
                ELSIF filter_value IN ('true', 'false') THEN
                    where_clause := where_clause || ' AND ' || filter_key || ' = ' || filter_value;
                -- Campo de texto com busca
                ELSIF filter_key = 'search' THEN
                    where_clause := where_clause || ' AND (nome ILIKE ''%' || filter_value || '%'' OR matricula ILIKE ''%' || filter_value || '%'' OR cpf ILIKE ''%' || filter_value || '%'')';
                -- Outros campos de texto
                ELSE
                    where_clause := where_clause || ' AND ' || filter_key || ' = ''' || filter_value || '''';
                END IF;
            END IF;
        END LOOP;
    END IF;
    
    -- Construir clÃ¡usula ORDER BY
    order_clause := 'ORDER BY ' || order_by || ' ' || order_direction;
    
    -- Query para contar total de registros
    count_query := format('SELECT COUNT(*) FROM %I.%I %s', schema_name, table_name, where_clause);
    EXECUTE count_query INTO total_rows;
    
    -- Query principal para buscar dados
    query_text := format('
        SELECT 
            t.id::text,
            to_jsonb(t.*) as data,
            %s::bigint as total_count
        FROM %I.%I t 
        %s 
        %s
        LIMIT %s OFFSET %s
    ', total_rows, schema_name, table_name, where_clause, order_clause, limit_param, offset_param);
    
    RETURN QUERY EXECUTE query_text;
END;
$$;


ALTER FUNCTION public.test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) OWNER TO postgres;

--
-- Name: test_get_entity_data(text, text, text, jsonb, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_get_entity_data(schema_name text, table_name text, company_id_param text DEFAULT NULL::text, filters jsonb DEFAULT '{}'::jsonb, limit_param integer DEFAULT 100, offset_param integer DEFAULT 0, order_by text DEFAULT 'created_at'::text, order_direction text DEFAULT 'DESC'::text) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    query_text text;
    count_query text;
    where_clause text := '';
    order_clause text;
    total_rows bigint;
    filter_key text;
    filter_value text;
BEGIN
    -- Construir clÃ¡usula WHERE
    where_clause := 'WHERE 1=1';
    
    -- Adicionar filtro de company_id se fornecido
    IF company_id_param IS NOT NULL THEN
        where_clause := where_clause || ' AND company_id = ''' || company_id_param || '''::uuid';
    END IF;
    
    -- Adicionar filtros dinÃ¢micos do JSON
    IF filters IS NOT NULL AND jsonb_typeof(filters) = 'object' THEN
        
        -- Filtros especÃ­ficos conhecidos
        IF filters ? 'search' AND filters->>'search' != '' THEN
            where_clause := where_clause || ' AND (nome ILIKE ''%' || (filters->>'search') || '%'' OR matricula ILIKE ''%' || (filters->>'search') || '%'')';
        END IF;
        
        IF filters ? 'status' AND filters->>'status' != '' THEN
            where_clause := where_clause || ' AND status = ''' || (filters->>'status') || '''';
        END IF;
        
        IF filters ? 'start_date' AND filters->>'start_date' != '' THEN
            where_clause := where_clause || ' AND created_at >= ''' || (filters->>'start_date') || '''::date';
        END IF;
        
        IF filters ? 'end_date' AND filters->>'end_date' != '' THEN
            where_clause := where_clause || ' AND created_at <= ''' || (filters->>'end_date') || '''::date';
        END IF;
        
        IF filters ? 'is_active' THEN
            where_clause := where_clause || ' AND is_active = ' || (filters->>'is_active')::boolean;
        END IF;
        
        -- Filtros dinÃ¢micos para campos especÃ­ficos conhecidos
        IF filters ? 'employee_id' AND filters->>'employee_id' != '' THEN
            where_clause := where_clause || ' AND employee_id = ''' || (filters->>'employee_id') || '''::uuid';
        END IF;
        
        IF filters ? 'data_registro' AND filters->>'data_registro' != '' THEN
            where_clause := where_clause || ' AND data_registro = ''' || (filters->>'data_registro') || '''::date';
        END IF;
        
        IF filters ? 'id' AND filters->>'id' != '' THEN
            where_clause := where_clause || ' AND id = ''' || (filters->>'id') || '''::uuid';
        END IF;
    END IF;
    
    -- Construir clÃ¡usula ORDER BY
    order_clause := 'ORDER BY ' || order_by || ' ' || order_direction;
    
    -- Query para contar total de registros
    count_query := format('SELECT COUNT(*) FROM %I.%I %s', schema_name, table_name, where_clause);
    EXECUTE count_query INTO total_rows;
    
    -- Query principal para buscar dados
    query_text := format('
        SELECT 
            t.id::text,
            to_jsonb(t.*) as data,
            %s::bigint as total_count
        FROM %I.%I t 
        %s 
        %s
        LIMIT %s OFFSET %s
    ', total_rows, schema_name, table_name, where_clause, order_clause, limit_param, offset_param);
    
    RETURN QUERY EXECUTE query_text;
END;
$$;


ALTER FUNCTION public.test_get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) OWNER TO postgres;

--
-- Name: test_time_bank_access(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_time_bank_access(company_id_param text) RETURNS TABLE(id text, data jsonb, total_count bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    query_text text;
    count_query text;
    where_clause text := '';
    total_rows bigint;
BEGIN
    -- Construir clÃ¡usula WHERE
    where_clause := 'WHERE 1=1';
    
    -- Adicionar filtro de company_id se fornecido
    IF company_id_param IS NOT NULL THEN
        where_clause := where_clause || ' AND company_id = ''' || company_id_param || '''::uuid';
    END IF;
    
    -- Query para buscar dados
    query_text := 'SELECT id::text, to_jsonb(t.*) as data, COUNT(*) OVER() as total_count FROM rh.time_bank t ' || where_clause || ' ORDER BY created_at DESC LIMIT 100';
    
    -- Query para contar total
    count_query := 'SELECT COUNT(*) FROM rh.time_bank t ' || where_clause;
    
    -- Executar query de contagem
    EXECUTE count_query INTO total_rows;
    
    -- Retornar dados
    RETURN QUERY EXECUTE query_text;
END;
$$;


ALTER FUNCTION public.test_time_bank_access(company_id_param text) OWNER TO postgres;

--
-- Name: transfer_approval(uuid, uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    approval_record RECORD;
BEGIN
    -- Obter registro de aprovaÃ§Ã£o
    SELECT * INTO approval_record
    FROM public.aprovacoes_unificada
    WHERE id = p_aprovacao_id
    AND status = 'pendente';
    
    -- Se nÃ£o encontrou, retorna false
    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;
    
    -- Atualizar aprovador
    UPDATE public.aprovacoes_unificada
    SET aprovador_id = p_novo_aprovador_id,
        transferido_em = NOW(),
        transferido_por = p_transferido_por,
        motivo_transferencia = p_motivo,
        updated_at = NOW()
    WHERE id = p_aprovacao_id;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION public.transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid) OWNER TO postgres;

--
-- Name: trigger_create_compensation_approvals(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.trigger_create_compensation_approvals() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Criar aprovaÃ§Ãµes apenas para novas solicitaÃ§Ãµes
    IF TG_OP = 'INSERT' AND NEW.status = 'pendente' THEN
        PERFORM create_compensation_approvals(NEW.id, NEW.company_id);
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.trigger_create_compensation_approvals() OWNER TO postgres;

--
-- Name: update_absence_types_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_absence_types_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_absence_types_updated_at() OWNER TO postgres;

--
-- Name: update_allowance_types_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_allowance_types_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_allowance_types_updated_at() OWNER TO postgres;

--
-- Name: update_approval_levels_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_approval_levels_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_approval_levels_updated_at() OWNER TO postgres;

--
-- Name: update_audit_config_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_audit_config_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_audit_config_updated_at() OWNER TO postgres;

--
-- Name: update_calculation_log(uuid, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  affected_rows INTEGER;
BEGIN
  UPDATE rh.calculation_logs 
  SET 
    status = COALESCE((updates->>'status')::text, status),
    progresso = COALESCE((updates->>'progresso')::integer, progresso),
    total_funcionarios = COALESCE((updates->>'total_funcionarios')::integer, total_funcionarios),
    funcionarios_processados = COALESCE((updates->>'funcionarios_processados')::integer, funcionarios_processados),
    eventos_calculados = COALESCE((updates->>'eventos_calculados')::integer, eventos_calculados),
    erros_encontrados = COALESCE((updates->>'erros_encontrados')::integer, erros_encontrados),
    fim_processamento = CASE WHEN updates->>'fim_processamento' IS NOT NULL THEN (updates->>'fim_processamento')::timestamptz ELSE fim_processamento END,
    tempo_execucao_segundos = COALESCE((updates->>'tempo_execucao_segundos')::integer, tempo_execucao_segundos),
    logs_execucao = COALESCE(updates->'logs_execucao', logs_execucao),
    erros_execucao = COALESCE(updates->'erros_execucao', erros_execucao),
    resumo_calculos = COALESCE(updates->'resumo_calculos', resumo_calculos),
    updated_at = now()
  WHERE id = log_id_param AND company_id = company_id_param;
  
  GET DIAGNOSTICS affected_rows = ROW_COUNT;
  
  RETURN affected_rows > 0;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao atualizar log de cÃ¡lculo: %', SQLERRM;
END;
$$;


ALTER FUNCTION public.update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb) OWNER TO postgres;

--
-- Name: update_cid_codes_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_cid_codes_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_cid_codes_updated_at() OWNER TO postgres;

--
-- Name: update_companies_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_companies_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_companies_updated_at() OWNER TO postgres;

--
-- Name: update_compensation_approvals_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_compensation_approvals_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_compensation_approvals_updated_at() OWNER TO postgres;

--
-- Name: update_compensation_requests_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_compensation_requests_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_compensation_requests_updated_at() OWNER TO postgres;

--
-- Name: update_deficiency_types_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_deficiency_types_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_deficiency_types_updated_at() OWNER TO postgres;

--
-- Name: update_delay_reasons_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_delay_reasons_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_delay_reasons_updated_at() OWNER TO postgres;

--
-- Name: update_disciplinary_actions_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_disciplinary_actions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_disciplinary_actions_updated_at() OWNER TO postgres;

--
-- Name: update_employee_shifts_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_employee_shifts_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_employee_shifts_updated_at() OWNER TO postgres;

--
-- Name: update_employment_contracts_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_employment_contracts_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_employment_contracts_updated_at() OWNER TO postgres;

--
-- Name: update_entity_data(text, text, uuid, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
  result JSONB;
  sql_query TEXT;
  set_clauses TEXT;
  param_values TEXT[];
  i INTEGER;
  key_value RECORD;
  value_text TEXT;
  param_count INTEGER;
  uuid_columns TEXT[] := ARRAY['employee_id', 'liberado_por', 'user_id', 'profile_id', 'correction_id', 'changed_by'];
  boolean_columns TEXT[] := ARRAY['liberado', 'ativo', 'is_active', 'pago', 'permitir_correcao_futura', 'exigir_justificativa', 'permitir_correcao_apos_aprovacao'];
  timestamp_columns TEXT[] := ARRAY['created_at', 'updated_at', 'liberado_em', 'data_agendamento', 'data_vencimento', 'data_realizacao', 'data_pagamento'];
BEGIN
  -- Log para debug
  RAISE NOTICE 'Updating entity: schema=%, table=%, company_id=%, id=%, data=%', 
    schema_name, table_name, company_id_param, id_param, data_param;
  
  -- Construir clÃ¡usulas SET e array de valores
  set_clauses := '';
  param_values := ARRAY[id_param::TEXT, company_id_param::TEXT];
  i := 3;
  
  -- Iterar sobre os pares chave-valor do JSONB
  FOR key_value IN 
    SELECT key, value 
    FROM jsonb_each(data_param) 
    ORDER BY key
  LOOP
    -- Pular company_id se estiver nos dados (nÃ£o deve ser atualizado)
    IF key_value.key = 'company_id' THEN
      CONTINUE;
    END IF;
    
    -- Adicionar clÃ¡usula SET com cast apropriado baseado no tipo da coluna
    IF key_value.key = ANY(uuid_columns) THEN
      IF set_clauses = '' THEN
        set_clauses := quote_ident(key_value.key) || ' = $' || i || '::uuid';
      ELSE
        set_clauses := set_clauses || ', ' || quote_ident(key_value.key) || ' = $' || i || '::uuid';
      END IF;
    ELSIF key_value.key = ANY(boolean_columns) THEN
      IF set_clauses = '' THEN
        set_clauses := quote_ident(key_value.key) || ' = $' || i || '::boolean';
      ELSE
        set_clauses := set_clauses || ', ' || quote_ident(key_value.key) || ' = $' || i || '::boolean';
      END IF;
    ELSIF key_value.key = ANY(timestamp_columns) THEN
      IF set_clauses = '' THEN
        set_clauses := quote_ident(key_value.key) || ' = $' || i || '::timestamp with time zone';
      ELSE
        set_clauses := set_clauses || ', ' || quote_ident(key_value.key) || ' = $' || i || '::timestamp with time zone';
      END IF;
    ELSE
      IF set_clauses = '' THEN
        set_clauses := quote_ident(key_value.key) || ' = $' || i;
      ELSE
        set_clauses := set_clauses || ', ' || quote_ident(key_value.key) || ' = $' || i;
      END IF;
    END IF;
    
    -- Converter valor para texto apropriado
    IF key_value.value IS NULL THEN
      value_text := 'NULL';
    ELSIF jsonb_typeof(key_value.value) = 'string' THEN
      value_text := key_value.value #>> '{}';
    ELSIF jsonb_typeof(key_value.value) = 'boolean' THEN
      value_text := (key_value.value #>> '{}');
    ELSIF jsonb_typeof(key_value.value) = 'number' THEN
      value_text := (key_value.value #>> '{}');
    ELSE
      value_text := key_value.value #>> '{}';
    END IF;
    
    -- Adicionar valor ao array
    param_values := param_values || value_text;
    i := i + 1;
  END LOOP;
  
  -- Construir query SQL
  sql_query := format('UPDATE %I.%I SET %s, updated_at = now() WHERE id = $1::uuid AND company_id = $2::uuid RETURNING row_to_json(%I.%I.*)',
    schema_name,
    table_name,
    set_clauses,
    schema_name,
    table_name
  );
  
  -- Log da query construÃ­da
  RAISE NOTICE 'SQL Query: %', sql_query;
  RAISE NOTICE 'Parameters: %', param_values;
  
  -- Executar query usando EXECUTE com USING
  param_count := array_length(param_values, 1);
  
  IF param_count = 2 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid;
  ELSIF param_count = 3 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3];
  ELSIF param_count = 4 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3], param_values[4];
  ELSIF param_count = 5 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3], param_values[4], param_values[5];
  ELSIF param_count = 6 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3], param_values[4], param_values[5], param_values[6];
  ELSIF param_count = 7 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3], param_values[4], param_values[5], param_values[6], param_values[7];
  ELSIF param_count = 8 THEN
    EXECUTE sql_query INTO result USING param_values[1]::uuid, param_values[2]::uuid, param_values[3], param_values[4], param_values[5], param_values[6], param_values[7], param_values[8];
  ELSE
    RAISE EXCEPTION 'Muitos parÃ¢metros: %', param_count;
  END IF;
  
  RETURN result;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao atualizar dados: %', SQLERRM;
END;
$_$;


ALTER FUNCTION public.update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb) OWNER TO postgres;

--
-- Name: update_entity_permission(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, entity_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
  updated_permission RECORD;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT ep.id INTO permission_id
  FROM entity_permissions ep
  WHERE ep.profile_id = p_profile_id AND ep.entity_name = p_entity_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE entity_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO entity_permissions (
      profile_id,
      entity_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_entity_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING entity_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    ep.id,
    ep.profile_id,
    ep.entity_name,
    ep.can_read,
    ep.can_create,
    ep.can_edit,
    ep.can_delete,
    ep.created_at,
    ep.updated_at
  FROM entity_permissions ep
  WHERE ep.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_entity_permission_no_auth(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, entity_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Buscar permissÃ£o existente
  SELECT ep.id INTO permission_id
  FROM entity_permissions ep
  WHERE ep.profile_id = p_profile_id AND ep.entity_name = p_entity_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE entity_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE entity_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO entity_permissions (
      profile_id,
      entity_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_entity_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING entity_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    ep.id,
    ep.profile_id,
    ep.entity_name,
    ep.can_read,
    ep.can_create,
    ep.can_edit,
    ep.can_delete,
    ep.created_at,
    ep.updated_at
  FROM entity_permissions ep
  WHERE ep.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_entity_permission_production(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, entity_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  -- Usa verificaÃ§Ã£o baseada em permissÃµes de produÃ§Ã£o
  IF auth.uid() IS NOT NULL AND NOT is_admin_all_production(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas usuÃ¡rios com permissÃµes administrativas podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT ep.id INTO permission_id
  FROM entity_permissions ep
  WHERE ep.profile_id = p_profile_id AND ep.entity_name = p_entity_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE entity_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE entity_permissions.can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE entity_permissions.can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE entity_permissions.can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE entity_permissions.can_delete END,
      updated_at = NOW()
    WHERE entity_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO entity_permissions (
      profile_id,
      entity_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_entity_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING entity_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    ep.id,
    ep.profile_id,
    ep.entity_name,
    ep.can_read,
    ep.can_create,
    ep.can_edit,
    ep.can_delete,
    ep.created_at,
    ep.updated_at
  FROM entity_permissions ep
  WHERE ep.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_entity_permission_with_check(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, entity_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  -- Usa verificaÃ§Ã£o baseada em permissÃµes em vez de nome do perfil
  IF auth.uid() IS NOT NULL AND NOT is_admin_by_permissions_flexible(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas usuÃ¡rios com permissÃµes administrativas podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT ep.id INTO permission_id
  FROM entity_permissions ep
  WHERE ep.profile_id = p_profile_id AND ep.entity_name = p_entity_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE entity_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE entity_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO entity_permissions (
      profile_id,
      entity_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_entity_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING entity_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    ep.id,
    ep.profile_id,
    ep.entity_name,
    ep.can_read,
    ep.can_create,
    ep.can_edit,
    ep.can_delete,
    ep.created_at,
    ep.updated_at
  FROM entity_permissions ep
  WHERE ep.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_esocial_integrations_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_esocial_integrations_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_esocial_integrations_updated_at() OWNER TO postgres;

--
-- Name: update_event_consolidations_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_event_consolidations_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_event_consolidations_updated_at() OWNER TO postgres;

--
-- Name: update_fgts_config_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_fgts_config_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_fgts_config_updated_at() OWNER TO postgres;

--
-- Name: update_income_statements_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_income_statements_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_income_statements_updated_at() OWNER TO postgres;

--
-- Name: update_inss_brackets_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_inss_brackets_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_inss_brackets_updated_at() OWNER TO postgres;

--
-- Name: update_irrf_brackets_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_irrf_brackets_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_irrf_brackets_updated_at() OWNER TO postgres;

--
-- Name: update_module_permission(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
  updated_permission RECORD;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT mp.id INTO permission_id
  FROM module_permissions mp
  WHERE mp.profile_id = p_profile_id AND mp.module_name = p_module_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE module_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO module_permissions (
      profile_id,
      module_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_module_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING module_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    mp.id,
    mp.profile_id,
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete,
    mp.created_at,
    mp.updated_at
  FROM module_permissions mp
  WHERE mp.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_module_permission_no_auth(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Buscar permissÃ£o existente
  SELECT mp.id INTO permission_id
  FROM module_permissions mp
  WHERE mp.profile_id = p_profile_id AND mp.module_name = p_module_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE module_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE module_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO module_permissions (
      profile_id,
      module_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_module_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING module_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    mp.id,
    mp.profile_id,
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete,
    mp.created_at,
    mp.updated_at
  FROM module_permissions mp
  WHERE mp.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_module_permission_production(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  -- Usa verificaÃ§Ã£o baseada em permissÃµes de produÃ§Ã£o
  IF auth.uid() IS NOT NULL AND NOT is_admin_all_production(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas usuÃ¡rios com permissÃµes administrativas podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT mp.id INTO permission_id
  FROM module_permissions mp
  WHERE mp.profile_id = p_profile_id AND mp.module_name = p_module_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE module_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE module_permissions.can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE module_permissions.can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE module_permissions.can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE module_permissions.can_delete END,
      updated_at = NOW()
    WHERE module_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO module_permissions (
      profile_id,
      module_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_module_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING module_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    mp.id,
    mp.profile_id,
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete,
    mp.created_at,
    mp.updated_at
  FROM module_permissions mp
  WHERE mp.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_module_permission_with_check(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) RETURNS TABLE(id uuid, profile_id uuid, module_name text, can_read boolean, can_create boolean, can_edit boolean, can_delete boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  permission_id UUID;
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para gerenciar permissÃµes
  -- Usa verificaÃ§Ã£o baseada em permissÃµes em vez de nome do perfil
  IF auth.uid() IS NOT NULL AND NOT is_admin_by_permissions_flexible(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas usuÃ¡rios com permissÃµes administrativas podem gerenciar permissÃµes';
  END IF;
  
  -- Buscar permissÃ£o existente
  SELECT mp.id INTO permission_id
  FROM module_permissions mp
  WHERE mp.profile_id = p_profile_id AND mp.module_name = p_module_name;
  
  IF permission_id IS NOT NULL THEN
    -- Atualizar permissÃ£o existente
    UPDATE module_permissions
    SET 
      can_read = CASE WHEN p_action = 'can_read' THEN p_value ELSE can_read END,
      can_create = CASE WHEN p_action = 'can_create' THEN p_value ELSE can_create END,
      can_edit = CASE WHEN p_action = 'can_edit' THEN p_value ELSE can_edit END,
      can_delete = CASE WHEN p_action = 'can_delete' THEN p_value ELSE can_delete END,
      updated_at = NOW()
    WHERE module_permissions.id = permission_id;
  ELSE
    -- Criar nova permissÃ£o
    INSERT INTO module_permissions (
      profile_id,
      module_name,
      can_read,
      can_create,
      can_edit,
      can_delete,
      created_at,
      updated_at
    ) VALUES (
      p_profile_id,
      p_module_name,
      CASE WHEN p_action = 'can_read' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_create' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_edit' THEN p_value ELSE FALSE END,
      CASE WHEN p_action = 'can_delete' THEN p_value ELSE FALSE END,
      NOW(),
      NOW()
    )
    RETURNING module_permissions.id INTO permission_id;
  END IF;
  
  -- Retornar permissÃ£o atualizada
  RETURN QUERY
  SELECT 
    mp.id,
    mp.profile_id,
    mp.module_name,
    mp.can_read,
    mp.can_create,
    mp.can_edit,
    mp.can_delete,
    mp.created_at,
    mp.updated_at
  FROM module_permissions mp
  WHERE mp.id = permission_id;
END;
$$;


ALTER FUNCTION public.update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) OWNER TO postgres;

--
-- Name: update_notifications_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_notifications_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_notifications_updated_at() OWNER TO postgres;

--
-- Name: update_periodic_exam(uuid, uuid, uuid, character varying, date, date, date, character varying, character varying, character varying, text, character varying, text, text[], numeric, boolean, date); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid DEFAULT NULL::uuid, p_tipo_exame character varying DEFAULT NULL::character varying, p_data_agendamento date DEFAULT NULL::date, p_data_realizacao date DEFAULT NULL::date, p_data_vencimento date DEFAULT NULL::date, p_status character varying DEFAULT NULL::character varying, p_medico_responsavel character varying DEFAULT NULL::character varying, p_clinica_local character varying DEFAULT NULL::character varying, p_observacoes text DEFAULT NULL::text, p_resultado character varying DEFAULT NULL::character varying, p_restricoes text DEFAULT NULL::text, p_anexos text[] DEFAULT NULL::text[], p_custo numeric DEFAULT NULL::numeric, p_pago boolean DEFAULT NULL::boolean, p_data_pagamento date DEFAULT NULL::date) RETURNS TABLE(id uuid, company_id uuid, employee_id uuid, tipo_exame character varying, data_agendamento date, data_realizacao date, data_vencimento date, status character varying, medico_responsavel character varying, clinica_local character varying, observacoes text, resultado character varying, restricoes text, anexos text[], custo numeric, pago boolean, data_pagamento date, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  exam_record RECORD;
BEGIN
  -- Verificar se o exame existe e pertence Ã  empresa
  IF NOT EXISTS (
    SELECT 1 FROM rh.periodic_exams 
    WHERE rh.periodic_exams.id = p_exam_id AND rh.periodic_exams.company_id = p_company_id
  ) THEN
    RAISE EXCEPTION 'Exame nÃ£o encontrado ou nÃ£o pertence Ã  empresa';
  END IF;

  -- Atualizar apenas os campos fornecidos
  UPDATE rh.periodic_exams SET
    employee_id = COALESCE(p_employee_id, employee_id),
    tipo_exame = COALESCE(p_tipo_exame, tipo_exame),
    data_agendamento = COALESCE(p_data_agendamento, data_agendamento),
    data_realizacao = COALESCE(p_data_realizacao, data_realizacao),
    data_vencimento = COALESCE(p_data_vencimento, data_vencimento),
    status = COALESCE(p_status, status),
    medico_responsavel = COALESCE(p_medico_responsavel, medico_responsavel),
    clinica_local = COALESCE(p_clinica_local, clinica_local),
    observacoes = COALESCE(p_observacoes, observacoes),
    resultado = COALESCE(p_resultado, resultado),
    restricoes = COALESCE(p_restricoes, restricoes),
    anexos = COALESCE(p_anexos, anexos),
    custo = COALESCE(p_custo, custo),
    pago = COALESCE(p_pago, pago),
    data_pagamento = COALESCE(p_data_pagamento, data_pagamento),
    updated_at = NOW()
  WHERE rh.periodic_exams.id = p_exam_id
  RETURNING * INTO exam_record;

  -- Retornar o exame atualizado
  RETURN QUERY SELECT * FROM rh.periodic_exams WHERE rh.periodic_exams.id = p_exam_id;
END;
$$;


ALTER FUNCTION public.update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_realizacao date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) OWNER TO postgres;

--
-- Name: update_profile(uuid, text, text, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_profile(p_id uuid, p_nome text, p_descricao text DEFAULT NULL::text, p_is_active boolean DEFAULT true) RETURNS TABLE(id uuid, nome text, descricao text, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Verificar se o usuÃ¡rio tem permissÃ£o para atualizar perfis
  IF auth.uid() IS NOT NULL AND NOT is_admin_simple(auth.uid()) THEN
    RAISE EXCEPTION 'Acesso negado: apenas administradores podem atualizar perfis';
  END IF;
  
  -- Verificar se o nome jÃ¡ existe (exceto para o prÃ³prio perfil)
  IF EXISTS (SELECT 1 FROM profiles WHERE profiles.nome = p_nome AND profiles.id != p_id) THEN
    RAISE EXCEPTION 'JÃ¡ existe um perfil com este nome: %', p_nome;
  END IF;
  
  -- Atualizar perfil
  UPDATE profiles
  SET 
    nome = p_nome,
    descricao = p_descricao,
    is_active = p_is_active,
    updated_at = NOW()
  WHERE profiles.id = p_id;
  
  -- Retornar perfil atualizado
  RETURN QUERY
  SELECT 
    p.id,
    p.nome,
    p.descricao,
    p.is_active,
    p.created_at,
    p.updated_at
  FROM profiles p
  WHERE p.id = p_id;
END;
$$;


ALTER FUNCTION public.update_profile(p_id uuid, p_nome text, p_descricao text, p_is_active boolean) OWNER TO postgres;

--
-- Name: update_reports_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_reports_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_reports_updated_at() OWNER TO postgres;

--
-- Name: update_rubricas_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_rubricas_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_rubricas_updated_at() OWNER TO postgres;

--
-- Name: update_schedule_planning_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_schedule_planning_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_schedule_planning_updated_at() OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: time_record_signature_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.time_record_signature_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    is_enabled boolean DEFAULT false NOT NULL,
    signature_period_days integer DEFAULT 5 NOT NULL,
    reminder_days integer DEFAULT 3 NOT NULL,
    require_manager_approval boolean DEFAULT true NOT NULL,
    auto_close_month boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.time_record_signature_config OWNER TO postgres;

--
-- Name: TABLE time_record_signature_config; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.time_record_signature_config IS 'ConfiguraÃ§Ãµes de assinatura de registros de ponto por empresa';


--
-- Name: COLUMN time_record_signature_config.signature_period_days; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signature_config.signature_period_days IS 'NÃºmero de dias para assinar apÃ³s fechamento do mÃªs';


--
-- Name: COLUMN time_record_signature_config.reminder_days; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signature_config.reminder_days IS 'Dias antes do vencimento para enviar lembrete';


--
-- Name: COLUMN time_record_signature_config.require_manager_approval; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signature_config.require_manager_approval IS 'Se requer aprovaÃ§Ã£o do gestor apÃ³s assinatura';


--
-- Name: COLUMN time_record_signature_config.auto_close_month; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signature_config.auto_close_month IS 'Se fecha o mÃªs automaticamente no Ãºltimo dia';


--
-- Name: update_time_record_signature_config(uuid, uuid, boolean, integer, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean) RETURNS rh.time_record_signature_config
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    result rh.time_record_signature_config;
BEGIN
    UPDATE rh.time_record_signature_config
    SET 
        is_enabled = p_is_enabled,
        signature_period_days = p_signature_period_days,
        reminder_days = p_reminder_days,
        require_manager_approval = p_require_manager_approval,
        auto_close_month = p_auto_close_month,
        updated_at = NOW()
    WHERE id = p_id AND company_id = p_company_id
    RETURNING * INTO result;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'ConfiguraÃ§Ã£o nÃ£o encontrada ou sem permissÃ£o';
    END IF;
    
    RETURN result;
END;
$$;


ALTER FUNCTION public.update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean) OWNER TO postgres;

--
-- Name: update_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    SET search_path TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_updated_at() OWNER TO postgres;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_updated_at_column() OWNER TO postgres;

--
-- Name: update_work_shifts_updated_at(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_work_shifts_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_work_shifts_updated_at() OWNER TO postgres;

--
-- Name: user_has_company_access(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.user_has_company_access(user_id uuid, company_id uuid) RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO ''
    AS $_$
  SELECT EXISTS (
    SELECT 1 FROM public.user_companies
    WHERE user_id = $1 
    AND company_id = $2
    AND ativo = true
  );
$_$;


ALTER FUNCTION public.user_has_company_access(user_id uuid, company_id uuid) OWNER TO postgres;

--
-- Name: user_has_company_access_new(uuid, uuid); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.user_has_company_access_new(p_user_id uuid, p_company_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Super admin tem acesso a todas as empresas
  IF is_admin(p_user_id) THEN
    RETURN TRUE;
  END IF;
  
  -- Verificar se o usuÃ¡rio tem acesso Ã  empresa
  RETURN EXISTS (
    SELECT 1
    FROM user_companies uc
    WHERE uc.user_id = p_user_id
    AND uc.company_id = p_company_id
    AND uc.ativo = true
  );
END;
$$;


ALTER FUNCTION public.user_has_company_access_new(p_user_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: validar_solicitacao_ferias(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    dias_disponiveis INTEGER;
    resultado JSON;
BEGIN
    -- Buscar dias disponÃ­veis
    SELECT ve.dias_restantes
    INTO dias_disponiveis
    FROM rh.vacation_entitlements ve
    WHERE ve.employee_id = employee_id_param
      AND ve.ano_aquisitivo = ano_param
      AND ve.status IN ('ativo', 'parcialmente_gozado');
    
    -- Validar solicitaÃ§Ã£o
    IF dias_disponiveis IS NULL THEN
        resultado := json_build_object(
            'valido', false,
            'erro', 'PerÃ­odo aquisitivo nÃ£o encontrado',
            'dias_disponiveis', 0,
            'dias_solicitados', dias_solicitados
        );
    ELSIF dias_solicitados > dias_disponiveis THEN
        resultado := json_build_object(
            'valido', false,
            'erro', 'Dias solicitados excedem os dias disponÃ­veis',
            'dias_disponiveis', dias_disponiveis,
            'dias_solicitados', dias_solicitados
        );
    ELSE
        resultado := json_build_object(
            'valido', true,
            'erro', null,
            'dias_disponiveis', dias_disponiveis,
            'dias_solicitados', dias_solicitados
        );
    END IF;
    
    RETURN resultado;
END;
$$;


ALTER FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) OWNER TO postgres;

--
-- Name: FUNCTION validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer); Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) IS 'Valida uma solicitaÃ§Ã£o de fÃ©rias';


--
-- Name: apply_rls(jsonb, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)) RETURNS SETOF realtime.wal_rls
    LANGUAGE plpgsql
    AS $$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_;

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$$;


ALTER FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: broadcast_changes(text, text, text, text, text, record, record, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$$;


ALTER FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) OWNER TO supabase_admin;

--
-- Name: build_prepared_statement_sql(text, regclass, realtime.wal_column[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) RETURNS text
    LANGUAGE sql
    AS $$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $$;


ALTER FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) OWNER TO supabase_admin;

--
-- Name: cast(text, regtype); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime."cast"(val text, type_ regtype) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $$;


ALTER FUNCTION realtime."cast"(val text, type_ regtype) OWNER TO supabase_admin;

--
-- Name: check_equality_op(realtime.equality_op, regtype, text, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $$;


ALTER FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) OWNER TO supabase_admin;

--
-- Name: is_visible_through_filters(realtime.wal_column[], realtime.user_defined_filter[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $_$;


ALTER FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) OWNER TO supabase_admin;

--
-- Name: list_changes(name, name, integer, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) RETURNS SETOF realtime.wal_rls
    LANGUAGE sql
    SET log_min_messages TO 'fatal'
    AS $$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $$;


ALTER FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: quote_wal2json(regclass); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.quote_wal2json(entity regclass) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $$;


ALTER FUNCTION realtime.quote_wal2json(entity regclass) OWNER TO supabase_admin;

--
-- Name: send(jsonb, text, text, boolean); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  BEGIN
    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (payload, event, topic, private, extension)
    VALUES (payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) OWNER TO supabase_admin;

--
-- Name: subscription_check_filters(); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.subscription_check_filters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $$;


ALTER FUNCTION realtime.subscription_check_filters() OWNER TO supabase_admin;

--
-- Name: to_regrole(text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.to_regrole(role_name text) RETURNS regrole
    LANGUAGE sql IMMUTABLE
    AS $$ select role_name::regrole $$;


ALTER FUNCTION realtime.to_regrole(role_name text) OWNER TO supabase_admin;

--
-- Name: topic(); Type: FUNCTION; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE FUNCTION realtime.topic() RETURNS text
    LANGUAGE sql STABLE
    AS $$
select nullif(current_setting('realtime.topic', true), '')::text;
$$;


ALTER FUNCTION realtime.topic() OWNER TO supabase_realtime_admin;

--
-- Name: adjust_bank_hours_balance(uuid, uuid, numeric, text, uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_transaction_id UUID;
  v_new_balance DECIMAL(6,2);
BEGIN
  -- Verificar se o colaborador tem banco de horas configurado
  IF NOT EXISTS (
    SELECT 1 FROM rh.bank_hours_config 
    WHERE employee_id = p_employee_id 
      AND company_id = p_company_id 
      AND is_active = true
  ) THEN
    RAISE EXCEPTION 'Colaborador nÃ£o possui banco de horas configurado';
  END IF;

  -- Registrar transaÃ§Ã£o
  INSERT INTO rh.bank_hours_transactions (
    employee_id, company_id, transaction_type, transaction_date,
    hours_amount, description, created_by, is_automatic
  ) VALUES (
    p_employee_id, p_company_id, 'adjustment', CURRENT_DATE,
    p_hours_amount, p_description, p_created_by, false
  ) RETURNING id INTO v_transaction_id;

  -- Atualizar saldo
  UPDATE rh.bank_hours_balance SET
    current_balance = current_balance + p_hours_amount,
    updated_at = NOW()
  WHERE employee_id = p_employee_id AND company_id = p_company_id
  RETURNING current_balance INTO v_new_balance;

  -- Se nÃ£o existe saldo, criar
  IF NOT FOUND THEN
    INSERT INTO rh.bank_hours_balance (employee_id, company_id, current_balance)
    VALUES (p_employee_id, p_company_id, p_hours_amount)
    RETURNING current_balance INTO v_new_balance;
  END IF;

  RETURN v_transaction_id;
END;
$$;


ALTER FUNCTION rh.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid) OWNER TO postgres;

--
-- Name: buscar_anos_ferias_disponiveis(uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.buscar_anos_ferias_disponiveis(employee_id_param uuid) RETURNS TABLE(ano integer, dias_disponiveis integer, dias_gozados integer, dias_restantes integer, status character varying, data_vencimento date)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN RETURN QUERY SELECT ve.ano_aquisitivo as ano, ve.dias_disponiveis, ve.dias_gozados, ve.dias_restantes, ve.status, ve.data_vencimento FROM rh.vacation_entitlements ve WHERE ve.employee_id = employee_id_param AND ve.status IN ('ativo', 'parcialmente_gozado') ORDER BY ve.ano_aquisitivo DESC; END;$$;


ALTER FUNCTION rh.buscar_anos_ferias_disponiveis(employee_id_param uuid) OWNER TO postgres;

--
-- Name: buscar_ferias_pendentes(uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.buscar_ferias_pendentes(p_company_id uuid) RETURNS TABLE(id uuid, employee_id uuid, employee_nome character varying, data_inicio date, data_fim date, dias_solicitados integer, tipo character varying, observacoes text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$BEGIN RETURN QUERY SELECT v.id, v.employee_id, e.nome as employee_nome, v.data_inicio, v.data_fim, v.dias_solicitados, v.tipo, v.observacoes, v.created_at FROM rh.vacations v JOIN rh.employees e ON e.id = v.employee_id WHERE v.company_id = p_company_id AND v.status = 'pendente' ORDER BY v.created_at DESC; END;$$;


ALTER FUNCTION rh.buscar_ferias_pendentes(p_company_id uuid) OWNER TO postgres;

--
-- Name: calcular_dias_ferias_disponiveis(uuid, integer); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$DECLARE dias_disponiveis INTEGER; BEGIN SELECT dias_restantes INTO dias_disponiveis FROM rh.vacation_entitlements WHERE employee_id = p_employee_id AND ano_aquisitivo = p_ano AND status IN ('ativo', 'parcialmente_gozado'); RETURN COALESCE(dias_disponiveis, 0); END;$$;


ALTER FUNCTION rh.calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer) OWNER TO postgres;

--
-- Name: calculate_and_accumulate_bank_hours(uuid, uuid, date, date); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date) RETURNS TABLE(hours_accumulated numeric, hours_compensated numeric, new_balance numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_config rh.bank_hours_config%ROWTYPE;
  v_balance rh.bank_hours_balance%ROWTYPE;
  v_total_extra_hours DECIMAL(5,2) := 0;
  v_hours_to_accumulate DECIMAL(5,2) := 0;
  v_hours_to_compensate DECIMAL(5,2) := 0;
  v_new_balance DECIMAL(6,2) := 0;
  v_transaction_id UUID;
BEGIN
  -- Buscar configuraÃ§Ã£o
  SELECT * INTO v_config 
  FROM rh.bank_hours_config 
  WHERE employee_id = p_employee_id 
    AND company_id = p_company_id 
    AND is_active = true;

  -- Se nÃ£o tem banco de horas configurado, retornar zeros
  IF NOT FOUND OR NOT v_config.has_bank_hours THEN
    RETURN QUERY SELECT 0.00, 0.00, 0.00;
    RETURN;
  END IF;

  -- Buscar saldo atual
  SELECT * INTO v_balance 
  FROM rh.bank_hours_balance 
  WHERE employee_id = p_employee_id 
    AND company_id = p_company_id;

  -- Calcular total de horas extras no perÃ­odo
  SELECT COALESCE(SUM(horas_extras), 0) INTO v_total_extra_hours
  FROM rh.time_records 
  WHERE employee_id = p_employee_id 
    AND company_id = p_company_id
    AND data_registro BETWEEN p_period_start AND p_period_end
    AND status = 'aprovado';

  -- Determinar quanto acumular e quanto compensar
  IF v_config.auto_compensate AND v_balance.current_balance > 0 THEN
    -- Compensar horas existentes primeiro
    v_hours_to_compensate := LEAST(v_total_extra_hours, v_balance.current_balance);
    v_hours_to_accumulate := v_total_extra_hours - v_hours_to_compensate;
  ELSE
    -- Apenas acumular
    v_hours_to_accumulate := v_total_extra_hours;
  END IF;

  -- Verificar limite mÃ¡ximo de acumulaÃ§Ã£o
  IF v_hours_to_accumulate > 0 THEN
    v_hours_to_accumulate := LEAST(
      v_hours_to_accumulate, 
      v_config.max_accumulation_hours - v_balance.accumulated_hours
    );
  END IF;

  -- Atualizar saldo
  v_new_balance := v_balance.current_balance + v_hours_to_accumulate - v_hours_to_compensate;

  -- Registrar transaÃ§Ã£o de acumulaÃ§Ã£o
  IF v_hours_to_accumulate > 0 THEN
    INSERT INTO rh.bank_hours_transactions (
      employee_id, company_id, transaction_type, transaction_date,
      hours_amount, reference_period_start, reference_period_end,
      description, is_automatic
    ) VALUES (
      p_employee_id, p_company_id, 'accumulation', p_period_end,
      v_hours_to_accumulate, p_period_start, p_period_end,
      'AcumulaÃ§Ã£o automÃ¡tica de horas extras', true
    );
  END IF;

  -- Registrar transaÃ§Ã£o de compensaÃ§Ã£o
  IF v_hours_to_compensate > 0 THEN
    INSERT INTO rh.bank_hours_transactions (
      employee_id, company_id, transaction_type, transaction_date,
      hours_amount, reference_period_start, reference_period_end,
      description, compensation_rate, is_automatic
    ) VALUES (
      p_employee_id, p_company_id, 'compensation', p_period_end,
      -v_hours_to_compensate, p_period_start, p_period_end,
      'CompensaÃ§Ã£o automÃ¡tica de banco de horas', v_config.compensation_rate, true
    );
  END IF;

  -- Atualizar saldo
  UPDATE rh.bank_hours_balance SET
    current_balance = v_new_balance,
    accumulated_hours = accumulated_hours + v_hours_to_accumulate,
    compensated_hours = compensated_hours + v_hours_to_compensate,
    last_calculation_date = p_period_end,
    updated_at = NOW()
  WHERE employee_id = p_employee_id AND company_id = p_company_id;

  RETURN QUERY SELECT v_hours_to_accumulate, v_hours_to_compensate, v_new_balance;
END;
$$;


ALTER FUNCTION rh.calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date) OWNER TO postgres;

--
-- Name: create_exam_notification(uuid, uuid, uuid, character varying, character varying, text); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    INSERT INTO notifications (
        id,
        user_id,
        company_id,
        type,
        title,
        message,
        data,
        is_read,
        created_at
    ) VALUES (
        gen_random_uuid(),
        p_user_id,
        p_company_id,
        p_notification_type,
        p_title,
        p_message,
        jsonb_build_object('exam_id', p_exam_id),
        false,
        NOW()
    ) RETURNING id INTO v_notification_id;
    
    RETURN v_notification_id;
END;
$$;


ALTER FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) OWNER TO postgres;

--
-- Name: FUNCTION create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text); Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) IS 'Cria uma notificaÃ§Ã£o para um exame especÃ­fico';


--
-- Name: create_training_notification_rules(uuid, uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.create_training_notification_rules(p_training_id uuid, p_company_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    notification_type_record RECORD;
BEGIN
    -- Create notification rules for all default types
    FOR notification_type_record IN
        SELECT id, tipo FROM rh.training_notification_types
        WHERE company_id = p_company_id
        AND is_active = true
    LOOP
        INSERT INTO rh.training_notification_rules (
            company_id, training_id, notification_type_id, target_audience, dias_antecedencia
        ) VALUES (
            p_company_id,
            p_training_id,
            notification_type_record.id,
            CASE 
                WHEN notification_type_record.tipo IN ('inscricao_aberta', 'lembrete_inscricao') THEN 'todos_funcionarios'
                ELSE 'inscritos'
            END,
            (SELECT dias_antecedencia FROM rh.training_notification_types WHERE id = notification_type_record.id)
        );
    END LOOP;
END;
$$;


ALTER FUNCTION rh.create_training_notification_rules(p_training_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: get_bank_hours_balance(uuid, uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) RETURNS TABLE(current_balance numeric, accumulated_hours numeric, compensated_hours numeric, expired_hours numeric, last_calculation_date date, has_bank_hours boolean, max_accumulation_hours numeric, accumulation_period_months integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(b.current_balance, 0),
    COALESCE(b.accumulated_hours, 0),
    COALESCE(b.compensated_hours, 0),
    COALESCE(b.expired_hours, 0),
    COALESCE(b.last_calculation_date, CURRENT_DATE),
    COALESCE(c.has_bank_hours, false),
    COALESCE(c.max_accumulation_hours, 0),
    COALESCE(c.accumulation_period_months, 0)
  FROM rh.bank_hours_balance b
  FULL OUTER JOIN rh.bank_hours_config c ON b.employee_id = c.employee_id AND b.company_id = c.company_id
  WHERE (b.employee_id = p_employee_id OR c.employee_id = p_employee_id)
    AND (b.company_id = p_company_id OR c.company_id = p_company_id);
END;
$$;


ALTER FUNCTION rh.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) OWNER TO postgres;

--
-- Name: get_exams_needing_notification(uuid, integer); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer DEFAULT 30) RETURNS TABLE(exam_id uuid, employee_id uuid, employee_name character varying, exam_type character varying, scheduled_date date, days_until_exam integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pe.id as exam_id,
        pe.employee_id,
        e.nome as employee_name,
        pe.tipo_exame as exam_type,
        pe.data_agendamento as scheduled_date,
        (pe.data_agendamento - CURRENT_DATE)::INTEGER as days_until_exam
    FROM rh.periodic_exams pe
    JOIN rh.employees e ON pe.employee_id = e.id
    WHERE pe.company_id = p_company_id
    AND pe.status = 'agendado'
    AND pe.data_agendamento BETWEEN CURRENT_DATE AND (CURRENT_DATE + INTERVAL '1 day' * p_days_ahead)
    ORDER BY pe.data_agendamento ASC;
END;
$$;


ALTER FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer) OWNER TO postgres;

--
-- Name: FUNCTION get_exams_needing_notification(p_company_id uuid, p_days_ahead integer); Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer) IS 'Busca exames que precisam de notificaÃ§Ã£o baseado nos dias de antecedÃªncia';


--
-- Name: get_expired_exams(uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.get_expired_exams(p_company_id uuid) RETURNS TABLE(exam_id uuid, employee_id uuid, employee_name character varying, exam_type character varying, scheduled_date date, days_overdue integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pe.id as exam_id,
        pe.employee_id,
        e.nome as employee_name,
        pe.tipo_exame as exam_type,
        pe.data_agendamento as scheduled_date,
        (CURRENT_DATE - pe.data_agendamento)::INTEGER as days_overdue
    FROM rh.periodic_exams pe
    JOIN rh.employees e ON pe.employee_id = e.id
    WHERE pe.company_id = p_company_id
    AND pe.status = 'agendado'
    AND pe.data_agendamento < CURRENT_DATE
    ORDER BY pe.data_agendamento ASC;
END;
$$;


ALTER FUNCTION rh.get_expired_exams(p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION get_expired_exams(p_company_id uuid); Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON FUNCTION rh.get_expired_exams(p_company_id uuid) IS 'Busca exames que estÃ£o vencidos (data de agendamento no passado)';


--
-- Name: get_training_notifications(uuid, uuid, integer, integer); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0) RETURNS TABLE(id uuid, training_id uuid, training_name character varying, titulo text, mensagem text, data_envio timestamp with time zone, status character varying, tipo character varying)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tnh.id,
        tnh.training_id,
        t.nome as training_name,
        tnh.titulo,
        tnh.mensagem,
        tnh.data_envio,
        tnh.status,
        tnt.tipo
    FROM rh.training_notification_history tnh
    JOIN rh.training_notification_types tnt ON tnt.id = tnh.notification_type_id
    LEFT JOIN rh.trainings t ON t.id = tnh.training_id
    WHERE tnh.user_id = p_user_id
    AND tnh.company_id = p_company_id
    ORDER BY tnh.data_envio DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


ALTER FUNCTION rh.get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer, p_offset integer) OWNER TO postgres;

--
-- Name: get_training_settings(uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.get_training_settings(p_company_id uuid) RETURNS TABLE(id uuid, company_id uuid, notification_enabled boolean, email_notifications boolean, push_notifications boolean, reminder_days_before integer, reminder_days_after integer, auto_enrollment boolean, require_approval boolean, max_participants integer, min_attendance_percentage integer, certificate_auto_generate boolean, certificate_validity_days integer, training_duration_default numeric, evaluation_required boolean, feedback_required boolean, auto_archive_days integer, allow_self_enrollment boolean, allow_cancellation boolean, cancellation_deadline_hours integer, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ts.id,
        ts.company_id,
        ts.notification_enabled,
        ts.email_notifications,
        ts.push_notifications,
        ts.reminder_days_before,
        ts.reminder_days_after,
        ts.auto_enrollment,
        ts.require_approval,
        ts.max_participants,
        ts.min_attendance_percentage,
        ts.certificate_auto_generate,
        ts.certificate_validity_days,
        ts.training_duration_default,
        ts.evaluation_required,
        ts.feedback_required,
        ts.auto_archive_days,
        ts.allow_self_enrollment,
        ts.allow_cancellation,
        ts.cancellation_deadline_hours,
        ts.is_active,
        ts.created_at,
        ts.updated_at
    FROM rh.training_settings ts
    WHERE ts.company_id = p_company_id
    AND ts.is_active = true
    ORDER BY ts.updated_at DESC
    LIMIT 1;
END;
$$;


ALTER FUNCTION rh.get_training_settings(p_company_id uuid) OWNER TO postgres;

--
-- Name: initialize_bank_hours_config(uuid, uuid, boolean, integer, numeric, numeric); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean DEFAULT true, p_accumulation_period_months integer DEFAULT 12, p_max_accumulation_hours numeric DEFAULT 40.00, p_compensation_rate numeric DEFAULT 1.00) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_config_id UUID;
  v_balance_id UUID;
BEGIN
  -- Inserir ou atualizar configuraÃ§Ã£o
  INSERT INTO rh.bank_hours_config (
    employee_id, company_id, has_bank_hours, 
    accumulation_period_months, max_accumulation_hours, compensation_rate
  ) VALUES (
    p_employee_id, p_company_id, p_has_bank_hours,
    p_accumulation_period_months, p_max_accumulation_hours, p_compensation_rate
  )
  ON CONFLICT (employee_id, company_id) 
  DO UPDATE SET
    has_bank_hours = EXCLUDED.has_bank_hours,
    accumulation_period_months = EXCLUDED.accumulation_period_months,
    max_accumulation_hours = EXCLUDED.max_accumulation_hours,
    compensation_rate = EXCLUDED.compensation_rate,
    updated_at = NOW()
  RETURNING id INTO v_config_id;

  -- Inicializar saldo se nÃ£o existir
  INSERT INTO rh.bank_hours_balance (employee_id, company_id)
  VALUES (p_employee_id, p_company_id)
  ON CONFLICT (employee_id, company_id) DO NOTHING
  RETURNING id INTO v_balance_id;

  RETURN v_config_id;
END;
$$;


ALTER FUNCTION rh.initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean, p_accumulation_period_months integer, p_max_accumulation_hours numeric, p_compensation_rate numeric) OWNER TO postgres;

--
-- Name: process_bank_hours_expiration(uuid, date); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.process_bank_hours_expiration(p_company_id uuid, p_expiration_date date DEFAULT CURRENT_DATE) RETURNS TABLE(employees_processed integer, hours_expired numeric)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_employee_record RECORD;
  v_hours_to_expire DECIMAL(5,2);
  v_total_employees INTEGER := 0;
  v_total_hours_expired DECIMAL(8,2) := 0;
BEGIN
  -- Processar cada colaborador com banco de horas
  FOR v_employee_record IN
    SELECT 
      b.employee_id,
      b.company_id,
      b.current_balance,
      c.expires_after_months,
      c.accumulation_period_months
    FROM rh.bank_hours_balance b
    JOIN rh.bank_hours_config c ON b.employee_id = c.employee_id AND b.company_id = c.company_id
    WHERE b.company_id = p_company_id
      AND c.is_active = true
      AND c.has_bank_hours = true
      AND b.current_balance > 0
  LOOP
    -- Calcular horas que devem expirar
    v_hours_to_expire := 0;
    
    -- LÃ³gica de expiraÃ§Ã£o baseada no perÃ­odo de acumulaÃ§Ã£o
    -- Por simplicidade, vamos expirar horas antigas baseado na data de cÃ¡lculo
    IF v_employee_record.current_balance > 0 THEN
      -- Verificar se hÃ¡ horas que devem expirar
      -- Esta Ã© uma implementaÃ§Ã£o simplificada - pode ser refinada conforme necessÃ¡rio
      v_hours_to_expire := LEAST(
        v_employee_record.current_balance,
        v_employee_record.current_balance * 0.1 -- Expirar 10% das horas por mÃªs
      );
    END IF;

    -- Registrar expiraÃ§Ã£o se houver horas para expirar
    IF v_hours_to_expire > 0 THEN
      INSERT INTO rh.bank_hours_transactions (
        employee_id, company_id, transaction_type, transaction_date,
        hours_amount, description, is_automatic
      ) VALUES (
        v_employee_record.employee_id, v_employee_record.company_id, 'expiration', p_expiration_date,
        -v_hours_to_expire, 'ExpiraÃ§Ã£o automÃ¡tica de horas do banco', true
      );

      -- Atualizar saldo
      UPDATE rh.bank_hours_balance SET
        current_balance = current_balance - v_hours_to_expire,
        expired_hours = expired_hours + v_hours_to_expire,
        updated_at = NOW()
      WHERE employee_id = v_employee_record.employee_id 
        AND company_id = v_employee_record.company_id;

      v_total_hours_expired := v_total_hours_expired + v_hours_to_expire;
    END IF;

    v_total_employees := v_total_employees + 1;
  END LOOP;

  RETURN QUERY SELECT v_total_employees, v_total_hours_expired;
END;
$$;


ALTER FUNCTION rh.process_bank_hours_expiration(p_company_id uuid, p_expiration_date date) OWNER TO postgres;

--
-- Name: process_notification_queue(); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.process_notification_queue() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    notification_record RECORD;
    success_count INTEGER := 0;
    error_count INTEGER := 0;
BEGIN
    -- Process pending notifications
    FOR notification_record IN
        SELECT * FROM rh.training_notification_queue
        WHERE status = 'pendente'
        AND data_agendamento <= NOW()
        AND tentativas < max_tentativas
        ORDER BY data_agendamento ASC
        LIMIT 100
    LOOP
        BEGIN
            -- Insert into public notifications table
            INSERT INTO public.notifications (
                user_id, company_id, title, message, type, is_read, created_at
            ) VALUES (
                notification_record.user_id,
                notification_record.company_id,
                notification_record.titulo,
                notification_record.mensagem,
                'training',
                false,
                NOW()
            );

            -- Update queue status
            UPDATE rh.training_notification_queue
            SET status = 'enviada',
                data_envio = NOW(),
                tentativas = tentativas + 1
            WHERE id = notification_record.id;

            -- Insert into history
            INSERT INTO rh.training_notification_history (
                company_id, training_id, notification_type_id, user_id, employee_id,
                titulo, mensagem, data_envio, status, metodo_envio
            ) VALUES (
                notification_record.company_id,
                notification_record.training_id,
                notification_record.notification_type_id,
                notification_record.user_id,
                notification_record.employee_id,
                notification_record.titulo,
                notification_record.mensagem,
                NOW(),
                'enviada',
                'sistema'
            );

            success_count := success_count + 1;

        EXCEPTION WHEN OTHERS THEN
            -- Update queue with error
            UPDATE rh.training_notification_queue
            SET status = CASE 
                WHEN tentativas + 1 >= max_tentativas THEN 'falhou'
                ELSE 'pendente'
            END,
            tentativas = tentativas + 1,
            erro_mensagem = SQLERRM
            WHERE id = notification_record.id;

            error_count := error_count + 1;
        END;
    END LOOP;

    -- Log processing results
    RAISE NOTICE 'Processed % notifications successfully, % failed', success_count, error_count;
END;
$$;


ALTER FUNCTION rh.process_notification_queue() OWNER TO postgres;

--
-- Name: run_bank_hours_calculation(uuid, date); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date DEFAULT CURRENT_DATE) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_calculation_id UUID;
  v_period_start DATE;
  v_period_end DATE;
  v_employee_record RECORD;
  v_result RECORD;
  v_total_accumulated DECIMAL(8,2) := 0;
  v_total_compensated DECIMAL(8,2) := 0;
  v_total_expired DECIMAL(8,2) := 0;
  v_employees_processed INTEGER := 0;
BEGIN
  -- Criar registro de cÃ¡lculo
  INSERT INTO rh.bank_hours_calculations (
    company_id, calculation_date, period_start, period_end, status
  ) VALUES (
    p_company_id, p_calculation_date, 
    p_calculation_date - INTERVAL '1 month', p_calculation_date,
    'running'
  ) RETURNING id INTO v_calculation_id;

  -- Definir perÃ­odo de cÃ¡lculo (Ãºltimo mÃªs)
  v_period_start := p_calculation_date - INTERVAL '1 month';
  v_period_end := p_calculation_date;

  -- Processar cada colaborador com banco de horas ativo
  FOR v_employee_record IN
    SELECT employee_id, company_id
    FROM rh.bank_hours_config
    WHERE company_id = p_company_id
      AND is_active = true
      AND has_bank_hours = true
  LOOP
    -- Calcular e acumular horas para este colaborador
    SELECT * INTO v_result
    FROM rh.calculate_and_accumulate_bank_hours(
      v_employee_record.employee_id,
      v_employee_record.company_id,
      v_period_start,
      v_period_end
    );

    v_total_accumulated := v_total_accumulated + v_result.hours_accumulated;
    v_total_compensated := v_total_compensated + v_result.hours_compensated;
    v_employees_processed := v_employees_processed + 1;
  END LOOP;

  -- Processar expiraÃ§Ã£o de horas
  SELECT * INTO v_result
  FROM rh.process_bank_hours_expiration(p_company_id, p_calculation_date);
  
  v_total_expired := v_result.hours_expired;

  -- Atualizar registro de cÃ¡lculo
  UPDATE rh.bank_hours_calculations SET
    employees_processed = v_employees_processed,
    hours_accumulated = v_total_accumulated,
    hours_compensated = v_total_compensated,
    hours_expired = v_total_expired,
    status = 'completed',
    completed_at = NOW()
  WHERE id = v_calculation_id;

  RETURN v_calculation_id;
END;
$$;


ALTER FUNCTION rh.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) OWNER TO postgres;

--
-- Name: schedule_exam_notifications(uuid); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.schedule_exam_notifications(p_company_id uuid) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_notifications_created INTEGER := 0;
    v_exam RECORD;
    v_user_id UUID;
    v_title VARCHAR;
    v_message TEXT;
BEGIN
    -- Buscar exames que precisam de notificaÃ§Ã£o (30 dias antes)
    FOR v_exam IN 
        SELECT * FROM rh.get_exams_needing_notification(p_company_id, 30)
    LOOP
        -- Buscar user_id do funcionÃ¡rio
        SELECT user_id INTO v_user_id 
        FROM rh.employees 
        WHERE id = v_exam.employee_id;
        
        -- SÃ³ criar notificaÃ§Ã£o se o funcionÃ¡rio tiver user_id
        IF v_user_id IS NOT NULL THEN
            -- Definir tÃ­tulo e mensagem baseado nos dias restantes
            IF v_exam.days_until_exam = 0 THEN
                v_title := 'Exame Agendado para Hoje';
                v_message := 'VocÃª tem um exame ' || v_exam.exam_type || ' agendado para hoje.';
            ELSIF v_exam.days_until_exam <= 7 THEN
                v_title := 'Exame PrÃ³ximo';
                v_message := 'VocÃª tem um exame ' || v_exam.exam_type || ' agendado para ' || 
                           v_exam.days_until_exam || ' dias.';
            ELSIF v_exam.days_until_exam <= 30 THEN
                v_title := 'Lembrete de Exame';
                v_message := 'VocÃª tem um exame ' || v_exam.exam_type || ' agendado para ' || 
                           v_exam.days_until_exam || ' dias.';
            END IF;
            
            -- Criar notificaÃ§Ã£o
            PERFORM rh.create_exam_notification(
                v_user_id,
                p_company_id,
                v_exam.exam_id,
                'exam_reminder',
                v_title,
                v_message
            );
            
            v_notifications_created := v_notifications_created + 1;
        END IF;
    END LOOP;
    
    -- Buscar exames vencidos
    FOR v_exam IN 
        SELECT * FROM rh.get_expired_exams(p_company_id)
    LOOP
        -- Buscar user_id do funcionÃ¡rio
        SELECT user_id INTO v_user_id 
        FROM rh.employees 
        WHERE id = v_exam.employee_id;
        
        -- SÃ³ criar notificaÃ§Ã£o se o funcionÃ¡rio tiver user_id
        IF v_user_id IS NOT NULL THEN
            v_title := 'Exame Vencido';
            v_message := 'Seu exame ' || v_exam.exam_type || ' estava agendado para ' || 
                        v_exam.scheduled_date || ' e estÃ¡ ' || v_exam.days_overdue || ' dias atrasado.';
            
            -- Criar notificaÃ§Ã£o
            PERFORM rh.create_exam_notification(
                v_user_id,
                p_company_id,
                v_exam.exam_id,
                'exam_overdue',
                v_title,
                v_message
            );
            
            v_notifications_created := v_notifications_created + 1;
        END IF;
    END LOOP;
    
    RETURN v_notifications_created;
END;
$$;


ALTER FUNCTION rh.schedule_exam_notifications(p_company_id uuid) OWNER TO postgres;

--
-- Name: FUNCTION schedule_exam_notifications(p_company_id uuid); Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON FUNCTION rh.schedule_exam_notifications(p_company_id uuid) IS 'Agenda notificaÃ§Ãµes automÃ¡ticas para exames (30 dias antes e vencidos)';


--
-- Name: schedule_training_notifications(); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.schedule_training_notifications() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    training_record RECORD;
    notification_type_record RECORD;
    employee_record RECORD;
    user_record RECORD;
    scheduled_date TIMESTAMP WITH TIME ZONE;
    template_titulo TEXT;
    template_mensagem TEXT;
BEGIN
    -- Process each active training
    FOR training_record IN 
        SELECT t.*, nt.dias_antecedencia, nt.template_titulo, nt.template_mensagem, nt.tipo
        FROM rh.trainings t
        JOIN rh.training_notification_rules tnr ON tnr.training_id = t.id
        JOIN rh.training_notification_types nt ON nt.id = tnr.notification_type_id
        WHERE t.is_active = true 
        AND tnr.is_enabled = true
        AND t.status IN ('inscricoes_abertas', 'em_andamento', 'concluido')
    LOOP
        -- Calculate scheduled date based on training date and days_antecedencia
        CASE training_record.tipo
            WHEN 'inscricao_aberta' THEN
                scheduled_date := training_record.data_limite_inscricao - INTERVAL '0 days';
            WHEN 'lembrete_inscricao' THEN
                scheduled_date := training_record.data_limite_inscricao - INTERVAL '3 days';
            WHEN 'inicio_treinamento' THEN
                scheduled_date := training_record.data_inicio;
            WHEN 'fim_treinamento' THEN
                scheduled_date := training_record.data_fim;
            WHEN 'certificado_disponivel' THEN
                scheduled_date := training_record.data_fim + INTERVAL '1 day';
            WHEN 'presenca_obrigatoria' THEN
                scheduled_date := training_record.data_inicio - INTERVAL '1 day';
            ELSE
                scheduled_date := NOW() + INTERVAL '1 hour';
        END CASE;

        -- Get target audience
        FOR employee_record IN
            SELECT DISTINCT e.*, u.id as user_id
            FROM rh.employees e
            LEFT JOIN public.users u ON u.id = e.user_id
            WHERE e.company_id = training_record.company_id
            AND e.status = 'ativo'
            AND (
                training_record.tipo IN ('inscricao_aberta', 'lembrete_inscricao') OR
                EXISTS (
                    SELECT 1 FROM rh.training_enrollments te 
                    WHERE te.training_id = training_record.id 
                    AND te.employee_id = e.id
                    AND te.status IN ('inscrito', 'confirmado', 'presente')
                )
            )
        LOOP
            -- Replace template variables
            template_titulo := training_record.template_titulo;
            template_mensagem := training_record.template_mensagem;
            
            template_titulo := REPLACE(template_titulo, '{training_name}', training_record.nome);
            template_titulo := REPLACE(template_titulo, '{training_date}', training_record.data_inicio::text);
            template_titulo := REPLACE(template_titulo, '{training_time}', '08:00');
            template_titulo := REPLACE(template_titulo, '{training_location}', COALESCE(training_record.local, 'A definir'));
            template_titulo := REPLACE(template_titulo, '{available_slots}', COALESCE(training_record.vagas_disponiveis::text, 'Ilimitadas'));
            template_titulo := REPLACE(template_titulo, '{deadline_date}', COALESCE(training_record.data_limite_inscricao::text, 'Não definido'));
            
            template_mensagem := REPLACE(template_mensagem, '{training_name}', training_record.nome);
            template_mensagem := REPLACE(template_mensagem, '{training_date}', training_record.data_inicio::text);
            template_mensagem := REPLACE(template_mensagem, '{training_time}', '08:00');
            template_mensagem := REPLACE(template_mensagem, '{training_location}', COALESCE(training_record.local, 'A definir'));
            template_mensagem := REPLACE(template_mensagem, '{available_slots}', COALESCE(training_record.vagas_disponiveis::text, 'Ilimitadas'));
            template_mensagem := REPLACE(template_mensagem, '{deadline_date}', COALESCE(training_record.data_limite_inscricao::text, 'Não definido'));
            template_mensagem := REPLACE(template_mensagem, '{new_date}', training_record.data_inicio::text);

            -- Insert notification into queue
            INSERT INTO rh.training_notification_queue (
                company_id, training_id, notification_type_id, user_id, employee_id,
                titulo, mensagem, data_agendamento, status
            ) VALUES (
                training_record.company_id,
                training_record.id,
                (SELECT id FROM rh.training_notification_types WHERE tipo = training_record.tipo AND company_id = training_record.company_id LIMIT 1),
                employee_record.user_id,
                employee_record.id,
                template_titulo,
                template_mensagem,
                scheduled_date,
                'pendente'
            );
        END LOOP;
    END LOOP;
END;
$$;


ALTER FUNCTION rh.schedule_training_notifications() OWNER TO postgres;

--
-- Name: trigger_create_training_notification_rules(); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.trigger_create_training_notification_rules() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM rh.create_training_notification_rules(NEW.id, NEW.company_id);
    RETURN NEW;
END;
$$;


ALTER FUNCTION rh.trigger_create_training_notification_rules() OWNER TO postgres;

--
-- Name: update_training_settings_updated_at(); Type: FUNCTION; Schema: rh; Owner: postgres
--

CREATE FUNCTION rh.update_training_settings_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION rh.update_training_settings_updated_at() OWNER TO postgres;

--
-- Name: add_prefixes(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.add_prefixes(_bucket_id text, _name text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    prefixes text[];
BEGIN
    prefixes := "storage"."get_prefixes"("_name");

    IF array_length(prefixes, 1) > 0 THEN
        INSERT INTO storage.prefixes (name, bucket_id)
        SELECT UNNEST(prefixes) as name, "_bucket_id" ON CONFLICT DO NOTHING;
    END IF;
END;
$$;


ALTER FUNCTION storage.add_prefixes(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: can_insert_object(text, text, uuid, jsonb); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$$;


ALTER FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) OWNER TO supabase_storage_admin;

--
-- Name: delete_leaf_prefixes(text[], text[]); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_rows_deleted integer;
BEGIN
    LOOP
        WITH candidates AS (
            SELECT DISTINCT
                t.bucket_id,
                unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        ),
        uniq AS (
             SELECT
                 bucket_id,
                 name,
                 storage.get_level(name) AS level
             FROM candidates
             WHERE name <> ''
             GROUP BY bucket_id, name
        ),
        leaf AS (
             SELECT
                 p.bucket_id,
                 p.name,
                 p.level
             FROM storage.prefixes AS p
                  JOIN uniq AS u
                       ON u.bucket_id = p.bucket_id
                           AND u.name = p.name
                           AND u.level = p.level
             WHERE NOT EXISTS (
                 SELECT 1
                 FROM storage.objects AS o
                 WHERE o.bucket_id = p.bucket_id
                   AND o.level = p.level + 1
                   AND o.name COLLATE "C" LIKE p.name || '/%'
             )
             AND NOT EXISTS (
                 SELECT 1
                 FROM storage.prefixes AS c
                 WHERE c.bucket_id = p.bucket_id
                   AND c.level = p.level + 1
                   AND c.name COLLATE "C" LIKE p.name || '/%'
             )
        )
        DELETE
        FROM storage.prefixes AS p
            USING leaf AS l
        WHERE p.bucket_id = l.bucket_id
          AND p.name = l.name
          AND p.level = l.level;

        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
        EXIT WHEN v_rows_deleted = 0;
    END LOOP;
END;
$$;


ALTER FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[]) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix(_bucket_id text, _name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Check if we can delete the prefix
    IF EXISTS(
        SELECT FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name") + 1
          AND "prefixes"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    )
    OR EXISTS(
        SELECT FROM "storage"."objects"
        WHERE "objects"."bucket_id" = "_bucket_id"
          AND "storage"."get_level"("objects"."name") = "storage"."get_level"("_name") + 1
          AND "objects"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    ) THEN
    -- There are sub-objects, skip deletion
    RETURN false;
    ELSE
        DELETE FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name")
          AND "prefixes"."name" = "_name";
        RETURN true;
    END IF;
END;
$$;


ALTER FUNCTION storage.delete_prefix(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix_hierarchy_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix_hierarchy_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    prefix text;
BEGIN
    prefix := "storage"."get_prefix"(OLD."name");

    IF coalesce(prefix, '') != '' THEN
        PERFORM "storage"."delete_prefix"(OLD."bucket_id", prefix);
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION storage.delete_prefix_hierarchy_trigger() OWNER TO supabase_storage_admin;

--
-- Name: enforce_bucket_name_length(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.enforce_bucket_name_length() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
    if length(new.name) > 100 then
        raise exception 'bucket name "%" is too long (% characters). Max is 100.', new.name, length(new.name);
    end if;
    return new;
end;
$$;


ALTER FUNCTION storage.enforce_bucket_name_length() OWNER TO supabase_storage_admin;

--
-- Name: extension(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.extension(name text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$$;


ALTER FUNCTION storage.extension(name text) OWNER TO supabase_storage_admin;

--
-- Name: filename(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.filename(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$$;


ALTER FUNCTION storage.filename(name text) OWNER TO supabase_storage_admin;

--
-- Name: foldername(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.foldername(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
BEGIN
    -- Split on "/" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$$;


ALTER FUNCTION storage.foldername(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_level(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_level(name text) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT array_length(string_to_array("name", '/'), 1);
$$;


ALTER FUNCTION storage.get_level(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefix(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefix(name text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT
    CASE WHEN strpos("name", '/') > 0 THEN
             regexp_replace("name", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$_$;


ALTER FUNCTION storage.get_prefix(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefixes(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefixes(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array("name", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$$;


ALTER FUNCTION storage.get_prefixes(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_size_by_bucket(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_size_by_bucket() RETURNS TABLE(size bigint, bucket_id text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$$;


ALTER FUNCTION storage.get_size_by_bucket() OWNER TO supabase_storage_admin;

--
-- Name: list_multipart_uploads_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text) RETURNS TABLE(key text, id text, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$_$;


ALTER FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text) OWNER TO supabase_storage_admin;

--
-- Name: list_objects_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text) RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$_$;


ALTER FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text) OWNER TO supabase_storage_admin;

--
-- Name: lock_top_prefixes(text[], text[]); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[]) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket text;
    v_top text;
BEGIN
    FOR v_bucket, v_top IN
        SELECT DISTINCT t.bucket_id,
            split_part(t.name, '/', 1) AS top
        FROM unnest(bucket_ids, names) AS t(bucket_id, name)
        WHERE t.name <> ''
        ORDER BY 1, 2
        LOOP
            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));
        END LOOP;
END;
$$;


ALTER FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[]) OWNER TO supabase_storage_admin;

--
-- Name: objects_delete_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_delete_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.objects_delete_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: objects_insert_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_insert_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    NEW.level := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_insert_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    -- NEW - OLD (destinations to create prefixes for)
    v_add_bucket_ids text[];
    v_add_names      text[];

    -- OLD - NEW (sources to prune)
    v_src_bucket_ids text[];
    v_src_names      text[];
BEGIN
    IF TG_OP <> 'UPDATE' THEN
        RETURN NULL;
    END IF;

    -- 1) Compute NEW−OLD (added paths) and OLD−NEW (moved-away paths)
    WITH added AS (
        SELECT n.bucket_id, n.name
        FROM new_rows n
        WHERE n.name <> '' AND position('/' in n.name) > 0
        EXCEPT
        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''
    ),
    moved AS (
         SELECT o.bucket_id, o.name
         FROM old_rows o
         WHERE o.name <> ''
         EXCEPT
         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''
    )
    SELECT
        -- arrays for ADDED (dest) in stable order
        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),
        -- arrays for MOVED (src) in stable order
        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),
        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )
    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;

    -- Nothing to do?
    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN
        RETURN NULL;
    END IF;

    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks
    DECLARE
        v_all_bucket_ids text[];
        v_all_names text[];
    BEGIN
        -- Combine source and destination arrays for consistent lock ordering
        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');
        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');

        -- Single lock call ensures consistent global ordering across all transactions
        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN
            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);
        END IF;
    END;

    -- 3) Create destination prefixes (NEW−OLD) BEFORE pruning sources
    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN
        WITH candidates AS (
            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name
            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)
            WHERE name <> ''
        )
        INSERT INTO storage.prefixes (bucket_id, name)
        SELECT c.bucket_id, c.name
        FROM candidates c
        ON CONFLICT DO NOTHING;
    END IF;

    -- 4) Prune source prefixes bottom-up for OLD−NEW
    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN
        -- re-entrancy guard so DELETE on prefixes won't recurse
        IF current_setting('storage.gc.prefixes', true) <> '1' THEN
            PERFORM set_config('storage.gc.prefixes', '1', true);
        END IF;

        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);
    END IF;

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.objects_update_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_level_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_level_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW."name" <> OLD."name" OR NEW."bucket_id" <> OLD."bucket_id") THEN
        -- Set the new level
        NEW."level" := "storage"."get_level"(NEW."name");
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_update_level_trigger() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_prefixes TEXT[];
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW."name" <> OLD."name" OR NEW."bucket_id" <> OLD."bucket_id") THEN
        -- Retrieve old prefixes
        old_prefixes := "storage"."get_prefixes"(OLD."name");

        -- Remove old prefixes that are only used by this object
        WITH all_prefixes as (
            SELECT unnest(old_prefixes) as prefix
        ),
        can_delete_prefixes as (
             SELECT prefix
             FROM all_prefixes
             WHERE NOT EXISTS (
                 SELECT 1 FROM "storage"."objects"
                 WHERE "bucket_id" = OLD."bucket_id"
                   AND "name" <> OLD."name"
                   AND "name" LIKE (prefix || '%')
             )
         )
        DELETE FROM "storage"."prefixes" WHERE name IN (SELECT prefix FROM can_delete_prefixes);

        -- Add new prefixes
        PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    END IF;
    -- Set the new level
    NEW."level" := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_update_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: operation(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.operation() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$$;


ALTER FUNCTION storage.operation() OWNER TO supabase_storage_admin;

--
-- Name: prefixes_delete_cleanup(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.prefixes_delete_cleanup() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_bucket_ids text[];
    v_names      text[];
BEGIN
    IF current_setting('storage.gc.prefixes', true) = '1' THEN
        RETURN NULL;
    END IF;

    PERFORM set_config('storage.gc.prefixes', '1', true);

    SELECT COALESCE(array_agg(d.bucket_id), '{}'),
           COALESCE(array_agg(d.name), '{}')
    INTO v_bucket_ids, v_names
    FROM deleted AS d
    WHERE d.name <> '';

    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);
    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);

    RETURN NULL;
END;
$$;


ALTER FUNCTION storage.prefixes_delete_cleanup() OWNER TO supabase_storage_admin;

--
-- Name: prefixes_insert_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.prefixes_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.prefixes_insert_trigger() OWNER TO supabase_storage_admin;

--
-- Name: search(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql
    AS $$
declare
    can_bypass_rls BOOLEAN;
begin
    SELECT rolbypassrls
    INTO can_bypass_rls
    FROM pg_roles
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);

    IF can_bypass_rls THEN
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$$;


ALTER FUNCTION storage.search(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_legacy_v1(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v1_optimised(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select (string_to_array(name, ''/''))[level] as name
           from storage.prefixes
             where lower(prefixes.name) like lower($2 || $3) || ''%''
               and bucket_id = $4
               and level = $1
           order by name ' || v_sort_order || '
     )
     (select name,
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[level] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where lower(objects.name) like lower($2 || $3) || ''%''
       and bucket_id = $4
       and level = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v2(text, text, integer, integer, text, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text) RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
    sort_col text;
    sort_ord text;
    cursor_op text;
    cursor_expr text;
    sort_expr text;
BEGIN
    -- Validate sort_order
    sort_ord := lower(sort_order);
    IF sort_ord NOT IN ('asc', 'desc') THEN
        sort_ord := 'asc';
    END IF;

    -- Determine cursor comparison operator
    IF sort_ord = 'asc' THEN
        cursor_op := '>';
    ELSE
        cursor_op := '<';
    END IF;
    
    sort_col := lower(sort_column);
    -- Validate sort column  
    IF sort_col IN ('updated_at', 'created_at') THEN
        cursor_expr := format(
            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE "C") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',
            sort_col, cursor_op
        );
        sort_expr := format(
            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE "C" %s',
            sort_col, sort_ord, sort_ord
        );
    ELSE
        cursor_expr := format('($5 = '''' OR name COLLATE "C" %s $5)', cursor_op);
        sort_expr := format('name COLLATE "C" %s', sort_ord);
    END IF;

    RETURN QUERY EXECUTE format(
        $sql$
        SELECT * FROM (
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    NULL::uuid AS id,
                    updated_at,
                    created_at,
                    NULL::timestamptz AS last_accessed_at,
                    NULL::jsonb AS metadata
                FROM storage.prefixes
                WHERE name COLLATE "C" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
            UNION ALL
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name,
                    id,
                    updated_at,
                    created_at,
                    last_accessed_at,
                    metadata
                FROM storage.objects
                WHERE name COLLATE "C" LIKE $1 || '%%'
                    AND bucket_id = $2
                    AND level = $4
                    AND %s
                ORDER BY %s
                LIMIT $3
            )
        ) obj
        ORDER BY %s
        LIMIT $3
        $sql$,
        cursor_expr,    -- prefixes WHERE
        sort_expr,      -- prefixes ORDER BY
        cursor_expr,    -- objects WHERE
        sort_expr,      -- objects ORDER BY
        sort_expr       -- final ORDER BY
    )
    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;
END;
$_$;


ALTER FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text) OWNER TO supabase_storage_admin;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$$;


ALTER FUNCTION storage.update_updated_at_column() OWNER TO supabase_storage_admin;

--
-- Name: almoxarifados; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.almoxarifados (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    codigo character varying(50) NOT NULL,
    endereco text,
    responsavel_id uuid,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE almoxarifado.almoxarifados OWNER TO postgres;

--
-- Name: TABLE almoxarifados; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.almoxarifados IS 'Cadastro de almoxarifados/locais de estoque';


--
-- Name: checklist_recebimento; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.checklist_recebimento (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    entrada_id uuid NOT NULL,
    item_id uuid NOT NULL,
    criterio character varying(255) NOT NULL,
    aprovado boolean NOT NULL,
    observacoes text,
    usuario_id uuid NOT NULL,
    data_verificacao timestamp with time zone DEFAULT now(),
    company_id uuid NOT NULL
);


ALTER TABLE almoxarifado.checklist_recebimento OWNER TO postgres;

--
-- Name: TABLE checklist_recebimento; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.checklist_recebimento IS 'Checklist de inspeÃ§Ã£o de recebimento';


--
-- Name: COLUMN checklist_recebimento.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.checklist_recebimento.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: entrada_itens; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.entrada_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    entrada_id uuid NOT NULL,
    material_equipamento_id uuid NOT NULL,
    quantidade_recebida integer NOT NULL,
    quantidade_aprovada integer DEFAULT 0,
    valor_unitario numeric(15,2),
    valor_total numeric(15,2),
    centro_custo_id uuid,
    projeto_id uuid,
    lote character varying(100),
    validade date,
    observacoes text,
    company_id uuid NOT NULL,
    CONSTRAINT check_quantidade_entrada CHECK (((quantidade_recebida > 0) AND (quantidade_aprovada >= 0)))
);


ALTER TABLE almoxarifado.entrada_itens OWNER TO postgres;

--
-- Name: TABLE entrada_itens; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.entrada_itens IS 'Itens especÃ­ficos de cada entrada';


--
-- Name: COLUMN entrada_itens.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.entrada_itens.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: entradas_materiais; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.entradas_materiais (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nfe_id uuid,
    fornecedor_id uuid,
    numero_nota character varying(50),
    data_entrada date NOT NULL,
    valor_total numeric(15,2),
    status character varying(20) DEFAULT 'pendente'::character varying,
    checklist_aprovado boolean DEFAULT false,
    usuario_recebimento_id uuid,
    usuario_aprovacao_id uuid,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT entradas_materiais_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'inspecao'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE almoxarifado.entradas_materiais OWNER TO postgres;

--
-- Name: TABLE entradas_materiais; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.entradas_materiais IS 'Entradas de materiais via NF-e ou manual';


--
-- Name: estoque_atual; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.estoque_atual (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_equipamento_id uuid NOT NULL,
    almoxarifado_id uuid NOT NULL,
    quantidade_atual integer DEFAULT 0 NOT NULL,
    quantidade_reservada integer DEFAULT 0,
    quantidade_disponivel integer GENERATED ALWAYS AS ((quantidade_atual - quantidade_reservada)) STORED,
    valor_total numeric(15,2),
    updated_at timestamp with time zone DEFAULT now(),
    company_id uuid NOT NULL,
    CONSTRAINT check_quantidade_positiva CHECK (((quantidade_atual >= 0) AND (quantidade_reservada >= 0)))
);


ALTER TABLE almoxarifado.estoque_atual OWNER TO postgres;

--
-- Name: TABLE estoque_atual; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.estoque_atual IS 'Controle de estoque atual por material e almoxarifado';


--
-- Name: COLUMN estoque_atual.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.estoque_atual.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: inventario_itens; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.inventario_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    inventario_id uuid NOT NULL,
    material_equipamento_id uuid NOT NULL,
    quantidade_sistema integer NOT NULL,
    quantidade_contada integer,
    divergencia integer GENERATED ALWAYS AS ((COALESCE(quantidade_contada, 0) - quantidade_sistema)) STORED,
    observacoes text,
    contador_id uuid,
    data_contagem timestamp with time zone DEFAULT now(),
    company_id uuid NOT NULL
);


ALTER TABLE almoxarifado.inventario_itens OWNER TO postgres;

--
-- Name: TABLE inventario_itens; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.inventario_itens IS 'Itens contados em cada inventÃ¡rio';


--
-- Name: COLUMN inventario_itens.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.inventario_itens.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: inventarios; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.inventarios (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    almoxarifado_id uuid NOT NULL,
    tipo character varying(20) NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    status character varying(20) DEFAULT 'aberto'::character varying,
    responsavel_id uuid NOT NULL,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_data_inventario CHECK (((data_fim IS NULL) OR (data_fim >= data_inicio))),
    CONSTRAINT inventarios_status_check CHECK (((status)::text = ANY ((ARRAY['aberto'::character varying, 'em_andamento'::character varying, 'validado'::character varying, 'fechado'::character varying])::text[]))),
    CONSTRAINT inventarios_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['geral'::character varying, 'ciclico'::character varying, 'rotativo'::character varying])::text[])))
);


ALTER TABLE almoxarifado.inventarios OWNER TO postgres;

--
-- Name: TABLE inventarios; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.inventarios IS 'Controle de inventÃ¡rios fÃ­sicos';


--
-- Name: localizacoes_fisicas; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.localizacoes_fisicas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    almoxarifado_id uuid NOT NULL,
    rua character varying(10),
    nivel character varying(10),
    posicao character varying(10),
    descricao text,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    company_id uuid NOT NULL
);


ALTER TABLE almoxarifado.localizacoes_fisicas OWNER TO postgres;

--
-- Name: TABLE localizacoes_fisicas; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.localizacoes_fisicas IS 'LocalizaÃ§Ãµes fÃ­sicas dentro dos almoxarifados';


--
-- Name: COLUMN localizacoes_fisicas.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.localizacoes_fisicas.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: materiais_equipamentos; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.materiais_equipamentos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    material_id uuid,
    codigo_interno character varying(100) NOT NULL,
    descricao text NOT NULL,
    tipo character varying(20) NOT NULL,
    classe character varying(100),
    unidade_medida character varying(20) NOT NULL,
    imagem_url text,
    status character varying(20) DEFAULT 'ativo'::character varying,
    equipamento_proprio boolean DEFAULT true,
    localizacao_id uuid,
    estoque_minimo integer DEFAULT 0,
    estoque_maximo integer,
    valor_unitario numeric(15,2),
    validade_dias integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    ncm character varying(20),
    cfop character varying(10),
    cst character varying(10),
    CONSTRAINT check_estoque_min_max CHECK ((estoque_minimo <= COALESCE(estoque_maximo, 999999))),
    CONSTRAINT materiais_equipamentos_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying])::text[]))),
    CONSTRAINT materiais_equipamentos_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['produto'::character varying, 'servico'::character varying, 'equipamento'::character varying])::text[])))
);


ALTER TABLE almoxarifado.materiais_equipamentos OWNER TO postgres;

--
-- Name: TABLE materiais_equipamentos; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.materiais_equipamentos IS 'Materiais e equipamentos do almoxarifado';


--
-- Name: COLUMN materiais_equipamentos.ncm; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.materiais_equipamentos.ncm IS 'CÃ³digo NCM (Nomenclatura Comum do Mercosul)';


--
-- Name: COLUMN materiais_equipamentos.cfop; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.materiais_equipamentos.cfop IS 'CÃ³digo Fiscal de OperaÃ§Ãµes e PrestaÃ§Ãµes';


--
-- Name: COLUMN materiais_equipamentos.cst; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.materiais_equipamentos.cst IS 'CÃ³digo de SituaÃ§Ã£o TributÃ¡ria';


--
-- Name: movimentacoes_estoque; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.movimentacoes_estoque (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    material_equipamento_id uuid NOT NULL,
    almoxarifado_origem_id uuid,
    almoxarifado_destino_id uuid,
    tipo_movimentacao character varying(20) NOT NULL,
    quantidade integer NOT NULL,
    valor_unitario numeric(15,2),
    valor_total numeric(15,2),
    centro_custo_id uuid,
    projeto_id uuid,
    nfe_id uuid,
    observacoes text,
    usuario_id uuid NOT NULL,
    data_movimentacao timestamp with time zone DEFAULT now(),
    status character varying(20) DEFAULT 'confirmado'::character varying,
    CONSTRAINT check_almoxarifado_origem_destino CHECK (((((tipo_movimentacao)::text = 'entrada'::text) AND (almoxarifado_origem_id IS NULL) AND (almoxarifado_destino_id IS NOT NULL)) OR (((tipo_movimentacao)::text = 'saida'::text) AND (almoxarifado_origem_id IS NOT NULL) AND (almoxarifado_destino_id IS NULL)) OR (((tipo_movimentacao)::text = 'transferencia'::text) AND (almoxarifado_origem_id IS NOT NULL) AND (almoxarifado_destino_id IS NOT NULL)) OR (((tipo_movimentacao)::text = ANY ((ARRAY['ajuste'::character varying, 'inventario'::character varying])::text[])) AND (almoxarifado_origem_id IS NOT NULL) AND (almoxarifado_destino_id IS NULL)))),
    CONSTRAINT check_quantidade_movimentacao CHECK ((quantidade <> 0)),
    CONSTRAINT movimentacoes_estoque_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'confirmado'::character varying, 'cancelado'::character varying])::text[]))),
    CONSTRAINT movimentacoes_estoque_tipo_movimentacao_check CHECK (((tipo_movimentacao)::text = ANY ((ARRAY['entrada'::character varying, 'saida'::character varying, 'transferencia'::character varying, 'ajuste'::character varying, 'inventario'::character varying])::text[])))
);


ALTER TABLE almoxarifado.movimentacoes_estoque OWNER TO postgres;

--
-- Name: TABLE movimentacoes_estoque; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.movimentacoes_estoque IS 'HistÃ³rico de todas as movimentaÃ§Ãµes de estoque';


--
-- Name: solicitacoes_compra; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.solicitacoes_compra (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    material_equipamento_id uuid NOT NULL,
    almoxarifado_id uuid NOT NULL,
    quantidade_solicitada integer NOT NULL,
    quantidade_minima integer NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    centro_custo_id uuid,
    projeto_id uuid,
    prioridade character varying(20) DEFAULT 'normal'::character varying,
    created_at timestamp with time zone DEFAULT now(),
    atendido_at timestamp with time zone,
    CONSTRAINT check_quantidade_solicitacao CHECK (((quantidade_solicitada > 0) AND (quantidade_minima > 0))),
    CONSTRAINT solicitacoes_compra_prioridade_check CHECK (((prioridade)::text = ANY ((ARRAY['baixa'::character varying, 'normal'::character varying, 'alta'::character varying, 'urgente'::character varying])::text[]))),
    CONSTRAINT solicitacoes_compra_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'atendido'::character varying])::text[])))
);


ALTER TABLE almoxarifado.solicitacoes_compra OWNER TO postgres;

--
-- Name: TABLE solicitacoes_compra; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.solicitacoes_compra IS 'SolicitaÃ§Ãµes automÃ¡ticas de compra por estoque mÃ­nimo';


--
-- Name: solicitacoes_saida_materiais; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.solicitacoes_saida_materiais (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    funcionario_solicitante_id uuid NOT NULL,
    almoxarifado_id uuid NOT NULL,
    centro_custo_id uuid,
    projeto_id uuid,
    data_solicitacao timestamp with time zone DEFAULT now(),
    data_aprovacao timestamp with time zone,
    data_saida timestamp with time zone,
    status character varying(20) DEFAULT 'pendente'::character varying,
    valor_total numeric(15,2),
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    funcionario_receptor_id uuid,
    CONSTRAINT solicitacoes_saida_materiais_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'cancelado'::character varying, 'entregue'::character varying])::text[])))
);


ALTER TABLE almoxarifado.solicitacoes_saida_materiais OWNER TO postgres;

--
-- Name: TABLE solicitacoes_saida_materiais; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.solicitacoes_saida_materiais IS 'SolicitaÃ§Ãµes de saÃ­da de materiais para funcionÃ¡rios';


--
-- Name: solicitacoes_saida_materiais_itens; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.solicitacoes_saida_materiais_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    solicitacao_id uuid NOT NULL,
    material_id uuid NOT NULL,
    quantidade_solicitada numeric(10,2) NOT NULL,
    quantidade_entregue numeric(10,2) DEFAULT 0,
    valor_unitario numeric(15,2),
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE almoxarifado.solicitacoes_saida_materiais_itens OWNER TO postgres;

--
-- Name: transferencia_itens; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.transferencia_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    transferencia_id uuid NOT NULL,
    material_equipamento_id uuid NOT NULL,
    quantidade_solicitada integer NOT NULL,
    quantidade_aprovada integer DEFAULT 0,
    centro_custo_id uuid,
    projeto_id uuid,
    company_id uuid NOT NULL,
    CONSTRAINT check_quantidade_transferencia CHECK (((quantidade_solicitada > 0) AND (quantidade_aprovada >= 0)))
);


ALTER TABLE almoxarifado.transferencia_itens OWNER TO postgres;

--
-- Name: TABLE transferencia_itens; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.transferencia_itens IS 'Itens especÃ­ficos de cada transferÃªncia';


--
-- Name: COLUMN transferencia_itens.company_id; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON COLUMN almoxarifado.transferencia_itens.company_id IS 'ID da empresa para isolamento multi-tenant';


--
-- Name: transferencias; Type: TABLE; Schema: almoxarifado; Owner: postgres
--

CREATE TABLE almoxarifado.transferencias (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    almoxarifado_origem_id uuid NOT NULL,
    almoxarifado_destino_id uuid NOT NULL,
    solicitante_id uuid NOT NULL,
    aprovador_id uuid,
    data_solicitacao timestamp with time zone DEFAULT now(),
    data_aprovacao timestamp with time zone,
    data_transferencia timestamp with time zone,
    status character varying(20) DEFAULT 'pendente'::character varying,
    observacoes text,
    CONSTRAINT check_almoxarifado_diferentes CHECK ((almoxarifado_origem_id <> almoxarifado_destino_id)),
    CONSTRAINT transferencias_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'transferido'::character varying])::text[])))
);


ALTER TABLE almoxarifado.transferencias OWNER TO postgres;

--
-- Name: TABLE transferencias; Type: COMMENT; Schema: almoxarifado; Owner: postgres
--

COMMENT ON TABLE almoxarifado.transferencias IS 'TransferÃªncias entre almoxarifados';


--
-- Name: audit_log_entries; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.audit_log_entries (
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE auth.audit_log_entries OWNER TO supabase_auth_admin;

--
-- Name: TABLE audit_log_entries; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.audit_log_entries IS 'Auth: Audit trail for user actions.';


--
-- Name: flow_state; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.flow_state (
    id uuid NOT NULL,
    user_id uuid,
    auth_code text NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text NOT NULL,
    provider_type text NOT NULL,
    provider_access_token text,
    provider_refresh_token text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text NOT NULL,
    auth_code_issued_at timestamp with time zone
);


ALTER TABLE auth.flow_state OWNER TO supabase_auth_admin;

--
-- Name: TABLE flow_state; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.flow_state IS 'stores metadata for pkce logins';


--
-- Name: identities; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.identities (
    provider_id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE auth.identities OWNER TO supabase_auth_admin;

--
-- Name: TABLE identities; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';


--
-- Name: COLUMN identities.email; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.identities.email IS 'Auth: Email is a generated column that references the optional email property in the identity_data';


--
-- Name: instances; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.instances (
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);


ALTER TABLE auth.instances OWNER TO supabase_auth_admin;

--
-- Name: TABLE instances; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.instances IS 'Auth: Manages users across multiple sites.';


--
-- Name: mfa_amr_claims; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_amr_claims (
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text NOT NULL,
    id uuid NOT NULL
);


ALTER TABLE auth.mfa_amr_claims OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_amr_claims; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_amr_claims IS 'auth: stores authenticator method reference claims for multi factor authentication';


--
-- Name: mfa_challenges; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_challenges (
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text,
    web_authn_session_data jsonb
);


ALTER TABLE auth.mfa_challenges OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_challenges; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_challenges IS 'auth: stores metadata about challenge requests made';


--
-- Name: mfa_factors; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_factors (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text,
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text,
    phone text,
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid
);


ALTER TABLE auth.mfa_factors OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_factors; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_factors IS 'auth: stores metadata about factors';


--
-- Name: oauth_authorizations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_authorizations (
    id uuid NOT NULL,
    authorization_id text NOT NULL,
    client_id uuid NOT NULL,
    user_id uuid,
    redirect_uri text NOT NULL,
    scope text NOT NULL,
    state text,
    resource text,
    code_challenge text,
    code_challenge_method auth.code_challenge_method,
    response_type auth.oauth_response_type DEFAULT 'code'::auth.oauth_response_type NOT NULL,
    status auth.oauth_authorization_status DEFAULT 'pending'::auth.oauth_authorization_status NOT NULL,
    authorization_code text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone DEFAULT (now() + '00:03:00'::interval) NOT NULL,
    approved_at timestamp with time zone,
    CONSTRAINT oauth_authorizations_authorization_code_length CHECK ((char_length(authorization_code) <= 255)),
    CONSTRAINT oauth_authorizations_code_challenge_length CHECK ((char_length(code_challenge) <= 128)),
    CONSTRAINT oauth_authorizations_expires_at_future CHECK ((expires_at > created_at)),
    CONSTRAINT oauth_authorizations_redirect_uri_length CHECK ((char_length(redirect_uri) <= 2048)),
    CONSTRAINT oauth_authorizations_resource_length CHECK ((char_length(resource) <= 2048)),
    CONSTRAINT oauth_authorizations_scope_length CHECK ((char_length(scope) <= 4096)),
    CONSTRAINT oauth_authorizations_state_length CHECK ((char_length(state) <= 4096))
);


ALTER TABLE auth.oauth_authorizations OWNER TO supabase_auth_admin;

--
-- Name: oauth_clients; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_clients (
    id uuid NOT NULL,
    client_secret_hash text,
    registration_type auth.oauth_registration_type NOT NULL,
    redirect_uris text NOT NULL,
    grant_types text NOT NULL,
    client_name text,
    client_uri text,
    logo_uri text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted_at timestamp with time zone,
    client_type auth.oauth_client_type DEFAULT 'confidential'::auth.oauth_client_type NOT NULL,
    CONSTRAINT oauth_clients_client_name_length CHECK ((char_length(client_name) <= 1024)),
    CONSTRAINT oauth_clients_client_uri_length CHECK ((char_length(client_uri) <= 2048)),
    CONSTRAINT oauth_clients_logo_uri_length CHECK ((char_length(logo_uri) <= 2048))
);


ALTER TABLE auth.oauth_clients OWNER TO supabase_auth_admin;

--
-- Name: oauth_consents; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.oauth_consents (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    client_id uuid NOT NULL,
    scopes text NOT NULL,
    granted_at timestamp with time zone DEFAULT now() NOT NULL,
    revoked_at timestamp with time zone,
    CONSTRAINT oauth_consents_revoked_after_granted CHECK (((revoked_at IS NULL) OR (revoked_at >= granted_at))),
    CONSTRAINT oauth_consents_scopes_length CHECK ((char_length(scopes) <= 2048)),
    CONSTRAINT oauth_consents_scopes_not_empty CHECK ((char_length(TRIM(BOTH FROM scopes)) > 0))
);


ALTER TABLE auth.oauth_consents OWNER TO supabase_auth_admin;

--
-- Name: one_time_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.one_time_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text NOT NULL,
    relates_to text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT one_time_tokens_token_hash_check CHECK ((char_length(token_hash) > 0))
);


ALTER TABLE auth.one_time_tokens OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL,
    token character varying(255),
    user_id character varying(255),
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255),
    session_id uuid
);


ALTER TABLE auth.refresh_tokens OWNER TO supabase_auth_admin;

--
-- Name: TABLE refresh_tokens; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.refresh_tokens IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE; Schema: auth; Owner: supabase_auth_admin
--

CREATE SEQUENCE auth.refresh_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE auth.refresh_tokens_id_seq OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: auth; Owner: supabase_auth_admin
--

ALTER SEQUENCE auth.refresh_tokens_id_seq OWNED BY auth.refresh_tokens.id;


--
-- Name: saml_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_providers (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text NOT NULL,
    metadata_xml text NOT NULL,
    metadata_url text,
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text,
    CONSTRAINT "entity_id not empty" CHECK ((char_length(entity_id) > 0)),
    CONSTRAINT "metadata_url not empty" CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0))),
    CONSTRAINT "metadata_xml not empty" CHECK ((char_length(metadata_xml) > 0))
);


ALTER TABLE auth.saml_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_providers IS 'Auth: Manages SAML Identity Provider connections.';


--
-- Name: saml_relay_states; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_relay_states (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text NOT NULL,
    for_email text,
    redirect_to text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT "request_id not empty" CHECK ((char_length(request_id) > 0))
);


ALTER TABLE auth.saml_relay_states OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_relay_states; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_relay_states IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';


--
-- Name: schema_migrations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.schema_migrations (
    version character varying(255) NOT NULL
);


ALTER TABLE auth.schema_migrations OWNER TO supabase_auth_admin;

--
-- Name: TABLE schema_migrations; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.schema_migrations IS 'Auth: Manages updates to the auth system.';


--
-- Name: sessions; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text,
    ip inet,
    tag text,
    oauth_client_id uuid
);


ALTER TABLE auth.sessions OWNER TO supabase_auth_admin;

--
-- Name: TABLE sessions; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sessions IS 'Auth: Stores session data associated to a user.';


--
-- Name: COLUMN sessions.not_after; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.not_after IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';


--
-- Name: sso_domains; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_domains (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "domain not empty" CHECK ((char_length(domain) > 0))
);


ALTER TABLE auth.sso_domains OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_domains; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_domains IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';


--
-- Name: sso_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_providers (
    id uuid NOT NULL,
    resource_id text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    disabled boolean,
    CONSTRAINT "resource_id not empty" CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))
);


ALTER TABLE auth.sso_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_providers IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';


--
-- Name: COLUMN sso_providers.resource_id; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sso_providers.resource_id IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';


--
-- Name: users; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.users (
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255),
    role character varying(255),
    email character varying(255),
    encrypted_password character varying(255),
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255),
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255),
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255),
    email_change character varying(255),
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text DEFAULT ''::character varying,
    phone_change_token character varying(255) DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean DEFAULT false NOT NULL,
    deleted_at timestamp with time zone,
    is_anonymous boolean DEFAULT false NOT NULL,
    CONSTRAINT users_email_change_confirm_status_check CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))
);


ALTER TABLE auth.users OWNER TO supabase_auth_admin;

--
-- Name: TABLE users; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.users IS 'Auth: Stores user login data within a secure schema.';


--
-- Name: COLUMN users.is_sso_user; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.users.is_sso_user IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';


--
-- Name: aprovacoes_cotacao; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.aprovacoes_cotacao (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    cotacao_id uuid NOT NULL,
    aprovador_id uuid NOT NULL,
    nivel_aprovacao integer NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    data_aprovacao timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aprovacoes_cotacao_nivel_aprovacao_check CHECK ((nivel_aprovacao > 0)),
    CONSTRAINT aprovacoes_cotacao_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE compras.aprovacoes_cotacao OWNER TO postgres;

--
-- Name: TABLE aprovacoes_cotacao; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.aprovacoes_cotacao IS 'Workflow de aprovaÃ§Ã£o para cotaÃ§Ãµes';


--
-- Name: aprovacoes_requisicao; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.aprovacoes_requisicao (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    requisicao_id uuid NOT NULL,
    aprovador_id uuid NOT NULL,
    nivel_aprovacao integer NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    data_aprovacao timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aprovacoes_requisicao_nivel_aprovacao_check CHECK ((nivel_aprovacao > 0)),
    CONSTRAINT aprovacoes_requisicao_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE compras.aprovacoes_requisicao OWNER TO postgres;

--
-- Name: TABLE aprovacoes_requisicao; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.aprovacoes_requisicao IS 'Workflow de aprovaÃ§Ã£o para requisiÃ§Ãµes';


--
-- Name: avaliacoes_fornecedor; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.avaliacoes_fornecedor (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    fornecedor_id uuid NOT NULL,
    pedido_id uuid,
    avaliador_id uuid NOT NULL,
    company_id uuid NOT NULL,
    nota_prazo numeric(3,2) NOT NULL,
    nota_qualidade numeric(3,2) NOT NULL,
    nota_preco numeric(3,2) NOT NULL,
    nota_atendimento numeric(3,2) NOT NULL,
    media_geral numeric(3,2) GENERATED ALWAYS AS (((((nota_prazo + nota_qualidade) + nota_preco) + nota_atendimento) / (4)::numeric)) STORED,
    observacoes text,
    data_avaliacao date DEFAULT CURRENT_DATE,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT avaliacoes_fornecedor_nota_atendimento_check CHECK (((nota_atendimento >= (0)::numeric) AND (nota_atendimento <= (10)::numeric))),
    CONSTRAINT avaliacoes_fornecedor_nota_prazo_check CHECK (((nota_prazo >= (0)::numeric) AND (nota_prazo <= (10)::numeric))),
    CONSTRAINT avaliacoes_fornecedor_nota_preco_check CHECK (((nota_preco >= (0)::numeric) AND (nota_preco <= (10)::numeric))),
    CONSTRAINT avaliacoes_fornecedor_nota_qualidade_check CHECK (((nota_qualidade >= (0)::numeric) AND (nota_qualidade <= (10)::numeric)))
);


ALTER TABLE compras.avaliacoes_fornecedor OWNER TO postgres;

--
-- Name: TABLE avaliacoes_fornecedor; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.avaliacoes_fornecedor IS 'AvaliaÃ§Ãµes de fornecedores por pedidos';


--
-- Name: COLUMN avaliacoes_fornecedor.media_geral; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.avaliacoes_fornecedor.media_geral IS 'MÃ©dia automÃ¡tica das 4 notas';


--
-- Name: compras_recorrentes; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.compras_recorrentes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    contrato_id uuid,
    material_id uuid NOT NULL,
    company_id uuid NOT NULL,
    quantidade_mensal numeric(10,3) NOT NULL,
    valor_unitario numeric(10,2) NOT NULL,
    valor_total_mensal numeric(15,2) GENERATED ALWAYS AS ((quantidade_mensal * valor_unitario)) STORED,
    proxima_compra date,
    frequencia_dias integer DEFAULT 30,
    status character varying(20) DEFAULT 'ativo'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT compras_recorrentes_quantidade_mensal_check CHECK ((quantidade_mensal > (0)::numeric)),
    CONSTRAINT compras_recorrentes_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'pausado'::character varying, 'finalizado'::character varying])::text[]))),
    CONSTRAINT compras_recorrentes_valor_unitario_check CHECK ((valor_unitario >= (0)::numeric))
);


ALTER TABLE compras.compras_recorrentes OWNER TO postgres;

--
-- Name: TABLE compras_recorrentes; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.compras_recorrentes IS 'Compras recorrentes baseadas em contratos';


--
-- Name: configuracoes_aprovacao; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.configuracoes_aprovacao (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    tipo_documento character varying(50) NOT NULL,
    valor_limite numeric(15,2) NOT NULL,
    nivel_aprovacao integer NOT NULL,
    departamento_id uuid,
    classe_financeira character varying(50),
    perfil_id uuid,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT configuracoes_aprovacao_nivel_aprovacao_check CHECK ((nivel_aprovacao > 0)),
    CONSTRAINT configuracoes_aprovacao_tipo_documento_check CHECK (((tipo_documento)::text = ANY ((ARRAY['requisicao'::character varying, 'cotacao'::character varying, 'pedido'::character varying])::text[]))),
    CONSTRAINT configuracoes_aprovacao_valor_limite_check CHECK ((valor_limite > (0)::numeric))
);


ALTER TABLE compras.configuracoes_aprovacao OWNER TO postgres;

--
-- Name: TABLE configuracoes_aprovacao; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.configuracoes_aprovacao IS 'ConfiguraÃ§Ãµes de aprovaÃ§Ã£o por valor, departamento e perfil';


--
-- Name: contratos; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.contratos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    fornecedor_id uuid NOT NULL,
    company_id uuid NOT NULL,
    numero_contrato character varying(50) NOT NULL,
    descricao text NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    renovacao_automatica boolean DEFAULT false,
    valor_total numeric(15,2),
    valor_mensal numeric(15,2),
    tipo_reajuste compras.tipo_reajuste,
    indice_reajuste character varying(50),
    percentual_reajuste numeric(5,2),
    status character varying(20) DEFAULT 'ativo'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT contratos_check CHECK ((data_fim >= data_inicio)),
    CONSTRAINT contratos_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'suspenso'::character varying, 'finalizado'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE compras.contratos OWNER TO postgres;

--
-- Name: TABLE contratos; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.contratos IS 'Contratos com fornecedores';


--
-- Name: COLUMN contratos.renovacao_automatica; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.contratos.renovacao_automatica IS 'Se o contrato deve ser renovado automaticamente';


--
-- Name: cotacao_itens; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.cotacao_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    cotacao_id uuid NOT NULL,
    requisicao_item_id uuid NOT NULL,
    material_id uuid NOT NULL,
    quantidade numeric(10,3) NOT NULL,
    valor_unitario numeric(10,2) NOT NULL,
    valor_total numeric(15,2) NOT NULL,
    prazo_entrega integer,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT cotacao_itens_quantidade_check CHECK ((quantidade > (0)::numeric)),
    CONSTRAINT cotacao_itens_valor_total_check CHECK ((valor_total >= (0)::numeric)),
    CONSTRAINT cotacao_itens_valor_unitario_check CHECK ((valor_unitario >= (0)::numeric))
);


ALTER TABLE compras.cotacao_itens OWNER TO postgres;

--
-- Name: TABLE cotacao_itens; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.cotacao_itens IS 'Itens especÃ­ficos de cada cotaÃ§Ã£o';


--
-- Name: cotacoes; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.cotacoes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    requisicao_id uuid NOT NULL,
    fornecedor_id uuid NOT NULL,
    numero_cotacao character varying(50),
    data_cotacao date DEFAULT CURRENT_DATE,
    data_validade date,
    status compras.status_cotacao DEFAULT 'rascunho'::compras.status_cotacao,
    metodo_envio compras.metodo_envio,
    link_fornecedor text,
    valor_total numeric(15,2) DEFAULT 0,
    desconto_percentual numeric(5,2) DEFAULT 0,
    valor_final numeric(15,2) DEFAULT 0,
    prazo_entrega integer,
    condicoes_pagamento text,
    observacoes text,
    anexos jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT cotacoes_check CHECK ((data_validade >= data_cotacao))
);


ALTER TABLE compras.cotacoes OWNER TO postgres;

--
-- Name: TABLE cotacoes; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.cotacoes IS 'CotaÃ§Ãµes de fornecedores para requisiÃ§Ãµes';


--
-- Name: COLUMN cotacoes.link_fornecedor; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.cotacoes.link_fornecedor IS 'Link para fornecedor preencher cotaÃ§Ã£o online';


--
-- Name: COLUMN cotacoes.anexos; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.cotacoes.anexos IS 'Array de anexos em JSON';


--
-- Name: fornecedores_dados; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.fornecedores_dados (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    partner_id uuid NOT NULL,
    company_id uuid NOT NULL,
    contato_principal character varying(255),
    email_cotacao character varying(255),
    telefone character varying(20),
    celular character varying(20),
    uf character varying(2),
    cidade character varying(100),
    endereco text,
    cep character varying(10),
    prazo_pagamento integer DEFAULT 30,
    desconto_padrao numeric(5,2) DEFAULT 0,
    limite_credito numeric(15,2),
    nota_media numeric(3,2) DEFAULT 0,
    total_avaliacoes integer DEFAULT 0,
    status character varying(20) DEFAULT 'ativo'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT fornecedores_dados_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying, 'bloqueado'::character varying])::text[])))
);


ALTER TABLE compras.fornecedores_dados OWNER TO postgres;

--
-- Name: TABLE fornecedores_dados; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.fornecedores_dados IS 'Dados especÃ­ficos de fornecedores para o mÃ³dulo de compras';


--
-- Name: COLUMN fornecedores_dados.partner_id; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.fornecedores_dados.partner_id IS 'ReferÃªncia ao partner base em public.partners';


--
-- Name: COLUMN fornecedores_dados.prazo_pagamento; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.fornecedores_dados.prazo_pagamento IS 'Prazo de pagamento em dias';


--
-- Name: COLUMN fornecedores_dados.nota_media; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.fornecedores_dados.nota_media IS 'MÃ©dia das avaliaÃ§Ãµes (0-10)';


--
-- Name: pedidos_compra; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.pedidos_compra (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    cotacao_id uuid,
    fornecedor_id uuid NOT NULL,
    company_id uuid NOT NULL,
    numero_pedido character varying(50) NOT NULL,
    data_pedido date DEFAULT CURRENT_DATE,
    data_entrega_prevista date,
    data_entrega_real date,
    status compras.status_pedido DEFAULT 'rascunho'::compras.status_pedido,
    valor_total numeric(15,2) DEFAULT 0,
    desconto_percentual numeric(5,2) DEFAULT 0,
    valor_final numeric(15,2) DEFAULT 0,
    cnpj_emissor character varying(18),
    razao_social_emissor character varying(255),
    observacoes text,
    condicoes_especiais text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT pedidos_compra_check CHECK ((data_entrega_prevista >= data_pedido))
);


ALTER TABLE compras.pedidos_compra OWNER TO postgres;

--
-- Name: TABLE pedidos_compra; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.pedidos_compra IS 'Pedidos de compra gerados a partir de cotaÃ§Ãµes';


--
-- Name: COLUMN pedidos_compra.cnpj_emissor; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.pedidos_compra.cnpj_emissor IS 'CNPJ que emitirÃ¡ a NF (pode ser diferente do fornecedor)';


--
-- Name: requisicoes_compra; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.requisicoes_compra (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    solicitante_id uuid NOT NULL,
    centro_custo_id uuid,
    projeto_id uuid,
    numero_requisicao character varying(50) NOT NULL,
    data_solicitacao date DEFAULT CURRENT_DATE,
    data_necessidade date,
    status compras.status_requisicao DEFAULT 'rascunho'::compras.status_requisicao,
    prioridade compras.prioridade DEFAULT 'normal'::compras.prioridade,
    valor_total_estimado numeric(15,2) DEFAULT 0,
    valor_total_aprovado numeric(15,2),
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    observacoes_aprovacao text,
    observacoes text,
    justificativa text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT requisicoes_compra_check CHECK ((data_necessidade >= data_solicitacao))
);


ALTER TABLE compras.requisicoes_compra OWNER TO postgres;

--
-- Name: TABLE requisicoes_compra; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.requisicoes_compra IS 'RequisiÃ§Ãµes de compra com workflow de aprovaÃ§Ã£o';


--
-- Name: COLUMN requisicoes_compra.numero_requisicao; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.requisicoes_compra.numero_requisicao IS 'NÃºmero sequencial da requisiÃ§Ã£o por empresa';


--
-- Name: COLUMN requisicoes_compra.data_necessidade; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.requisicoes_compra.data_necessidade IS 'Data em que o material Ã© necessÃ¡rio';


--
-- Name: dashboard_compras; Type: VIEW; Schema: compras; Owner: postgres
--

CREATE VIEW compras.dashboard_compras AS
 SELECT rc.company_id,
    count(
        CASE
            WHEN (rc.status = 'pendente_aprovacao'::compras.status_requisicao) THEN 1
            ELSE NULL::integer
        END) AS requisicoes_pendentes,
    count(
        CASE
            WHEN (c.status = 'enviada'::compras.status_cotacao) THEN 1
            ELSE NULL::integer
        END) AS cotacoes_enviadas,
    count(
        CASE
            WHEN (pc.status = 'enviado'::compras.status_pedido) THEN 1
            ELSE NULL::integer
        END) AS pedidos_enviados,
    COALESCE(sum(rc.valor_total_estimado), (0)::numeric) AS valor_total_estimado,
    COALESCE(sum(pc.valor_final), (0)::numeric) AS valor_total_pedidos,
    count(DISTINCT fd.id) AS total_fornecedores
   FROM (((compras.requisicoes_compra rc
     LEFT JOIN compras.cotacoes c ON ((c.requisicao_id = rc.id)))
     LEFT JOIN compras.pedidos_compra pc ON ((pc.cotacao_id = c.id)))
     LEFT JOIN compras.fornecedores_dados fd ON ((fd.company_id = rc.company_id)))
  WHERE (rc.created_at >= (CURRENT_DATE - '30 days'::interval))
  GROUP BY rc.company_id;


ALTER VIEW compras.dashboard_compras OWNER TO postgres;

--
-- Name: VIEW dashboard_compras; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON VIEW compras.dashboard_compras IS 'Dashboard principal do mÃ³dulo de compras';


--
-- Name: dashboard_estoque_minimo; Type: VIEW; Schema: compras; Owner: postgres
--

CREATE VIEW compras.dashboard_estoque_minimo AS
 SELECT ea.company_id,
    count(
        CASE
            WHEN (
            CASE
                WHEN (ea.quantidade_atual <= me.estoque_minimo) THEN 'CRITICO'::text
                WHEN ((ea.quantidade_atual)::numeric <= ((me.estoque_minimo)::numeric * 1.5)) THEN 'ATENCAO'::text
                ELSE 'NORMAL'::text
            END = 'CRITICO'::text) THEN 1
            ELSE NULL::integer
        END) AS estoques_criticos,
    count(
        CASE
            WHEN (
            CASE
                WHEN (ea.quantidade_atual <= me.estoque_minimo) THEN 'CRITICO'::text
                WHEN ((ea.quantidade_atual)::numeric <= ((me.estoque_minimo)::numeric * 1.5)) THEN 'ATENCAO'::text
                ELSE 'NORMAL'::text
            END = 'ATENCAO'::text) THEN 1
            ELSE NULL::integer
        END) AS estoques_atencao,
    count(
        CASE
            WHEN (
            CASE
                WHEN (ea.quantidade_atual <= me.estoque_minimo) THEN 'CRITICO'::text
                WHEN ((ea.quantidade_atual)::numeric <= ((me.estoque_minimo)::numeric * 1.5)) THEN 'ATENCAO'::text
                ELSE 'NORMAL'::text
            END = 'NORMAL'::text) THEN 1
            ELSE NULL::integer
        END) AS estoques_normais,
    count(*) AS total_materiais_monitorados,
    avg(
        CASE
            WHEN (me.estoque_minimo > 0) THEN ((ea.quantidade_atual)::numeric / (me.estoque_minimo)::numeric)
            ELSE (1)::numeric
        END) AS media_estoque_vs_minimo
   FROM (almoxarifado.estoque_atual ea
     JOIN almoxarifado.materiais_equipamentos me ON ((me.id = ea.material_equipamento_id)))
  WHERE ((me.estoque_minimo IS NOT NULL) AND (me.estoque_minimo > 0))
  GROUP BY ea.company_id;


ALTER VIEW compras.dashboard_estoque_minimo OWNER TO postgres;

--
-- Name: VIEW dashboard_estoque_minimo; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON VIEW compras.dashboard_estoque_minimo IS 'Dashboard de monitoramento de estoque minimo';


--
-- Name: historico_compras; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.historico_compras (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    pedido_id uuid NOT NULL,
    material_id uuid NOT NULL,
    fornecedor_id uuid NOT NULL,
    company_id uuid NOT NULL,
    quantidade numeric(10,3) NOT NULL,
    valor_unitario numeric(10,2) NOT NULL,
    valor_total numeric(15,2) NOT NULL,
    data_compra date NOT NULL,
    data_entrega date,
    status character varying(20) DEFAULT 'entregue'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT historico_compras_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'entregue'::character varying, 'parcial'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE compras.historico_compras OWNER TO postgres;

--
-- Name: TABLE historico_compras; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.historico_compras IS 'HistÃ³rico consolidado de todas as compras realizadas';


--
-- Name: historico_precos; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.historico_precos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    material_id uuid NOT NULL,
    fornecedor_id uuid,
    company_id uuid NOT NULL,
    valor_unitario numeric(10,2) NOT NULL,
    quantidade numeric(10,3),
    cotacao_id uuid,
    pedido_id uuid,
    data_cotacao date DEFAULT CURRENT_DATE,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT historico_precos_valor_unitario_check CHECK ((valor_unitario >= (0)::numeric))
);


ALTER TABLE compras.historico_precos OWNER TO postgres;

--
-- Name: TABLE historico_precos; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.historico_precos IS 'HistÃ³rico de preÃ§os de materiais por fornecedor';


--
-- Name: pedido_itens; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.pedido_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    pedido_id uuid NOT NULL,
    cotacao_item_id uuid,
    material_id uuid NOT NULL,
    quantidade numeric(10,3) NOT NULL,
    valor_unitario numeric(10,2) NOT NULL,
    valor_total numeric(15,2) NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    prazo_entrega integer,
    quantidade_entregue numeric(10,3) DEFAULT 0,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT pedido_itens_quantidade_check CHECK ((quantidade > (0)::numeric)),
    CONSTRAINT pedido_itens_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'entregue'::character varying, 'parcial'::character varying, 'cancelado'::character varying])::text[]))),
    CONSTRAINT pedido_itens_valor_total_check CHECK ((valor_total >= (0)::numeric)),
    CONSTRAINT pedido_itens_valor_unitario_check CHECK ((valor_unitario >= (0)::numeric))
);


ALTER TABLE compras.pedido_itens OWNER TO postgres;

--
-- Name: TABLE pedido_itens; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.pedido_itens IS 'Itens especÃ­ficos de cada pedido de compra';


--
-- Name: partners; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partners (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid,
    tipo public.partner_type[] NOT NULL,
    razao_social text NOT NULL,
    nome_fantasia text,
    cnpj text NOT NULL,
    matriz_id uuid,
    endereco jsonb,
    contato jsonb,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.partners OWNER TO postgres;

--
-- Name: performance_fornecedores; Type: VIEW; Schema: compras; Owner: postgres
--

CREATE VIEW compras.performance_fornecedores AS
 SELECT fd.id AS fornecedor_id,
    COALESCE(p.nome_fantasia, p.razao_social) AS fornecedor_nome,
    fd.uf,
    fd.cidade,
    fd.nota_media,
    fd.total_avaliacoes,
    count(pc.id) AS total_pedidos,
    COALESCE(sum(pc.valor_final), (0)::numeric) AS valor_total_compras,
    avg(
        CASE
            WHEN (pc.data_entrega_real IS NOT NULL) THEN (pc.data_entrega_real - pc.data_entrega_prevista)
            ELSE NULL::integer
        END) AS atraso_medio_dias
   FROM ((compras.fornecedores_dados fd
     JOIN public.partners p ON ((p.id = fd.partner_id)))
     LEFT JOIN compras.pedidos_compra pc ON ((pc.fornecedor_id = fd.id)))
  WHERE ((fd.status)::text = 'ativo'::text)
  GROUP BY fd.id, p.nome_fantasia, p.razao_social, fd.uf, fd.cidade, fd.nota_media, fd.total_avaliacoes
  ORDER BY fd.nota_media DESC;


ALTER VIEW compras.performance_fornecedores OWNER TO postgres;

--
-- Name: VIEW performance_fornecedores; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON VIEW compras.performance_fornecedores IS 'Performance e estatÃ­sticas dos fornecedores - CORRIGIDA';


--
-- Name: requisicao_itens; Type: TABLE; Schema: compras; Owner: postgres
--

CREATE TABLE compras.requisicao_itens (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    requisicao_id uuid NOT NULL,
    material_id uuid NOT NULL,
    almoxarifado_id uuid,
    quantidade numeric(10,3) NOT NULL,
    unidade_medida character varying(20) DEFAULT 'UN'::character varying,
    valor_unitario_estimado numeric(10,2),
    valor_total_estimado numeric(15,2),
    especificacao_tecnica text,
    observacoes text,
    status character varying(20) DEFAULT 'pendente'::character varying,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT requisicao_itens_quantidade_check CHECK ((quantidade > (0)::numeric)),
    CONSTRAINT requisicao_itens_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'cotado'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE compras.requisicao_itens OWNER TO postgres;

--
-- Name: TABLE requisicao_itens; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON TABLE compras.requisicao_itens IS 'Itens das requisiÃ§Ãµes de compra';


--
-- Name: COLUMN requisicao_itens.almoxarifado_id; Type: COMMENT; Schema: compras; Owner: postgres
--

COMMENT ON COLUMN compras.requisicao_itens.almoxarifado_id IS 'Almoxarifado de destino do material';


--
-- Name: aprovacoes; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.aprovacoes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    entidade_tipo character varying(50) NOT NULL,
    entidade_id uuid NOT NULL,
    nivel_aprovacao integer NOT NULL,
    aprovador_id uuid NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    data_aprovacao timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aprovacoes_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE financeiro.aprovacoes OWNER TO postgres;

--
-- Name: TABLE aprovacoes; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.aprovacoes IS 'HistÃ³rico de aprovaÃ§Ãµes';


--
-- Name: borderos; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.borderos (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    numero_borderos character varying(50) NOT NULL,
    data_geracao date NOT NULL,
    data_vencimento date NOT NULL,
    valor_total numeric(15,2) NOT NULL,
    quantidade_titulos integer NOT NULL,
    status character varying(20) DEFAULT 'gerado'::character varying,
    banco_codigo character varying(10),
    arquivo_remessa text,
    arquivo_retorno text,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT borderos_status_check CHECK (((status)::text = ANY ((ARRAY['gerado'::character varying, 'enviado'::character varying, 'processado'::character varying, 'retornado'::character varying])::text[])))
);


ALTER TABLE financeiro.borderos OWNER TO postgres;

--
-- Name: TABLE borderos; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.borderos IS 'BorderÃ´s de cobranÃ§a';


--
-- Name: conciliacoes_bancarias; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.conciliacoes_bancarias (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    conta_bancaria_id uuid NOT NULL,
    data_conciliacao date NOT NULL,
    saldo_banco numeric(15,2) NOT NULL,
    saldo_sistema numeric(15,2) NOT NULL,
    diferenca numeric(15,2) NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT conciliacoes_bancarias_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'conciliada'::character varying, 'divergente'::character varying])::text[])))
);


ALTER TABLE financeiro.conciliacoes_bancarias OWNER TO postgres;

--
-- Name: TABLE conciliacoes_bancarias; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.conciliacoes_bancarias IS 'ConciliaÃ§Ãµes bancÃ¡rias';


--
-- Name: configuracao_bancaria; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.configuracao_bancaria (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome_configuracao character varying(100) NOT NULL,
    banco_codigo character varying(10) NOT NULL,
    banco_nome character varying(100) NOT NULL,
    ambiente character varying(20) NOT NULL,
    client_id character varying(200),
    client_secret text,
    api_key text,
    access_token text,
    refresh_token text,
    base_url character varying(500) NOT NULL,
    auth_url character varying(500),
    api_version character varying(20) DEFAULT 'v1'::character varying,
    grant_type character varying(50) DEFAULT 'client_credentials'::character varying,
    scope character varying(200),
    token_expires_at timestamp with time zone,
    configuracao_banco jsonb DEFAULT '{}'::jsonb,
    credenciais_validas boolean DEFAULT false,
    conectividade_ok boolean DEFAULT false,
    ultima_validacao timestamp with time zone,
    erro_validacao text,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT configuracao_bancaria_ambiente_check CHECK (((ambiente)::text = ANY ((ARRAY['producao'::character varying, 'sandbox'::character varying, 'homologacao'::character varying])::text[])))
);


ALTER TABLE financeiro.configuracao_bancaria OWNER TO postgres;

--
-- Name: TABLE configuracao_bancaria; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.configuracao_bancaria IS 'ConfiguraÃ§Ãµes de integraÃ§Ã£o bancÃ¡ria por empresa e banco';


--
-- Name: COLUMN configuracao_bancaria.client_secret; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.client_secret IS 'Client secret da API bancÃ¡ria (criptografado)';


--
-- Name: COLUMN configuracao_bancaria.api_key; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.api_key IS 'Chave da API bancÃ¡ria (criptografada)';


--
-- Name: COLUMN configuracao_bancaria.access_token; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.access_token IS 'Token de acesso (criptografado)';


--
-- Name: COLUMN configuracao_bancaria.configuracao_banco; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.configuracao_banco IS 'ConfiguraÃ§Ãµes especÃ­ficas do banco (JSON)';


--
-- Name: COLUMN configuracao_bancaria.credenciais_validas; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.credenciais_validas IS 'Indica se as credenciais estÃ£o vÃ¡lidas';


--
-- Name: COLUMN configuracao_bancaria.conectividade_ok; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_bancaria.conectividade_ok IS 'Indica se a conectividade com o banco estÃ¡ OK';


--
-- Name: configuracao_fiscal; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.configuracao_fiscal (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome_configuracao character varying(100) NOT NULL,
    uf character varying(2) NOT NULL,
    tipo_documento character varying(10) NOT NULL,
    ambiente character varying(20) NOT NULL,
    certificado_digital text,
    senha_certificado text,
    data_validade_certificado date,
    webservice_url character varying(500) NOT NULL,
    versao_layout character varying(10) DEFAULT '4.00'::character varying NOT NULL,
    serie_numeracao integer DEFAULT 1 NOT NULL,
    numero_inicial integer DEFAULT 1 NOT NULL,
    numero_final integer,
    configuracao_uf jsonb DEFAULT '{}'::jsonb,
    certificado_valido boolean DEFAULT false,
    conectividade_ok boolean DEFAULT false,
    ultima_validacao timestamp with time zone,
    erro_validacao text,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT configuracao_fiscal_ambiente_check CHECK (((ambiente)::text = ANY ((ARRAY['producao'::character varying, 'homologacao'::character varying])::text[]))),
    CONSTRAINT configuracao_fiscal_tipo_documento_check CHECK (((tipo_documento)::text = ANY ((ARRAY['nfe'::character varying, 'nfse'::character varying, 'mdfe'::character varying, 'cte'::character varying])::text[])))
);


ALTER TABLE financeiro.configuracao_fiscal OWNER TO postgres;

--
-- Name: TABLE configuracao_fiscal; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.configuracao_fiscal IS 'ConfiguraÃ§Ãµes de integraÃ§Ã£o SEFAZ por empresa, UF e tipo de documento';


--
-- Name: COLUMN configuracao_fiscal.certificado_digital; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_fiscal.certificado_digital IS 'Certificado digital em formato base64';


--
-- Name: COLUMN configuracao_fiscal.senha_certificado; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_fiscal.senha_certificado IS 'Senha do certificado digital (criptografada)';


--
-- Name: COLUMN configuracao_fiscal.configuracao_uf; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_fiscal.configuracao_uf IS 'ConfiguraÃ§Ãµes especÃ­ficas por UF (JSON)';


--
-- Name: COLUMN configuracao_fiscal.certificado_valido; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_fiscal.certificado_valido IS 'Indica se o certificado estÃ¡ vÃ¡lido';


--
-- Name: COLUMN configuracao_fiscal.conectividade_ok; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON COLUMN financeiro.configuracao_fiscal.conectividade_ok IS 'Indica se a conectividade com SEFAZ estÃ¡ OK';


--
-- Name: configuracoes_aprovacao; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.configuracoes_aprovacao (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    tipo_aprovacao character varying(50) NOT NULL,
    valor_limite numeric(15,2) NOT NULL,
    centro_custo_id uuid,
    departamento character varying(100),
    classe_financeira character varying(100),
    usuario_id uuid,
    nivel_aprovacao integer DEFAULT 1 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE financeiro.configuracoes_aprovacao OWNER TO postgres;

--
-- Name: TABLE configuracoes_aprovacao; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.configuracoes_aprovacao IS 'ConfiguraÃ§Ãµes de aprovaÃ§Ã£o por valor/centro de custo/departamento/classe/usuÃ¡rio';


--
-- Name: contas_bancarias; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.contas_bancarias (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    banco_codigo character varying(10) NOT NULL,
    banco_nome character varying(100) NOT NULL,
    agencia character varying(10) NOT NULL,
    conta character varying(20) NOT NULL,
    tipo_conta character varying(20) NOT NULL,
    moeda character varying(3) DEFAULT 'BRL'::character varying,
    saldo_atual numeric(15,2) DEFAULT 0,
    saldo_disponivel numeric(15,2) DEFAULT 0,
    limite_credito numeric(15,2) DEFAULT 0,
    data_saldo date,
    is_active boolean DEFAULT true NOT NULL,
    observacoes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT contas_bancarias_tipo_conta_check CHECK (((tipo_conta)::text = ANY ((ARRAY['corrente'::character varying, 'poupanca'::character varying, 'investimento'::character varying])::text[])))
);


ALTER TABLE financeiro.contas_bancarias OWNER TO postgres;

--
-- Name: TABLE contas_bancarias; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.contas_bancarias IS 'Contas bancÃ¡rias da empresa';


--
-- Name: contas_pagar; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.contas_pagar (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    numero_titulo character varying(50) NOT NULL,
    fornecedor_id uuid,
    fornecedor_nome character varying(255),
    fornecedor_cnpj character varying(18),
    descricao text NOT NULL,
    valor_original numeric(15,2) NOT NULL,
    valor_atual numeric(15,2) NOT NULL,
    data_emissao date NOT NULL,
    data_vencimento date NOT NULL,
    data_pagamento date,
    centro_custo_id uuid,
    projeto_id uuid,
    departamento character varying(100),
    classe_financeira character varying(100),
    categoria character varying(100),
    status character varying(20) DEFAULT 'pendente'::character varying,
    forma_pagamento character varying(50),
    conta_bancaria_id uuid,
    observacoes text,
    anexos text[],
    valor_desconto numeric(15,2) DEFAULT 0,
    valor_juros numeric(15,2) DEFAULT 0,
    valor_multa numeric(15,2) DEFAULT 0,
    valor_pago numeric(15,2) DEFAULT 0,
    data_aprovacao timestamp with time zone,
    aprovado_por uuid,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT contas_pagar_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'pago'::character varying, 'vencido'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE financeiro.contas_pagar OWNER TO postgres;

--
-- Name: TABLE contas_pagar; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.contas_pagar IS 'Contas a pagar da empresa';


--
-- Name: contas_receber; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.contas_receber (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    numero_titulo character varying(50) NOT NULL,
    cliente_id uuid,
    cliente_nome character varying(255),
    cliente_cnpj character varying(18),
    descricao text NOT NULL,
    valor_original numeric(15,2) NOT NULL,
    valor_atual numeric(15,2) NOT NULL,
    data_emissao date NOT NULL,
    data_vencimento date NOT NULL,
    data_recebimento date,
    centro_custo_id uuid,
    projeto_id uuid,
    departamento character varying(100),
    classe_financeira character varying(100),
    categoria character varying(100),
    status character varying(20) DEFAULT 'pendente'::character varying,
    forma_recebimento character varying(50),
    conta_bancaria_id uuid,
    observacoes text,
    anexos text[],
    valor_desconto numeric(15,2) DEFAULT 0,
    valor_juros numeric(15,2) DEFAULT 0,
    valor_multa numeric(15,2) DEFAULT 0,
    valor_recebido numeric(15,2) DEFAULT 0,
    data_confirmacao timestamp with time zone,
    confirmado_por uuid,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT contas_receber_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'confirmado'::character varying, 'recebido'::character varying, 'vencido'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE financeiro.contas_receber OWNER TO postgres;

--
-- Name: TABLE contas_receber; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.contas_receber IS 'Contas a receber da empresa';


--
-- Name: fluxo_caixa; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.fluxo_caixa (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    data_projecao date NOT NULL,
    tipo_movimento character varying(20) NOT NULL,
    categoria character varying(100) NOT NULL,
    descricao text NOT NULL,
    valor numeric(15,2) NOT NULL,
    conta_bancaria_id uuid,
    centro_custo_id uuid,
    projeto_id uuid,
    status character varying(20) DEFAULT 'previsto'::character varying,
    data_confirmacao date,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT fluxo_caixa_status_check CHECK (((status)::text = ANY ((ARRAY['previsto'::character varying, 'confirmado'::character varying, 'realizado'::character varying])::text[]))),
    CONSTRAINT fluxo_caixa_tipo_movimento_check CHECK (((tipo_movimento)::text = ANY ((ARRAY['entrada'::character varying, 'saida'::character varying])::text[])))
);


ALTER TABLE financeiro.fluxo_caixa OWNER TO postgres;

--
-- Name: TABLE fluxo_caixa; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.fluxo_caixa IS 'Fluxo de caixa e projeÃ§Ãµes';


--
-- Name: lancamentos_contabeis; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.lancamentos_contabeis (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    data_lancamento date NOT NULL,
    conta_debito_id uuid NOT NULL,
    conta_credito_id uuid NOT NULL,
    valor numeric(15,2) NOT NULL,
    historico text NOT NULL,
    documento character varying(50),
    centro_custo_id uuid,
    projeto_id uuid,
    tipo_lancamento character varying(20) DEFAULT 'manual'::character varying,
    origem_id uuid,
    origem_tipo character varying(50),
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT lancamentos_contabeis_tipo_lancamento_check CHECK (((tipo_lancamento)::text = ANY ((ARRAY['manual'::character varying, 'automatico'::character varying, 'importado'::character varying])::text[])))
);


ALTER TABLE financeiro.lancamentos_contabeis OWNER TO postgres;

--
-- Name: TABLE lancamentos_contabeis; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.lancamentos_contabeis IS 'LanÃ§amentos contÃ¡beis';


--
-- Name: log_validacao_integracao; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.log_validacao_integracao (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    tipo_integracao character varying(20) NOT NULL,
    configuracao_id uuid NOT NULL,
    status character varying(20) NOT NULL,
    mensagem text,
    detalhes jsonb DEFAULT '{}'::jsonb,
    tempo_resposta_ms integer,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT log_validacao_integracao_status_check CHECK (((status)::text = ANY ((ARRAY['sucesso'::character varying, 'erro'::character varying, 'aviso'::character varying])::text[]))),
    CONSTRAINT log_validacao_integracao_tipo_integracao_check CHECK (((tipo_integracao)::text = ANY ((ARRAY['sefaz'::character varying, 'bancaria'::character varying])::text[])))
);


ALTER TABLE financeiro.log_validacao_integracao OWNER TO postgres;

--
-- Name: TABLE log_validacao_integracao; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.log_validacao_integracao IS 'Log de validaÃ§Ãµes de integraÃ§Ãµes SEFAZ e bancÃ¡rias';


--
-- Name: nfe; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.nfe (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    chave_acesso character varying(44) NOT NULL,
    numero_nfe character varying(20) NOT NULL,
    serie character varying(5) NOT NULL,
    data_emissao date NOT NULL,
    data_saida date,
    valor_total numeric(15,2) NOT NULL,
    valor_icms numeric(15,2) DEFAULT 0,
    valor_ipi numeric(15,2) DEFAULT 0,
    valor_pis numeric(15,2) DEFAULT 0,
    valor_cofins numeric(15,2) DEFAULT 0,
    status_sefaz character varying(20) DEFAULT 'pendente'::character varying,
    xml_nfe text,
    danfe_url text,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT nfe_status_sefaz_check CHECK (((status_sefaz)::text = ANY ((ARRAY['pendente'::character varying, 'autorizada'::character varying, 'rejeitada'::character varying, 'cancelada'::character varying, 'inutilizada'::character varying])::text[])))
);


ALTER TABLE financeiro.nfe OWNER TO postgres;

--
-- Name: TABLE nfe; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.nfe IS 'Notas Fiscais EletrÃ´nicas';


--
-- Name: nfse; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.nfse (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    numero_nfse character varying(20) NOT NULL,
    codigo_verificacao character varying(50),
    data_emissao date NOT NULL,
    data_competencia date NOT NULL,
    valor_servico numeric(15,2) NOT NULL,
    valor_iss numeric(15,2) DEFAULT 0,
    valor_pis numeric(15,2) DEFAULT 0,
    valor_cofins numeric(15,2) DEFAULT 0,
    valor_csll numeric(15,2) DEFAULT 0,
    valor_ir numeric(15,2) DEFAULT 0,
    status_sefaz character varying(20) DEFAULT 'pendente'::character varying,
    xml_nfse text,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT nfse_status_sefaz_check CHECK (((status_sefaz)::text = ANY ((ARRAY['pendente'::character varying, 'autorizada'::character varying, 'rejeitada'::character varying, 'cancelada'::character varying])::text[])))
);


ALTER TABLE financeiro.nfse OWNER TO postgres;

--
-- Name: TABLE nfse; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.nfse IS 'Notas Fiscais de ServiÃ§os EletrÃ´nicas';


--
-- Name: plano_contas; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.plano_contas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    descricao character varying(255) NOT NULL,
    tipo_conta character varying(20) NOT NULL,
    nivel integer DEFAULT 1 NOT NULL,
    conta_pai_id uuid,
    is_active boolean DEFAULT true NOT NULL,
    observacoes text,
    created_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT plano_contas_tipo_conta_check CHECK (((tipo_conta)::text = ANY ((ARRAY['ativo'::character varying, 'passivo'::character varying, 'patrimonio'::character varying, 'receita'::character varying, 'despesa'::character varying])::text[])))
);


ALTER TABLE financeiro.plano_contas OWNER TO postgres;

--
-- Name: TABLE plano_contas; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.plano_contas IS 'Plano de contas contÃ¡bil';


--
-- Name: remessas_bancarias; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.remessas_bancarias (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    borderos_id uuid,
    numero_remessa character varying(50) NOT NULL,
    data_remessa date NOT NULL,
    banco_codigo character varying(10) NOT NULL,
    agencia character varying(10),
    conta character varying(20),
    arquivo_cnab text,
    status character varying(20) DEFAULT 'enviada'::character varying,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT remessas_bancarias_status_check CHECK (((status)::text = ANY ((ARRAY['enviada'::character varying, 'processada'::character varying, 'retornada'::character varying])::text[])))
);


ALTER TABLE financeiro.remessas_bancarias OWNER TO postgres;

--
-- Name: TABLE remessas_bancarias; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.remessas_bancarias IS 'Remessas bancÃ¡rias (CNAB)';


--
-- Name: retornos_bancarios; Type: TABLE; Schema: financeiro; Owner: postgres
--

CREATE TABLE financeiro.retornos_bancarios (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    remessa_id uuid,
    numero_retorno character varying(50) NOT NULL,
    data_retorno date NOT NULL,
    banco_codigo character varying(10) NOT NULL,
    arquivo_retorno text,
    status character varying(20) DEFAULT 'processado'::character varying,
    observacoes text,
    created_by uuid,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT retornos_bancarios_status_check CHECK (((status)::text = ANY ((ARRAY['processado'::character varying, 'erro'::character varying, 'pendente'::character varying])::text[])))
);


ALTER TABLE financeiro.retornos_bancarios OWNER TO postgres;

--
-- Name: TABLE retornos_bancarios; Type: COMMENT; Schema: financeiro; Owner: postgres
--

COMMENT ON TABLE financeiro.retornos_bancarios IS 'Retornos bancÃ¡rios (CNAB)';


--
-- Name: aprovacoes_unificada; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.aprovacoes_unificada (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    processo_tipo character varying(50) NOT NULL,
    processo_id uuid NOT NULL,
    nivel_aprovacao integer NOT NULL,
    aprovador_id uuid NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    data_aprovacao timestamp with time zone,
    observacoes text,
    aprovador_original_id uuid,
    transferido_em timestamp with time zone,
    transferido_por uuid,
    motivo_transferencia text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT aprovacoes_unificada_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE public.aprovacoes_unificada OWNER TO postgres;

--
-- Name: TABLE aprovacoes_unificada; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.aprovacoes_unificada IS 'Workflow unificado de aprovaÃ§Ãµes com transferÃªncias';


--
-- Name: COLUMN aprovacoes_unificada.aprovador_original_id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.aprovacoes_unificada.aprovador_original_id IS 'UsuÃ¡rio original designado para aprovaÃ§Ã£o';


--
-- Name: COLUMN aprovacoes_unificada.transferido_em; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.aprovacoes_unificada.transferido_em IS 'Data/hora da transferÃªncia';


--
-- Name: COLUMN aprovacoes_unificada.transferido_por; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.aprovacoes_unificada.transferido_por IS 'UsuÃ¡rio que fez a transferÃªncia';


--
-- Name: companies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    razao_social text NOT NULL,
    nome_fantasia text NOT NULL,
    cnpj text NOT NULL,
    inscricao_estadual text,
    endereco jsonb,
    contato jsonb,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    numero_empresa character varying(10)
);


ALTER TABLE public.companies OWNER TO postgres;

--
-- Name: TABLE companies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.companies IS 'Tabela de empresas';


--
-- Name: COLUMN companies.razao_social; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.razao_social IS 'Razão social da empresa';


--
-- Name: COLUMN companies.nome_fantasia; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.nome_fantasia IS 'Nome fantasia da empresa';


--
-- Name: COLUMN companies.cnpj; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.cnpj IS 'CNPJ da empresa';


--
-- Name: COLUMN companies.inscricao_estadual; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.inscricao_estadual IS 'Inscrição estadual da empresa';


--
-- Name: COLUMN companies.endereco; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.endereco IS 'Dados de endereço da empresa (JSON)';


--
-- Name: COLUMN companies.contato; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.contato IS 'Dados de contato da empresa (JSON)';


--
-- Name: COLUMN companies.ativo; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.ativo IS 'Se a empresa está ativa';


--
-- Name: company_number_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.company_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.company_number_seq OWNER TO postgres;

--
-- Name: configuracoes_aprovacao_unificada; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.configuracoes_aprovacao_unificada (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    processo_tipo character varying(50) NOT NULL,
    centro_custo_id uuid,
    departamento character varying(100),
    classe_financeira character varying(100),
    usuario_id uuid,
    valor_limite numeric(15,2),
    nivel_aprovacao integer DEFAULT 1 NOT NULL,
    aprovadores jsonb NOT NULL,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    CONSTRAINT configuracoes_aprovacao_unificada_processo_tipo_check CHECK (((processo_tipo)::text = ANY ((ARRAY['conta_pagar'::character varying, 'requisicao_compra'::character varying, 'cotacao_compra'::character varying, 'solicitacao_saida_material'::character varying, 'solicitacao_transferencia_material'::character varying])::text[])))
);


ALTER TABLE public.configuracoes_aprovacao_unificada OWNER TO postgres;

--
-- Name: TABLE configuracoes_aprovacao_unificada; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.configuracoes_aprovacao_unificada IS 'ConfiguraÃ§Ãµes flexÃ­veis de aprovaÃ§Ã£o por processo';


--
-- Name: COLUMN configuracoes_aprovacao_unificada.aprovadores; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.configuracoes_aprovacao_unificada.aprovadores IS 'Array de aprovadores: [{"user_id": "uuid", "is_primary": true, "ordem": 1}]';


--
-- Name: cost_centers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cost_centers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid,
    nome text NOT NULL,
    codigo text NOT NULL,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.cost_centers OWNER TO postgres;

--
-- Name: entity_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.entity_permissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    entity_name text NOT NULL,
    can_read boolean DEFAULT false,
    can_create boolean DEFAULT false,
    can_edit boolean DEFAULT false,
    can_delete boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.entity_permissions OWNER TO postgres;

--
-- Name: TABLE entity_permissions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.entity_permissions IS 'PermissÃµes por entidade - incluindo periodic_exams';


--
-- Name: historico_edicoes_solicitacoes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.historico_edicoes_solicitacoes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    processo_tipo character varying(50) NOT NULL,
    processo_id uuid NOT NULL,
    usuario_editor_id uuid NOT NULL,
    data_edicao timestamp with time zone DEFAULT now(),
    campos_alterados jsonb,
    valores_anteriores jsonb,
    valores_novos jsonb,
    aprovacoes_resetadas boolean DEFAULT false,
    data_reset timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.historico_edicoes_solicitacoes OWNER TO postgres;

--
-- Name: TABLE historico_edicoes_solicitacoes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.historico_edicoes_solicitacoes IS 'HistÃ³rico de ediÃ§Ãµes para reset automÃ¡tico de aprovaÃ§Ãµes';


--
-- Name: COLUMN historico_edicoes_solicitacoes.campos_alterados; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.historico_edicoes_solicitacoes.campos_alterados IS 'Array de nomes dos campos alterados';


--
-- Name: COLUMN historico_edicoes_solicitacoes.valores_anteriores; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.historico_edicoes_solicitacoes.valores_anteriores IS 'Valores antes da alteraÃ§Ã£o';


--
-- Name: COLUMN historico_edicoes_solicitacoes.valores_novos; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.historico_edicoes_solicitacoes.valores_novos IS 'Valores apÃ³s a alteraÃ§Ã£o';


--
-- Name: module_permissions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.module_permissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    module_name text NOT NULL,
    can_read boolean DEFAULT false,
    can_create boolean DEFAULT false,
    can_edit boolean DEFAULT false,
    can_delete boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.module_permissions OWNER TO postgres;

--
-- Name: TABLE module_permissions; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.module_permissions IS 'PermissÃµes por mÃ³dulo - incluindo RH';


--
-- Name: notifications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    company_id uuid NOT NULL,
    type character varying(50) NOT NULL,
    title character varying(255) NOT NULL,
    message text NOT NULL,
    data jsonb,
    is_read boolean DEFAULT false,
    read_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT notifications_type_check CHECK (((type)::text = ANY ((ARRAY['compensation_request'::character varying, 'compensation_approved'::character varying, 'compensation_rejected'::character varying, 'compensation_reminder'::character varying, 'vacation_request'::character varying, 'vacation_approved'::character varying, 'vacation_rejected'::character varying, 'medical_certificate'::character varying, 'payroll_processed'::character varying, 'system_alert'::character varying])::text[])))
);


ALTER TABLE public.notifications OWNER TO postgres;

--
-- Name: TABLE notifications; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.notifications IS 'Tabela de notificaÃ§Ãµes do sistema';


--
-- Name: COLUMN notifications.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.notifications.type IS 'Tipo da notificaÃ§Ã£o: compensation_request, compensation_approved, etc.';


--
-- Name: COLUMN notifications.data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.notifications.data IS 'Dados adicionais da notificaÃ§Ã£o em formato JSON';


--
-- Name: COLUMN notifications.is_read; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.notifications.is_read IS 'Indica se a notificaÃ§Ã£o foi lida pelo usuÃ¡rio';


--
-- Name: profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profiles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    nome text NOT NULL,
    descricao text,
    permissoes jsonb DEFAULT '{}'::jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    is_active boolean DEFAULT true
);


ALTER TABLE public.profiles OWNER TO postgres;

--
-- Name: projects; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.projects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid,
    cost_center_id uuid,
    nome text NOT NULL,
    codigo text NOT NULL,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.projects OWNER TO postgres;

--
-- Name: user_companies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_companies (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid,
    company_id uuid,
    profile_id uuid,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.user_companies OWNER TO postgres;

--
-- Name: users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.users (
    id uuid NOT NULL,
    nome text NOT NULL,
    email text NOT NULL,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    company_id uuid
);


ALTER TABLE public.users OWNER TO postgres;

--
-- Name: messages; Type: TABLE; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE TABLE realtime.messages (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
)
PARTITION BY RANGE (inserted_at);


ALTER TABLE realtime.messages OWNER TO supabase_realtime_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


ALTER TABLE realtime.schema_migrations OWNER TO supabase_admin;

--
-- Name: subscription; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.subscription (
    id bigint NOT NULL,
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] DEFAULT '{}'::realtime.user_defined_filter[] NOT NULL,
    claims jsonb NOT NULL,
    claims_role regrole GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED NOT NULL,
    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE realtime.subscription OWNER TO supabase_admin;

--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE realtime.subscription ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME realtime.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: absence_types; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.absence_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    tipo character varying(50) NOT NULL,
    maximo_dias integer,
    remunerado boolean DEFAULT false,
    desconta_salario boolean DEFAULT false,
    desconta_ferias boolean DEFAULT false,
    desconta_13_salario boolean DEFAULT false,
    requer_anexo boolean DEFAULT false,
    requer_aprovacao boolean DEFAULT false,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT absence_types_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['ferias'::character varying, 'licenca_medica'::character varying, 'licenca_maternidade'::character varying, 'licenca_paternidade'::character varying, 'licenca_casamento'::character varying, 'licenca_luto'::character varying, 'afastamento_medico'::character varying, 'suspensao'::character varying, 'afastamento_sem_vencimento'::character varying])::text[]))),
    CONSTRAINT check_absence_type_maximo_dias CHECK (((maximo_dias IS NULL) OR (maximo_dias > 0)))
);


ALTER TABLE rh.absence_types OWNER TO postgres;

--
-- Name: TABLE absence_types; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.absence_types IS 'Tabela de tipos de afastamento e licen??as';


--
-- Name: COLUMN absence_types.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.tipo IS 'Tipo do afastamento: ferias, licenca_medica, licenca_maternidade, etc.';


--
-- Name: COLUMN absence_types.maximo_dias; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.maximo_dias IS 'N??mero m??ximo de dias permitidos para este tipo de afastamento';


--
-- Name: COLUMN absence_types.remunerado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.remunerado IS 'Se o afastamento ?? remunerado';


--
-- Name: COLUMN absence_types.desconta_salario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.desconta_salario IS 'Se desconta do sal??rio mensal';


--
-- Name: COLUMN absence_types.desconta_ferias; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.desconta_ferias IS 'Se desconta do per??odo de f??rias';


--
-- Name: COLUMN absence_types.requer_aprovacao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.absence_types.requer_aprovacao IS 'Se requer aprova????o pr??via';


--
-- Name: allowance_types; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.allowance_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    codigo character varying(50),
    descricao text,
    tipo character varying(50) NOT NULL,
    calculo_automatico boolean DEFAULT false,
    percentual_base numeric(5,4),
    valor_fixo numeric(10,2),
    incidencia_ferias boolean DEFAULT true,
    incidencia_13_salario boolean DEFAULT true,
    incidencia_aviso_previo boolean DEFAULT true,
    incidencia_fgts boolean DEFAULT true,
    incidencia_inss boolean DEFAULT true,
    incidencia_ir boolean DEFAULT true,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT allowance_types_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['adicional'::character varying, 'bonus'::character varying, 'comissao'::character varying, 'gratificacao'::character varying, 'horas_extras'::character varying, 'adicional_noturno'::character varying, 'adicional_periculosidade'::character varying, 'adicional_insalubridade'::character varying])::text[]))),
    CONSTRAINT check_allowance_type_valor_percentual CHECK ((((percentual_base IS NOT NULL) AND (valor_fixo IS NULL)) OR ((percentual_base IS NULL) AND (valor_fixo IS NOT NULL)) OR ((percentual_base IS NULL) AND (valor_fixo IS NULL))))
);


ALTER TABLE rh.allowance_types OWNER TO postgres;

--
-- Name: TABLE allowance_types; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.allowance_types IS 'Tabela de tipos de adicionais salariais';


--
-- Name: COLUMN allowance_types.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.allowance_types.tipo IS 'Tipo do adicional: adicional, bonus, comissao, gratificacao, horas_extras, etc.';


--
-- Name: COLUMN allowance_types.percentual_base; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.allowance_types.percentual_base IS 'Percentual sobre a base de c??lculo';


--
-- Name: COLUMN allowance_types.incidencia_ferias; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.allowance_types.incidencia_ferias IS 'Se o adicional incide no c??lculo de f??rias';


--
-- Name: COLUMN allowance_types.incidencia_13_salario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.allowance_types.incidencia_13_salario IS 'Se o adicional incide no 13?? sal??rio';


--
-- Name: approval_level_approvers; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.approval_level_approvers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    approval_level_id uuid NOT NULL,
    user_id uuid NOT NULL,
    is_primary boolean DEFAULT false,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.approval_level_approvers OWNER TO postgres;

--
-- Name: TABLE approval_level_approvers; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.approval_level_approvers IS 'Aprovadores por nÃ­vel de aprovaÃ§Ã£o';


--
-- Name: approval_levels; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.approval_levels (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    name character varying(100) NOT NULL,
    level_order integer NOT NULL,
    required_approvals integer DEFAULT 1,
    max_amount numeric(10,2),
    max_hours numeric(5,2),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.approval_levels OWNER TO postgres;

--
-- Name: TABLE approval_levels; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.approval_levels IS 'NÃ­veis de aprovaÃ§Ã£o hierÃ¡rquica para compensaÃ§Ãµes';


--
-- Name: attendance_corrections; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.attendance_corrections (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    data_original date NOT NULL,
    entrada_original time without time zone,
    saida_original time without time zone,
    entrada_corrigida time without time zone,
    saida_corrigida time without time zone,
    justificativa text NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    solicitado_por uuid,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT attendance_corrections_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE rh.attendance_corrections OWNER TO postgres;

--
-- Name: audit_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.audit_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    entity_type character varying(50) NOT NULL,
    is_enabled boolean DEFAULT true,
    log_level character varying(20) DEFAULT 'all'::character varying,
    retention_days integer DEFAULT 2555,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT audit_config_log_level_check CHECK (((log_level)::text = ANY ((ARRAY['all'::character varying, 'changes'::character varying, 'critical'::character varying])::text[])))
);


ALTER TABLE rh.audit_config OWNER TO postgres;

--
-- Name: TABLE audit_config; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.audit_config IS 'ConfiguraÃ§Ãµes de auditoria por empresa e entidade';


--
-- Name: audit_logs; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.audit_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    user_id uuid,
    action character varying(50) NOT NULL,
    entity_type character varying(50) NOT NULL,
    entity_id uuid NOT NULL,
    old_values jsonb,
    new_values jsonb,
    ip_address inet,
    user_agent text,
    session_id character varying(255),
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.audit_logs OWNER TO postgres;

--
-- Name: TABLE audit_logs; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.audit_logs IS 'Log de auditoria para todas as aÃ§Ãµes do sistema';


--
-- Name: bank_hours_balance; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.bank_hours_balance (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    current_balance numeric(6,2) DEFAULT 0.00,
    accumulated_hours numeric(6,2) DEFAULT 0.00,
    compensated_hours numeric(6,2) DEFAULT 0.00,
    expired_hours numeric(6,2) DEFAULT 0.00,
    last_calculation_date date DEFAULT CURRENT_DATE NOT NULL,
    next_expiration_date date,
    is_locked boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.bank_hours_balance OWNER TO postgres;

--
-- Name: bank_hours_calculations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.bank_hours_calculations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    calculation_date date NOT NULL,
    period_start date NOT NULL,
    period_end date NOT NULL,
    employees_processed integer DEFAULT 0,
    hours_accumulated numeric(8,2) DEFAULT 0.00,
    hours_compensated numeric(8,2) DEFAULT 0.00,
    hours_expired numeric(8,2) DEFAULT 0.00,
    status character varying(20) DEFAULT 'completed'::character varying,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    CONSTRAINT bank_hours_calculations_status_check CHECK (((status)::text = ANY ((ARRAY['running'::character varying, 'completed'::character varying, 'failed'::character varying, 'cancelled'::character varying])::text[])))
);


ALTER TABLE rh.bank_hours_calculations OWNER TO postgres;

--
-- Name: bank_hours_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.bank_hours_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    has_bank_hours boolean DEFAULT false NOT NULL,
    accumulation_period_months integer DEFAULT 12 NOT NULL,
    max_accumulation_hours numeric(5,2) DEFAULT 40.00,
    compensation_rate numeric(4,2) DEFAULT 1.00,
    auto_compensate boolean DEFAULT false,
    compensation_priority character varying(20) DEFAULT 'fifo'::character varying,
    expires_after_months integer DEFAULT 12,
    allow_negative_balance boolean DEFAULT false,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT bank_hours_config_compensation_priority_check CHECK (((compensation_priority)::text = ANY ((ARRAY['fifo'::character varying, 'lifo'::character varying, 'manual'::character varying])::text[])))
);


ALTER TABLE rh.bank_hours_config OWNER TO postgres;

--
-- Name: bank_hours_transactions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.bank_hours_transactions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    transaction_type character varying(20) NOT NULL,
    transaction_date date NOT NULL,
    hours_amount numeric(5,2) NOT NULL,
    time_record_id uuid,
    reference_period_start date,
    reference_period_end date,
    description text,
    compensation_rate numeric(4,2) DEFAULT 1.00,
    is_automatic boolean DEFAULT false,
    created_by uuid,
    approved_by uuid,
    approved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT bank_hours_transactions_transaction_type_check CHECK (((transaction_type)::text = ANY ((ARRAY['accumulation'::character varying, 'compensation'::character varying, 'expiration'::character varying, 'adjustment'::character varying, 'transfer'::character varying])::text[])))
);


ALTER TABLE rh.bank_hours_transactions OWNER TO postgres;

--
-- Name: benefit_configurations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.benefit_configurations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    benefit_type character varying(50) NOT NULL,
    name character varying(255) NOT NULL,
    description text,
    calculation_type character varying(50) NOT NULL,
    base_value numeric(10,2),
    percentage_value numeric(5,2),
    min_value numeric(10,2),
    max_value numeric(10,2),
    daily_calculation_base integer DEFAULT 30,
    requires_approval boolean DEFAULT false,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    entra_no_calculo_folha boolean DEFAULT true NOT NULL,
    CONSTRAINT benefit_configurations_benefit_type_check CHECK (((benefit_type)::text = ANY ((ARRAY['vr_va'::character varying, 'transporte'::character varying, 'equipment_rental'::character varying, 'premiacao'::character varying, 'outros'::character varying])::text[]))),
    CONSTRAINT benefit_configurations_calculation_type_check CHECK (((calculation_type)::text = ANY ((ARRAY['fixed_value'::character varying, 'daily_value'::character varying, 'percentage'::character varying, 'work_days'::character varying])::text[])))
);


ALTER TABLE rh.benefit_configurations OWNER TO postgres;

--
-- Name: COLUMN benefit_configurations.entra_no_calculo_folha; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.benefit_configurations.entra_no_calculo_folha IS 'Se o benefÃ­cio deve ser incluÃ­do no cÃ¡lculo da folha de pagamento';


--
-- Name: calculation_logs; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.calculation_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    processo_id uuid NOT NULL,
    tipo_processo character varying(50) NOT NULL,
    descricao_processo character varying(255),
    mes_referencia integer NOT NULL,
    ano_referencia integer NOT NULL,
    status character varying(20) DEFAULT 'iniciado'::character varying NOT NULL,
    progresso integer DEFAULT 0,
    total_funcionarios integer DEFAULT 0,
    funcionarios_processados integer DEFAULT 0,
    eventos_calculados integer DEFAULT 0,
    erros_encontrados integer DEFAULT 0,
    inicio_processamento timestamp with time zone,
    fim_processamento timestamp with time zone,
    tempo_execucao_segundos integer,
    usuario_id uuid,
    usuario_nome character varying(255),
    logs_execucao jsonb,
    erros_execucao jsonb,
    resumo_calculos jsonb,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT calculation_logs_ano_referencia_check CHECK (((ano_referencia >= 2000) AND (ano_referencia <= 2100))),
    CONSTRAINT calculation_logs_mes_referencia_check CHECK (((mes_referencia >= 1) AND (mes_referencia <= 12))),
    CONSTRAINT calculation_logs_progresso_check CHECK (((progresso >= 0) AND (progresso <= 100))),
    CONSTRAINT calculation_logs_status_check CHECK (((status)::text = ANY ((ARRAY['iniciado'::character varying, 'processando'::character varying, 'concluido'::character varying, 'erro'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE rh.calculation_logs OWNER TO postgres;

--
-- Name: TABLE calculation_logs; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.calculation_logs IS 'Logs de execuÃ§Ã£o do motor de cÃ¡lculo de folha';


--
-- Name: COLUMN calculation_logs.processo_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.processo_id IS 'ID Ãºnico do processo de cÃ¡lculo';


--
-- Name: COLUMN calculation_logs.tipo_processo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.tipo_processo IS 'Tipo: folha_mensal, recalculo, ajuste, simulacao';


--
-- Name: COLUMN calculation_logs.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.status IS 'Status: iniciado, processando, concluido, erro, cancelado';


--
-- Name: COLUMN calculation_logs.progresso; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.progresso IS 'Progresso em percentual (0-100)';


--
-- Name: COLUMN calculation_logs.logs_execucao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.logs_execucao IS 'Logs detalhados da execuÃ§Ã£o em JSON';


--
-- Name: COLUMN calculation_logs.erros_execucao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.erros_execucao IS 'Erros encontrados durante a execuÃ§Ã£o';


--
-- Name: COLUMN calculation_logs.resumo_calculos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.calculation_logs.resumo_calculos IS 'Resumo dos cÃ¡lculos realizados';


--
-- Name: candidate_documents; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.candidate_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    candidate_id uuid NOT NULL,
    document_type character varying(50) NOT NULL,
    file_name character varying(255) NOT NULL,
    file_path character varying(500) NOT NULL,
    file_size integer,
    mime_type character varying(100),
    uploaded_by uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT candidate_documents_document_type_check CHECK (((document_type)::text = ANY ((ARRAY['curriculo'::character varying, 'carteira_identidade'::character varying, 'cpf'::character varying, 'comprovante_residencia'::character varying, 'certificado'::character varying, 'outro'::character varying])::text[])))
);


ALTER TABLE rh.candidate_documents OWNER TO postgres;

--
-- Name: candidates; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.candidates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    name character varying(255) NOT NULL,
    email character varying(255) NOT NULL,
    phone character varying(20),
    cpf character varying(14),
    birth_date date,
    address text,
    city character varying(100),
    state character varying(2),
    zip_code character varying(10),
    linkedin_url character varying(500),
    portfolio_url character varying(500),
    source character varying(20) DEFAULT 'site'::character varying,
    status character varying(20) DEFAULT 'ativo'::character varying,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT candidates_source_check CHECK (((source)::text = ANY ((ARRAY['site'::character varying, 'linkedin'::character varying, 'indicacao'::character varying, 'agencia'::character varying, 'outro'::character varying])::text[]))),
    CONSTRAINT candidates_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying, 'contratado'::character varying, 'descartado'::character varying])::text[])))
);


ALTER TABLE rh.candidates OWNER TO postgres;

--
-- Name: cid_codes; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.cid_codes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(10) NOT NULL,
    descricao character varying(500) NOT NULL,
    categoria character varying(100),
    subcategoria character varying(100),
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_cid_code_format CHECK (((codigo)::text ~ '^[A-Z][0-9]{2}(\.[0-9])?$'::text))
);


ALTER TABLE rh.cid_codes OWNER TO postgres;

--
-- Name: TABLE cid_codes; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.cid_codes IS 'Tabela de c??digos CID (Classifica????o Internacional de Doen??as)';


--
-- Name: COLUMN cid_codes.codigo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.cid_codes.codigo IS 'C??digo CID (ex: F32.1, G43.9, etc.)';


--
-- Name: COLUMN cid_codes.descricao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.cid_codes.descricao IS 'Descri????o da doen??a/condi????o m??dica';


--
-- Name: COLUMN cid_codes.categoria; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.cid_codes.categoria IS 'Categoria da doen??a (ex: Mental, Neurol??gica, etc.)';


--
-- Name: COLUMN cid_codes.subcategoria; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.cid_codes.subcategoria IS 'Subcategoria da doen??a';


--
-- Name: collective_agreements; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.collective_agreements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    union_id uuid NOT NULL,
    tipo_documento character varying(50) NOT NULL,
    numero_documento character varying(100),
    titulo character varying(255) NOT NULL,
    descricao text,
    data_assinatura date NOT NULL,
    data_vigencia_inicio date NOT NULL,
    data_vigencia_fim date,
    status character varying(20) DEFAULT 'vigente'::character varying NOT NULL,
    valor_beneficios numeric(10,2),
    percentual_reajuste numeric(5,2),
    clausulas text,
    arquivo_url character varying(500),
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT collective_agreements_status_check CHECK (((status)::text = ANY ((ARRAY['vigente'::character varying, 'vencido'::character varying, 'suspenso'::character varying, 'cancelado'::character varying])::text[]))),
    CONSTRAINT collective_agreements_tipo_documento_check CHECK (((tipo_documento)::text = ANY ((ARRAY['convencao_coletiva'::character varying, 'acordo_coletivo'::character varying, 'acordo_individual'::character varying, 'dissidio'::character varying, 'norma_regulamentar'::character varying])::text[])))
);


ALTER TABLE rh.collective_agreements OWNER TO postgres;

--
-- Name: TABLE collective_agreements; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.collective_agreements IS 'Convenções coletivas e acordos sindicais';


--
-- Name: COLUMN collective_agreements.tipo_documento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.collective_agreements.tipo_documento IS 'Tipo: convencao_coletiva, acordo_coletivo, acordo_individual, dissidio, norma_regulamentar';


--
-- Name: compensation_approvals; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.compensation_approvals (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    compensation_request_id uuid NOT NULL,
    approval_level_id uuid NOT NULL,
    approver_id uuid NOT NULL,
    status character varying(20) NOT NULL,
    comments text,
    approved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT compensation_approvals_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying])::text[])))
);


ALTER TABLE rh.compensation_approvals OWNER TO postgres;

--
-- Name: TABLE compensation_approvals; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.compensation_approvals IS 'HistÃ³rico de aprovaÃ§Ãµes de compensaÃ§Ãµes';


--
-- Name: compensation_requests; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.compensation_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    tipo character varying(50) NOT NULL,
    data_solicitacao timestamp with time zone DEFAULT now(),
    data_inicio date NOT NULL,
    quantidade_horas numeric(5,2) NOT NULL,
    descricao text NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    data_fim date,
    valor_hora numeric(10,2),
    valor_total numeric(10,2),
    motivo_rejeicao text,
    anexos text[],
    CONSTRAINT compensation_requests_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'realizado'::character varying])::text[]))),
    CONSTRAINT compensation_requests_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['horas_extras'::character varying, 'banco_horas'::character varying, 'adicional_noturno'::character varying, 'adicional_periculosidade'::character varying, 'adicional_insalubridade'::character varying, 'dsr'::character varying, 'feriado'::character varying, 'outros'::character varying])::text[])))
);


ALTER TABLE rh.compensation_requests OWNER TO postgres;

--
-- Name: TABLE compensation_requests; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.compensation_requests IS 'Tabela de solicitaÃ§Ãµes de compensaÃ§Ã£o de horas - ESTRUTURA PADRONIZADA';


--
-- Name: COLUMN compensation_requests.employee_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.employee_id IS 'ID do funcionÃ¡rio que solicitou a compensaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.tipo IS 'Tipo de compensaÃ§Ã£o: horas_extras, banco_horas, adicional_noturno, etc.';


--
-- Name: COLUMN compensation_requests.data_inicio; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.data_inicio IS 'Data de inÃ­cio da compensaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.quantidade_horas; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.quantidade_horas IS 'Quantidade de horas solicitadas para compensaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.descricao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.descricao IS 'DescriÃ§Ã£o/justificativa da solicitaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.status IS 'Status: pendente, aprovado, rejeitado, realizado';


--
-- Name: COLUMN compensation_requests.aprovado_por; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.aprovado_por IS 'UsuÃ¡rio que aprovou/rejeitou a solicitaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.data_fim; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.data_fim IS 'Data de fim da compensaÃ§Ã£o';


--
-- Name: COLUMN compensation_requests.valor_hora; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.valor_hora IS 'Valor da hora (opcional)';


--
-- Name: COLUMN compensation_requests.valor_total; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.valor_total IS 'Valor total calculado (opcional)';


--
-- Name: COLUMN compensation_requests.motivo_rejeicao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.motivo_rejeicao IS 'Motivo da rejeiÃ§Ã£o (quando aplicÃ¡vel)';


--
-- Name: COLUMN compensation_requests.anexos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.compensation_requests.anexos IS 'Array de URLs dos anexos';


--
-- Name: correction_history; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.correction_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    correction_id uuid NOT NULL,
    action character varying(50) NOT NULL,
    old_values jsonb,
    new_values jsonb,
    changed_by uuid NOT NULL,
    changed_at timestamp with time zone DEFAULT now(),
    reason text,
    CONSTRAINT correction_history_action_check CHECK (((action)::text = ANY ((ARRAY['created'::character varying, 'updated'::character varying, 'approved'::character varying, 'rejected'::character varying, 'cancelled'::character varying])::text[])))
);


ALTER TABLE rh.correction_history OWNER TO postgres;

--
-- Name: TABLE correction_history; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.correction_history IS 'HistÃ³rico de alteraÃ§Ãµes nas correÃ§Ãµes de ponto';


--
-- Name: correction_settings; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.correction_settings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    dias_liberacao_correcao integer DEFAULT 7,
    permitir_correcao_futura boolean DEFAULT false,
    exigir_justificativa boolean DEFAULT true,
    permitir_correcao_apos_aprovacao boolean DEFAULT false,
    dias_limite_correcao integer DEFAULT 30,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.correction_settings OWNER TO postgres;

--
-- Name: TABLE correction_settings; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.correction_settings IS 'ConfiguraÃ§Ãµes de correÃ§Ã£o de ponto por empresa';


--
-- Name: deficiency_types; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.deficiency_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    tipo character varying(50) NOT NULL,
    grau character varying(50),
    beneficios_lei_8213 boolean DEFAULT false,
    beneficios_lei_13146 boolean DEFAULT false,
    isento_contribuicao_sindical boolean DEFAULT false,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT deficiency_types_grau_check CHECK (((grau)::text = ANY ((ARRAY['leve'::character varying, 'moderada'::character varying, 'severa'::character varying, 'profunda'::character varying])::text[]))),
    CONSTRAINT deficiency_types_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['fisica'::character varying, 'visual'::character varying, 'auditiva'::character varying, 'intelectual'::character varying, 'mental'::character varying, 'multipla'::character varying, 'outra'::character varying])::text[])))
);


ALTER TABLE rh.deficiency_types OWNER TO postgres;

--
-- Name: TABLE deficiency_types; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.deficiency_types IS 'Tabela de tipos de defici??ncia para PCDs';


--
-- Name: COLUMN deficiency_types.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.deficiency_types.tipo IS 'Tipo da defici??ncia: fisica, visual, auditiva, intelectual, mental, multipla, outra';


--
-- Name: COLUMN deficiency_types.grau; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.deficiency_types.grau IS 'Grau da defici??ncia: leve, moderada, severa, profunda';


--
-- Name: COLUMN deficiency_types.beneficios_lei_8213; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.deficiency_types.beneficios_lei_8213 IS 'Se tem benef??cios da Lei 8.213/91';


--
-- Name: COLUMN deficiency_types.beneficios_lei_13146; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.deficiency_types.beneficios_lei_13146 IS 'Se tem benef??cios da Lei 13.146/2015 (LBI)';


--
-- Name: COLUMN deficiency_types.isento_contribuicao_sindical; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.deficiency_types.isento_contribuicao_sindical IS 'Se est?? isento de contribui????o sindical';


--
-- Name: delay_reasons; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.delay_reasons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    tipo character varying(50) NOT NULL,
    desconta_salario boolean DEFAULT false,
    desconta_horas boolean DEFAULT false,
    requer_justificativa boolean DEFAULT false,
    requer_anexo boolean DEFAULT false,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT delay_reasons_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['atraso'::character varying, 'falta'::character varying, 'saida_antecipada'::character varying, 'justificado'::character varying, 'injustificado'::character varying])::text[])))
);


ALTER TABLE rh.delay_reasons OWNER TO postgres;

--
-- Name: TABLE delay_reasons; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.delay_reasons IS 'Motivos de atraso para correÃ§Ãµes de ponto';


--
-- Name: COLUMN delay_reasons.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.delay_reasons.tipo IS 'Tipo do motivo: atraso, falta, saida_antecipada, justificado, injustificado';


--
-- Name: COLUMN delay_reasons.desconta_salario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.delay_reasons.desconta_salario IS 'Se o motivo desconta do sal??rio';


--
-- Name: COLUMN delay_reasons.desconta_horas; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.delay_reasons.desconta_horas IS 'Se o motivo desconta horas trabalhadas';


--
-- Name: COLUMN delay_reasons.requer_justificativa; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.delay_reasons.requer_justificativa IS 'Se requer justificativa do funcion??rio';


--
-- Name: COLUMN delay_reasons.requer_anexo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.delay_reasons.requer_anexo IS 'Se requer anexo/documento comprobat??rio';


--
-- Name: dependents; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.dependents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    cpf character varying(14),
    rg character varying(20),
    data_nascimento date,
    parentesco character varying(50) NOT NULL,
    sexo character varying(10),
    estado_civil character varying(50),
    nacionalidade character varying(100),
    naturalidade character varying(100),
    nome_mae character varying(255),
    nome_pai character varying(255),
    cpf_mae character varying(14),
    cpf_pai character varying(14),
    telefone character varying(20),
    email character varying(255),
    endereco text,
    cidade character varying(100),
    estado character varying(2),
    cep character varying(10),
    data_casamento date,
    data_uniao_estavel date,
    data_separacao date,
    data_obito date,
    data_nascimento_mae date,
    escolaridade character varying(50),
    instituicao_ensino character varying(255),
    possui_deficiencia boolean DEFAULT false,
    tipo_deficiencia character varying(100),
    grau_deficiencia character varying(50),
    necessita_cuidados_especiais boolean DEFAULT false,
    certidao_nascimento character varying(100),
    certidao_casamento character varying(100),
    certidao_uniao_estavel character varying(100),
    comprovante_residencia character varying(100),
    status character varying(20) DEFAULT 'ativo'::character varying,
    data_inclusao date DEFAULT CURRENT_DATE,
    data_exclusao date,
    motivo_exclusao text,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT dependents_parentesco_check CHECK (((parentesco)::text = ANY ((ARRAY['conjuge'::character varying, 'companheiro'::character varying, 'filho'::character varying, 'filha'::character varying, 'pai'::character varying, 'mae'::character varying, 'sogro'::character varying, 'sogra'::character varying, 'neto'::character varying, 'neta'::character varying, 'irmao'::character varying, 'irma'::character varying, 'tio'::character varying, 'tia'::character varying, 'sobrinho'::character varying, 'sobrinha'::character varying, 'outros'::character varying])::text[]))),
    CONSTRAINT dependents_sexo_check CHECK (((sexo)::text = ANY ((ARRAY['masculino'::character varying, 'feminino'::character varying, 'outro'::character varying])::text[]))),
    CONSTRAINT dependents_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying, 'suspenso'::character varying, 'excluido'::character varying])::text[])))
);


ALTER TABLE rh.dependents OWNER TO postgres;

--
-- Name: TABLE dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.dependents IS 'Tabela para cadastro de dependentes dos funcionÃ¡rios';


--
-- Name: COLUMN dependents.parentesco; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.parentesco IS 'Tipo de parentesco com o funcionÃ¡rio';


--
-- Name: COLUMN dependents.data_casamento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_casamento IS 'Data do casamento (para cÃ´njuge)';


--
-- Name: COLUMN dependents.data_uniao_estavel; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_uniao_estavel IS 'Data da uniÃ£o estÃ¡vel (para companheiro)';


--
-- Name: COLUMN dependents.data_separacao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_separacao IS 'Data da separaÃ§Ã£o (para ex-cÃ´njuge)';


--
-- Name: COLUMN dependents.data_obito; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_obito IS 'Data do Ã³bito (para falecidos)';


--
-- Name: COLUMN dependents.escolaridade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.escolaridade IS 'NÃ­vel de escolaridade do dependente';


--
-- Name: COLUMN dependents.instituicao_ensino; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.instituicao_ensino IS 'InstituiÃ§Ã£o de ensino onde estuda';


--
-- Name: COLUMN dependents.possui_deficiencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.possui_deficiencia IS 'Indica se o dependente possui deficiÃªncia';


--
-- Name: COLUMN dependents.tipo_deficiencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.tipo_deficiencia IS 'Tipo de deficiÃªncia (fÃ­sica, visual, auditiva, etc.)';


--
-- Name: COLUMN dependents.grau_deficiencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.grau_deficiencia IS 'Grau da deficiÃªncia (leve, moderada, severa, profunda)';


--
-- Name: COLUMN dependents.necessita_cuidados_especiais; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.necessita_cuidados_especiais IS 'Indica se necessita de cuidados especiais';


--
-- Name: COLUMN dependents.certidao_nascimento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.certidao_nascimento IS 'NÃºmero da certidÃ£o de nascimento';


--
-- Name: COLUMN dependents.certidao_casamento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.certidao_casamento IS 'NÃºmero da certidÃ£o de casamento';


--
-- Name: COLUMN dependents.certidao_uniao_estavel; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.certidao_uniao_estavel IS 'NÃºmero da certidÃ£o de uniÃ£o estÃ¡vel';


--
-- Name: COLUMN dependents.comprovante_residencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.comprovante_residencia IS 'NÃºmero do comprovante de residÃªncia';


--
-- Name: COLUMN dependents.data_inclusao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_inclusao IS 'Data de inclusÃ£o como dependente';


--
-- Name: COLUMN dependents.data_exclusao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.data_exclusao IS 'Data de exclusÃ£o como dependente';


--
-- Name: COLUMN dependents.motivo_exclusao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.dependents.motivo_exclusao IS 'Motivo da exclusÃ£o como dependente';


--
-- Name: employees; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employees (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    matricula character varying(50),
    cpf character varying(14) NOT NULL,
    rg character varying(20),
    data_nascimento date,
    data_admissao date NOT NULL,
    data_demissao date,
    cargo_id uuid,
    departamento_id uuid,
    salario_base numeric(10,2),
    status character varying(20) DEFAULT 'ativo'::character varying,
    telefone character varying(20),
    email character varying(255),
    endereco text,
    cidade character varying(100),
    estado character varying(2),
    cep character varying(10),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    user_id uuid,
    gestor_imediato_id uuid,
    certidao_nascimento character varying(255),
    certidao_casamento character varying(255),
    titulo_eleitor character varying(255),
    ctps character varying(255),
    pis_pasep character varying(255),
    certificado_reservista character varying(255),
    comprovante_endereco character varying(255),
    foto_funcionario text,
    escolaridade character varying(100),
    tipo_cnh character varying(10),
    cartao_sus character varying(255),
    registros_profissionais jsonb,
    outros_vinculos_empregaticios boolean DEFAULT false,
    detalhes_outros_vinculos text,
    banco_nome character varying(255),
    banco_agencia character varying(20),
    banco_conta character varying(50),
    banco_tipo_conta character varying(20),
    banco_pix character varying(255),
    CONSTRAINT employees_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying, 'afastado'::character varying, 'demitido'::character varying])::text[])))
);


ALTER TABLE rh.employees OWNER TO postgres;

--
-- Name: COLUMN employees.certidao_nascimento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.certidao_nascimento IS 'NÃºmero da certidÃ£o de nascimento';


--
-- Name: COLUMN employees.certidao_casamento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.certidao_casamento IS 'NÃºmero da certidÃ£o de casamento (se aplicÃ¡vel)';


--
-- Name: COLUMN employees.titulo_eleitor; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.titulo_eleitor IS 'NÃºmero do tÃ­tulo de eleitor';


--
-- Name: COLUMN employees.ctps; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.ctps IS 'NÃºmero da Carteira de Trabalho (CTPS)';


--
-- Name: COLUMN employees.pis_pasep; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.pis_pasep IS 'NÃºmero do PIS/PASEP ou NIS/NIT';


--
-- Name: COLUMN employees.certificado_reservista; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.certificado_reservista IS 'NÃºmero do certificado de reservista (homens atÃ© 45 anos)';


--
-- Name: COLUMN employees.comprovante_endereco; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.comprovante_endereco IS 'Comprovante de endereÃ§o atualizado (Ãºltimos 3 meses)';


--
-- Name: COLUMN employees.foto_funcionario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.foto_funcionario IS 'URL da foto do funcionÃ¡rio';


--
-- Name: COLUMN employees.escolaridade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.escolaridade IS 'NÃ­vel de escolaridade';


--
-- Name: COLUMN employees.tipo_cnh; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.tipo_cnh IS 'Tipo da CNH (A, B, C, D, E)';


--
-- Name: COLUMN employees.cartao_sus; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.cartao_sus IS 'NÃºmero do cartÃ£o do SUS';


--
-- Name: COLUMN employees.registros_profissionais; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.registros_profissionais IS 'Registros profissionais (CREA, CRM, OAB, Coren, etc.) em formato JSON';


--
-- Name: COLUMN employees.outros_vinculos_empregaticios; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.outros_vinculos_empregaticios IS 'Possui outros vÃ­nculos empregatÃ­cios';


--
-- Name: COLUMN employees.detalhes_outros_vinculos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.detalhes_outros_vinculos IS 'Detalhes dos outros vÃ­nculos empregatÃ­cios';


--
-- Name: COLUMN employees.banco_nome; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.banco_nome IS 'Nome do banco';


--
-- Name: COLUMN employees.banco_agencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.banco_agencia IS 'NÃºmero da agÃªncia';


--
-- Name: COLUMN employees.banco_conta; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.banco_conta IS 'NÃºmero da conta';


--
-- Name: COLUMN employees.banco_tipo_conta; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.banco_tipo_conta IS 'Tipo da conta (corrente, poupanÃ§a, salÃ¡rio)';


--
-- Name: COLUMN employees.banco_pix; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employees.banco_pix IS 'Chave PIX';


--
-- Name: dependents_with_employee; Type: VIEW; Schema: rh; Owner: postgres
--

CREATE VIEW rh.dependents_with_employee AS
 SELECT d.id,
    d.company_id,
    d.employee_id,
    d.nome,
    d.cpf,
    d.rg,
    d.data_nascimento,
    d.parentesco,
    d.sexo,
    d.estado_civil,
    d.nacionalidade,
    d.naturalidade,
    d.nome_mae,
    d.nome_pai,
    d.cpf_mae,
    d.cpf_pai,
    d.telefone,
    d.email,
    d.endereco,
    d.cidade,
    d.estado,
    d.cep,
    d.data_casamento,
    d.data_uniao_estavel,
    d.data_separacao,
    d.data_obito,
    d.data_nascimento_mae,
    d.escolaridade,
    d.instituicao_ensino,
    d.possui_deficiencia,
    d.tipo_deficiencia,
    d.grau_deficiencia,
    d.necessita_cuidados_especiais,
    d.certidao_nascimento,
    d.certidao_casamento,
    d.certidao_uniao_estavel,
    d.comprovante_residencia,
    d.status,
    d.data_inclusao,
    d.data_exclusao,
    d.motivo_exclusao,
    d.observacoes,
    d.created_at,
    d.updated_at,
    d.created_by,
    d.updated_by,
    e.nome AS funcionario_nome,
    e.matricula AS funcionario_matricula,
    e.cpf AS funcionario_cpf
   FROM (rh.dependents d
     JOIN rh.employees e ON ((d.employee_id = e.id)))
  WHERE ((d.status)::text = 'ativo'::text);


ALTER VIEW rh.dependents_with_employee OWNER TO postgres;

--
-- Name: VIEW dependents_with_employee; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON VIEW rh.dependents_with_employee IS 'View para consultar dependentes ativos com informaÃ§Ãµes do funcionÃ¡rio';


--
-- Name: disciplinary_actions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.disciplinary_actions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    tipo_acao character varying(30) NOT NULL,
    data_ocorrencia date NOT NULL,
    data_aplicacao date NOT NULL,
    gravidade character varying(20) NOT NULL,
    motivo text NOT NULL,
    descricao_ocorrencia text NOT NULL,
    medidas_corretivas text,
    status character varying(20) DEFAULT 'ativo'::character varying NOT NULL,
    aplicado_por uuid,
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    observacoes text,
    anexos text[],
    data_arquivamento timestamp with time zone,
    motivo_arquivamento text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    duration_days integer,
    start_date date,
    end_date date,
    documents jsonb,
    is_active boolean DEFAULT true,
    CONSTRAINT disciplinary_actions_gravidade_check CHECK (((gravidade)::text = ANY ((ARRAY['leve'::character varying, 'moderada'::character varying, 'grave'::character varying, 'gravissima'::character varying])::text[]))),
    CONSTRAINT disciplinary_actions_status_check CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'suspended'::character varying, 'expired'::character varying, 'cancelled'::character varying])::text[]))),
    CONSTRAINT disciplinary_actions_tipo_acao_check CHECK (((tipo_acao)::text = ANY ((ARRAY['advertencia_verbal'::character varying, 'advertencia_escrita'::character varying, 'suspensao'::character varying, 'demissao_justa_causa'::character varying])::text[])))
);


ALTER TABLE rh.disciplinary_actions OWNER TO postgres;

--
-- Name: TABLE disciplinary_actions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.disciplinary_actions IS 'Ações disciplinares aplicadas aos funcionários - Estrutura atualizada conforme documentação';


--
-- Name: COLUMN disciplinary_actions.tipo_acao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.tipo_acao IS 'Tipo: advertencia, suspensao, demissao_justa_causa, transferencia, outros';


--
-- Name: COLUMN disciplinary_actions.gravidade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.gravidade IS 'Gravidade: leve, moderada, grave, gravissima';


--
-- Name: COLUMN disciplinary_actions.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.status IS 'Status: ativo, suspenso, cancelado, arquivado';


--
-- Name: COLUMN disciplinary_actions.aplicado_por; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.aplicado_por IS 'UsuÃ¡rio que aplicou a aÃ§Ã£o disciplinar';


--
-- Name: COLUMN disciplinary_actions.aprovado_por; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.aprovado_por IS 'UsuÃ¡rio que aprovou a aÃ§Ã£o disciplinar';


--
-- Name: COLUMN disciplinary_actions.anexos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.anexos IS 'Array de URLs dos arquivos anexados (evidÃªncias, testemunhos, etc.)';


--
-- Name: COLUMN disciplinary_actions.duration_days; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.duration_days IS 'Duração em dias para suspensões';


--
-- Name: COLUMN disciplinary_actions.start_date; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.start_date IS 'Data de início da suspensão';


--
-- Name: COLUMN disciplinary_actions.end_date; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.end_date IS 'Data de fim da suspensão';


--
-- Name: COLUMN disciplinary_actions.documents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.documents IS 'Documentos anexados (evidências, testemunhos, etc.)';


--
-- Name: COLUMN disciplinary_actions.is_active; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.disciplinary_actions.is_active IS 'Indica se a ação está ativa';


--
-- Name: employee_benefit_assignments; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_benefit_assignments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    benefit_config_id uuid NOT NULL,
    company_id uuid NOT NULL,
    start_date date NOT NULL,
    end_date date,
    custom_value numeric(10,2),
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.employee_benefit_assignments OWNER TO postgres;

--
-- Name: employee_correction_permissions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_correction_permissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    mes_ano character varying(7) NOT NULL,
    liberado boolean DEFAULT false,
    liberado_por uuid,
    liberado_em timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.employee_correction_permissions OWNER TO postgres;

--
-- Name: TABLE employee_correction_permissions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employee_correction_permissions IS 'Controle de liberaÃ§Ã£o de correÃ§Ã£o por funcionÃ¡rio e mÃªs';


--
-- Name: employee_medical_plans; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_medical_plans (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    plan_id uuid NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    status character varying(20) DEFAULT 'ativo'::character varying NOT NULL,
    valor_mensal numeric(10,2) NOT NULL,
    desconto_aplicado numeric(5,2) DEFAULT 0,
    motivo_suspensao text,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    entra_no_calculo_folha boolean DEFAULT true NOT NULL,
    CONSTRAINT employee_medical_plans_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'suspenso'::character varying, 'cancelado'::character varying, 'transferido'::character varying])::text[])))
);


ALTER TABLE rh.employee_medical_plans OWNER TO postgres;

--
-- Name: TABLE employee_medical_plans; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employee_medical_plans IS 'Adesões dos funcionários aos planos médicos/odontológicos';


--
-- Name: COLUMN employee_medical_plans.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_medical_plans.status IS 'Status: ativo, suspenso, cancelado, transferido';


--
-- Name: COLUMN employee_medical_plans.entra_no_calculo_folha; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_medical_plans.entra_no_calculo_folha IS 'Se a adesÃ£o do funcionÃ¡rio ao plano deve ser incluÃ­da no cÃ¡lculo da folha';


--
-- Name: employee_plan_dependents; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_plan_dependents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_plan_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    cpf character varying(11),
    data_nascimento date,
    parentesco character varying(50) NOT NULL,
    status character varying(20) DEFAULT 'ativo'::character varying NOT NULL,
    valor_mensal numeric(10,2) NOT NULL,
    data_inclusao date NOT NULL,
    data_exclusao date,
    motivo_exclusao text,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT employee_plan_dependents_parentesco_check CHECK (((parentesco)::text = ANY ((ARRAY['conjuge'::character varying, 'filho'::character varying, 'filha'::character varying, 'pai'::character varying, 'mae'::character varying, 'outros'::character varying])::text[]))),
    CONSTRAINT employee_plan_dependents_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'suspenso'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE rh.employee_plan_dependents OWNER TO postgres;

--
-- Name: TABLE employee_plan_dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employee_plan_dependents IS 'Dependentes dos funcionários nos planos médicos/odontológicos';


--
-- Name: COLUMN employee_plan_dependents.parentesco; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_plan_dependents.parentesco IS 'Parentesco: conjuge, filho, filha, pai, mae, outros';


--
-- Name: COLUMN employee_plan_dependents.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_plan_dependents.status IS 'Status: ativo, suspenso, cancelado';


--
-- Name: employee_schedules; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_schedules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    schedule_id uuid NOT NULL,
    company_id uuid NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.employee_schedules OWNER TO postgres;

--
-- Name: employee_shifts; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_shifts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    funcionario_id uuid NOT NULL,
    turno_id uuid NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    ativo boolean DEFAULT true,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_employee_shifts_data_fim CHECK (((data_fim IS NULL) OR (data_fim >= data_inicio)))
);


ALTER TABLE rh.employee_shifts OWNER TO postgres;

--
-- Name: TABLE employee_shifts; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employee_shifts IS 'Tabela de turnos atribuÃ­dos aos funcionÃ¡rios';


--
-- Name: COLUMN employee_shifts.data_inicio; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_shifts.data_inicio IS 'Data de inÃ­cio do turno para o funcionÃ¡rio';


--
-- Name: COLUMN employee_shifts.data_fim; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_shifts.data_fim IS 'Data de fim do turno (NULL se ainda ativo)';


--
-- Name: COLUMN employee_shifts.ativo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_shifts.ativo IS 'Se o turno estÃ¡ ativo para o funcionÃ¡rio';


--
-- Name: employee_union_memberships; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employee_union_memberships (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    union_id uuid NOT NULL,
    data_filiacao date NOT NULL,
    data_desfiliacao date,
    status character varying(20) DEFAULT 'ativo'::character varying NOT NULL,
    numero_carteira character varying(50),
    categoria_filiacao character varying(100),
    valor_mensalidade numeric(10,2),
    desconto_folha boolean DEFAULT false,
    motivo_desfiliacao text,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT employee_union_memberships_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'suspenso'::character varying, 'desfiliado'::character varying, 'transferido'::character varying])::text[])))
);


ALTER TABLE rh.employee_union_memberships OWNER TO postgres;

--
-- Name: TABLE employee_union_memberships; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employee_union_memberships IS 'Filiações dos funcionários aos sindicatos';


--
-- Name: COLUMN employee_union_memberships.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employee_union_memberships.status IS 'Status: ativo, suspenso, desfiliado, transferido';


--
-- Name: employment_contracts; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.employment_contracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    numero_contrato character varying(100) NOT NULL,
    tipo_contrato character varying(50) NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    periodo_experiencia integer DEFAULT 90,
    salario_base numeric(10,2) NOT NULL,
    carga_horaria_semanal integer DEFAULT 40,
    regime_trabalho character varying(50) DEFAULT 'tempo_integral'::character varying,
    tipo_jornada character varying(50) DEFAULT 'normal'::character varying,
    beneficios jsonb DEFAULT '{}'::jsonb,
    clausulas_especiais text,
    status character varying(20) DEFAULT 'ativo'::character varying,
    data_rescisao date,
    motivo_rescisao character varying(255),
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_employment_contracts_carga_horaria CHECK (((carga_horaria_semanal > 0) AND (carga_horaria_semanal <= 168))),
    CONSTRAINT check_employment_contracts_data_fim CHECK (((data_fim IS NULL) OR (data_fim >= data_inicio))),
    CONSTRAINT check_employment_contracts_salario CHECK ((salario_base > (0)::numeric)),
    CONSTRAINT employment_contracts_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'suspenso'::character varying, 'encerrado'::character varying, 'rescisao'::character varying])::text[])))
);


ALTER TABLE rh.employment_contracts OWNER TO postgres;

--
-- Name: TABLE employment_contracts; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.employment_contracts IS 'Tabela de contratos de trabalho';


--
-- Name: COLUMN employment_contracts.tipo_contrato; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employment_contracts.tipo_contrato IS 'Tipo do contrato: CLT, PJ, Estagi??rio, Terceirizado, etc.';


--
-- Name: COLUMN employment_contracts.regime_trabalho; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employment_contracts.regime_trabalho IS 'Regime de trabalho: tempo_integral, meio_periodo, etc.';


--
-- Name: COLUMN employment_contracts.beneficios; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.employment_contracts.beneficios IS 'JSON com benef??cios do contrato';


--
-- Name: equipment_rental_approvals; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.equipment_rental_approvals (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    tipo_equipamento character varying(100) NOT NULL,
    valor_mensal numeric(10,2) NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    justificativa text NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT equipment_rental_approvals_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'ativo'::character varying, 'finalizado'::character varying])::text[])))
);


ALTER TABLE rh.equipment_rental_approvals OWNER TO postgres;

--
-- Name: esocial_batches; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.esocial_batches (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    batch_number character varying(50) NOT NULL,
    period character varying(7) NOT NULL,
    status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    total_events integer DEFAULT 0 NOT NULL,
    sent_events integer DEFAULT 0 NOT NULL,
    accepted_events integer DEFAULT 0 NOT NULL,
    rejected_events integer DEFAULT 0 NOT NULL,
    error_events integer DEFAULT 0 NOT NULL,
    xml_content text,
    xml_response text,
    protocol_number character varying(100),
    sent_at timestamp with time zone,
    processed_at timestamp with time zone,
    error_message text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    created_by uuid,
    updated_by uuid,
    CONSTRAINT esocial_batches_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'sending'::character varying, 'sent'::character varying, 'accepted'::character varying, 'rejected'::character varying, 'error'::character varying])::text[])))
);


ALTER TABLE rh.esocial_batches OWNER TO postgres;

--
-- Name: esocial_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.esocial_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    ambiente character varying(10) DEFAULT 'homologacao'::character varying NOT NULL,
    tp_amb character varying(1) DEFAULT '2'::character varying NOT NULL,
    cnpj_empregador character varying(14) NOT NULL,
    cpf_empregador character varying(11),
    razao_social character varying(255) NOT NULL,
    codigo_empregador character varying(20),
    codigo_esocial character varying(20),
    versao_lote character varying(10) DEFAULT '2.5.00'::character varying,
    versao_evento character varying(10) DEFAULT '2.5.00'::character varying,
    url_consulta character varying(255),
    url_envio character varying(255),
    certificado_digital text,
    senha_certificado character varying(255),
    proxy_host character varying(255),
    proxy_port integer,
    proxy_user character varying(255),
    proxy_pass character varying(255),
    timeout integer DEFAULT 300,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT esocial_config_ambiente_check CHECK (((ambiente)::text = ANY ((ARRAY['homologacao'::character varying, 'producao'::character varying])::text[])))
);


ALTER TABLE rh.esocial_config OWNER TO postgres;

--
-- Name: TABLE esocial_config; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.esocial_config IS 'ConfiguraÃ§Ãµes de integraÃ§Ã£o com eSocial';


--
-- Name: COLUMN esocial_config.ambiente; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_config.ambiente IS 'Ambiente: homologacao ou producao';


--
-- Name: COLUMN esocial_config.tp_amb; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_config.tp_amb IS 'Tipo ambiente: 1=ProduÃ§Ã£o, 2=HomologaÃ§Ã£o';


--
-- Name: COLUMN esocial_config.versao_lote; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_config.versao_lote IS 'VersÃ£o do lote eSocial';


--
-- Name: COLUMN esocial_config.versao_evento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_config.versao_evento IS 'VersÃ£o do evento eSocial';


--
-- Name: COLUMN esocial_config.certificado_digital; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_config.certificado_digital IS 'Certificado digital em Base64';


--
-- Name: esocial_events; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.esocial_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid,
    tipo_evento character varying(50) NOT NULL,
    numero_recibo character varying(50),
    data_envio timestamp with time zone,
    data_recebimento timestamp with time zone,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    xml_content text,
    xml_response text,
    observacoes text,
    tentativas_envio integer DEFAULT 0,
    ultimo_erro text,
    data_proximo_envio timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    batch_id uuid,
    CONSTRAINT esocial_events_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'enviado'::character varying, 'processado'::character varying, 'rejeitado'::character varying, 'erro'::character varying])::text[]))),
    CONSTRAINT esocial_events_tipo_evento_check CHECK (((tipo_evento)::text = ANY ((ARRAY['S1000'::character varying, 'S1005'::character varying, 'S1010'::character varying, 'S1020'::character varying, 'S1030'::character varying, 'S1035'::character varying, 'S1040'::character varying, 'S1050'::character varying, 'S1060'::character varying, 'S1070'::character varying, 'S1080'::character varying, 'S1200'::character varying, 'S1202'::character varying, 'S1207'::character varying, 'S1210'::character varying, 'S1220'::character varying, 'S1250'::character varying, 'S1260'::character varying, 'S1270'::character varying, 'S1280'::character varying, 'S1295'::character varying, 'S1298'::character varying, 'S1299'::character varying, 'S1300'::character varying, 'S2190'::character varying, 'S2200'::character varying, 'S2205'::character varying, 'S2206'::character varying, 'S2210'::character varying, 'S2220'::character varying, 'S2221'::character varying, 'S2230'::character varying, 'S2231'::character varying, 'S2240'::character varying, 'S2241'::character varying, 'S2245'::character varying, 'S2250'::character varying, 'S2260'::character varying, 'S2298'::character varying, 'S2299'::character varying, 'S2300'::character varying, 'S2306'::character varying, 'S2399'::character varying, 'S2400'::character varying, 'S2405'::character varying, 'S2410'::character varying, 'S2416'::character varying, 'S2418'::character varying, 'S2420'::character varying, 'S3000'::character varying, 'S5001'::character varying, 'S5002'::character varying, 'S5003'::character varying, 'S5011'::character varying, 'S5012'::character varying, 'S5013'::character varying])::text[])))
);


ALTER TABLE rh.esocial_events OWNER TO postgres;

--
-- Name: TABLE esocial_events; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.esocial_events IS 'Eventos eSocial a serem enviados para o governo';


--
-- Name: COLUMN esocial_events.tipo_evento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_events.tipo_evento IS 'Tipo do evento eSocial (S1000, S2200, S1200, etc.)';


--
-- Name: COLUMN esocial_events.numero_recibo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_events.numero_recibo IS 'NÃºmero do recibo de entrega do eSocial';


--
-- Name: COLUMN esocial_events.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_events.status IS 'Status: pendente, enviado, processado, rejeitado, erro';


--
-- Name: COLUMN esocial_events.xml_content; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_events.xml_content IS 'ConteÃºdo XML do evento';


--
-- Name: COLUMN esocial_events.xml_response; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_events.xml_response IS 'Resposta XML do governo';


--
-- Name: esocial_integrations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.esocial_integrations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    tipo_evento character varying(50) NOT NULL,
    codigo_evento character varying(20) NOT NULL,
    descricao text,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    data_envio timestamp with time zone,
    data_processamento timestamp with time zone,
    protocolo character varying(100),
    funcionario_id uuid,
    observacoes text,
    arquivo_retorno text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT esocial_integrations_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'enviado'::character varying, 'processado'::character varying, 'erro'::character varying, 'rejeitado'::character varying])::text[])))
);


ALTER TABLE rh.esocial_integrations OWNER TO postgres;

--
-- Name: TABLE esocial_integrations; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.esocial_integrations IS 'Tabela de integraÃ§Ã£o com eSocial';


--
-- Name: COLUMN esocial_integrations.tipo_evento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_integrations.tipo_evento IS 'Tipo do evento eSocial (ex: S-1000, S-1010)';


--
-- Name: COLUMN esocial_integrations.codigo_evento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_integrations.codigo_evento IS 'CÃ³digo especÃ­fico do evento';


--
-- Name: COLUMN esocial_integrations.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_integrations.status IS 'Status da integraÃ§Ã£o: pendente, enviado, processado, erro, rejeitado';


--
-- Name: COLUMN esocial_integrations.protocolo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_integrations.protocolo IS 'Protocolo de envio para eSocial';


--
-- Name: COLUMN esocial_integrations.arquivo_retorno; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.esocial_integrations.arquivo_retorno IS 'URL do arquivo de retorno do eSocial';


--
-- Name: esocial_logs; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.esocial_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    event_id uuid,
    tipo_operacao character varying(20) NOT NULL,
    status character varying(20) NOT NULL,
    mensagem text,
    detalhes jsonb,
    tempo_execucao integer,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT esocial_logs_status_check CHECK (((status)::text = ANY ((ARRAY['sucesso'::character varying, 'erro'::character varying, 'aviso'::character varying])::text[]))),
    CONSTRAINT esocial_logs_tipo_operacao_check CHECK (((tipo_operacao)::text = ANY ((ARRAY['envio'::character varying, 'consulta'::character varying, 'download'::character varying, 'erro'::character varying])::text[])))
);


ALTER TABLE rh.esocial_logs OWNER TO postgres;

--
-- Name: TABLE esocial_logs; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.esocial_logs IS 'Logs de operaÃ§Ãµes eSocial';


--
-- Name: event_consolidations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.event_consolidations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    periodo character varying(7) NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    total_eventos integer DEFAULT 0,
    eventos_processados integer DEFAULT 0,
    data_inicio timestamp with time zone,
    data_fim timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT event_consolidations_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'processando'::character varying, 'concluido'::character varying, 'erro'::character varying])::text[])))
);


ALTER TABLE rh.event_consolidations OWNER TO postgres;

--
-- Name: TABLE event_consolidations; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.event_consolidations IS 'Tabela de consolidaÃ§Ã£o de eventos da folha de pagamento';


--
-- Name: COLUMN event_consolidations.periodo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.event_consolidations.periodo IS 'PerÃ­odo da consolidaÃ§Ã£o no formato YYYY/MM';


--
-- Name: COLUMN event_consolidations.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.event_consolidations.status IS 'Status da consolidaÃ§Ã£o: pendente, processando, concluido, erro';


--
-- Name: COLUMN event_consolidations.total_eventos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.event_consolidations.total_eventos IS 'Total de eventos a serem processados';


--
-- Name: COLUMN event_consolidations.eventos_processados; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.event_consolidations.eventos_processados IS 'Quantidade de eventos jÃ¡ processados';


--
-- Name: fgts_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.fgts_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    descricao character varying(255) NOT NULL,
    ano_vigencia integer NOT NULL,
    mes_vigencia integer NOT NULL,
    aliquota_fgts numeric(5,4) NOT NULL,
    aliquota_multa numeric(5,4) DEFAULT 0,
    aliquota_juros numeric(5,4) DEFAULT 0,
    teto_salario numeric(12,2),
    valor_minimo_contribuicao numeric(10,2) DEFAULT 0,
    multa_rescisao numeric(5,4) DEFAULT 0,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_fgts_config_aliquota_fgts CHECK (((aliquota_fgts >= (0)::numeric) AND (aliquota_fgts <= (1)::numeric))),
    CONSTRAINT check_fgts_config_aliquota_juros CHECK (((aliquota_juros >= (0)::numeric) AND (aliquota_juros <= (1)::numeric))),
    CONSTRAINT check_fgts_config_aliquota_multa CHECK (((aliquota_multa >= (0)::numeric) AND (aliquota_multa <= (1)::numeric))),
    CONSTRAINT check_fgts_config_ano CHECK (((ano_vigencia >= 2020) AND (ano_vigencia <= 2030))),
    CONSTRAINT check_fgts_config_mes CHECK (((mes_vigencia >= 1) AND (mes_vigencia <= 12))),
    CONSTRAINT check_fgts_config_multa_rescisao CHECK (((multa_rescisao >= (0)::numeric) AND (multa_rescisao <= (1)::numeric)))
);


ALTER TABLE rh.fgts_config OWNER TO postgres;

--
-- Name: TABLE fgts_config; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.fgts_config IS 'Tabela de configura????es do FGTS para c??lculo de fundo de garantia';


--
-- Name: COLUMN fgts_config.ano_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.ano_vigencia IS 'Ano de vig??ncia da configura????o FGTS';


--
-- Name: COLUMN fgts_config.mes_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.mes_vigencia IS 'M??s de vig??ncia da configura????o FGTS';


--
-- Name: COLUMN fgts_config.aliquota_fgts; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.aliquota_fgts IS 'Al??quota do FGTS (0.08 = 8%)';


--
-- Name: COLUMN fgts_config.aliquota_multa; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.aliquota_multa IS 'Al??quota de multa sobre FGTS';


--
-- Name: COLUMN fgts_config.aliquota_juros; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.aliquota_juros IS 'Al??quota de juros sobre FGTS';


--
-- Name: COLUMN fgts_config.teto_salario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.teto_salario IS 'Teto salarial para incid??ncia do FGTS';


--
-- Name: COLUMN fgts_config.multa_rescisao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.fgts_config.multa_rescisao IS 'Multa de rescis??o (0.4 = 40%)';


--
-- Name: gestor_notifications; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.gestor_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    gestor_id uuid NOT NULL,
    tipo_notificacao character varying(50) NOT NULL,
    titulo character varying(255) NOT NULL,
    mensagem text NOT NULL,
    dados_extras jsonb,
    lida boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT gestor_notifications_tipo_notificacao_check CHECK (((tipo_notificacao)::text = ANY ((ARRAY['aprovacao_pendente'::character varying, 'aprovacao_realizada'::character varying, 'solicitacao_nova'::character varying, 'alerta_vencimento'::character varying])::text[])))
);


ALTER TABLE rh.gestor_notifications OWNER TO postgres;

--
-- Name: holidays; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.holidays (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    data date NOT NULL,
    tipo character varying(30) NOT NULL,
    descricao text,
    ativo boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT holidays_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['nacional'::character varying, 'estadual'::character varying, 'municipal'::character varying, 'pontos_facultativos'::character varying, 'outros'::character varying])::text[])))
);


ALTER TABLE rh.holidays OWNER TO postgres;

--
-- Name: TABLE holidays; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.holidays IS 'Feriados e pontos facultativos para cÃ¡lculos de folha';


--
-- Name: COLUMN holidays.nome; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.holidays.nome IS 'Nome do feriado';


--
-- Name: COLUMN holidays.data; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.holidays.data IS 'Data do feriado';


--
-- Name: COLUMN holidays.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.holidays.tipo IS 'Tipo: nacional, estadual, municipal, pontos_facultativos, outros';


--
-- Name: COLUMN holidays.ativo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.holidays.ativo IS 'Se o feriado estÃ¡ ativo para cÃ¡lculos';


--
-- Name: income_statements; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.income_statements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    ano_referencia integer NOT NULL,
    mes_referencia integer NOT NULL,
    total_rendimentos numeric(12,2) DEFAULT 0 NOT NULL,
    total_descontos numeric(12,2) DEFAULT 0 NOT NULL,
    salario_liquido numeric(12,2) DEFAULT 0 NOT NULL,
    inss_descontado numeric(12,2) DEFAULT 0 NOT NULL,
    irrf_descontado numeric(12,2) DEFAULT 0 NOT NULL,
    fgts_descontado numeric(12,2) DEFAULT 0 NOT NULL,
    outros_descontos numeric(12,2) DEFAULT 0 NOT NULL,
    status character varying(20) DEFAULT 'processando'::character varying NOT NULL,
    arquivo_pdf text,
    observacoes text,
    data_geracao timestamp with time zone DEFAULT now(),
    data_vencimento date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT income_statements_status_check CHECK (((status)::text = ANY ((ARRAY['processando'::character varying, 'processado'::character varying, 'erro'::character varying])::text[])))
);


ALTER TABLE rh.income_statements OWNER TO postgres;

--
-- Name: TABLE income_statements; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.income_statements IS 'Informes de rendimentos para declaraÃ§Ã£o de Imposto de Renda';


--
-- Name: COLUMN income_statements.ano_referencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.ano_referencia IS 'Ano de referÃªncia do informe';


--
-- Name: COLUMN income_statements.mes_referencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.mes_referencia IS 'MÃªs de referÃªncia do informe';


--
-- Name: COLUMN income_statements.total_rendimentos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.total_rendimentos IS 'Total de rendimentos brutos';


--
-- Name: COLUMN income_statements.total_descontos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.total_descontos IS 'Total de descontos';


--
-- Name: COLUMN income_statements.salario_liquido; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.salario_liquido IS 'SalÃ¡rio lÃ­quido';


--
-- Name: COLUMN income_statements.inss_descontado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.inss_descontado IS 'Valor descontado de INSS';


--
-- Name: COLUMN income_statements.irrf_descontado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.irrf_descontado IS 'Valor descontado de IRRF';


--
-- Name: COLUMN income_statements.fgts_descontado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.fgts_descontado IS 'Valor descontado de FGTS';


--
-- Name: COLUMN income_statements.outros_descontos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.outros_descontos IS 'Outros descontos';


--
-- Name: COLUMN income_statements.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.status IS 'Status do processamento do informe';


--
-- Name: COLUMN income_statements.arquivo_pdf; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.arquivo_pdf IS 'Caminho do arquivo PDF gerado';


--
-- Name: COLUMN income_statements.data_geracao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.data_geracao IS 'Data de geraÃ§Ã£o do informe';


--
-- Name: COLUMN income_statements.data_vencimento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.income_statements.data_vencimento IS 'Data de vencimento para download';


--
-- Name: inss_brackets; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.inss_brackets (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    descricao character varying(255) NOT NULL,
    ano_vigencia integer NOT NULL,
    mes_vigencia integer NOT NULL,
    valor_minimo numeric(12,2) NOT NULL,
    valor_maximo numeric(12,2),
    aliquota numeric(5,4) NOT NULL,
    valor_deducao numeric(12,2) DEFAULT 0,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_inss_bracket_aliquota CHECK (((aliquota >= (0)::numeric) AND (aliquota <= (1)::numeric))),
    CONSTRAINT check_inss_bracket_ano CHECK (((ano_vigencia >= 2020) AND (ano_vigencia <= 2030))),
    CONSTRAINT check_inss_bracket_mes CHECK (((mes_vigencia >= 1) AND (mes_vigencia <= 12))),
    CONSTRAINT check_inss_bracket_valores CHECK (((valor_maximo IS NULL) OR (valor_minimo <= valor_maximo)))
);


ALTER TABLE rh.inss_brackets OWNER TO postgres;

--
-- Name: TABLE inss_brackets; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.inss_brackets IS 'Tabela de faixas do INSS para c??lculo de contribui????o previdenci??ria';


--
-- Name: COLUMN inss_brackets.ano_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.ano_vigencia IS 'Ano de vig??ncia da faixa INSS';


--
-- Name: COLUMN inss_brackets.mes_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.mes_vigencia IS 'M??s de vig??ncia da faixa INSS';


--
-- Name: COLUMN inss_brackets.valor_minimo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.valor_minimo IS 'Valor m??nimo da faixa salarial';


--
-- Name: COLUMN inss_brackets.valor_maximo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.valor_maximo IS 'Valor m??ximo da faixa salarial (NULL = sem limite)';


--
-- Name: COLUMN inss_brackets.aliquota; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.aliquota IS 'Al??quota do INSS (0.075 = 7,5%)';


--
-- Name: COLUMN inss_brackets.valor_deducao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.inss_brackets.valor_deducao IS 'Valor a ser deduzido do c??lculo';


--
-- Name: irrf_brackets; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.irrf_brackets (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    descricao character varying(255) NOT NULL,
    ano_vigencia integer NOT NULL,
    mes_vigencia integer NOT NULL,
    valor_minimo numeric(12,2) NOT NULL,
    valor_maximo numeric(12,2),
    aliquota numeric(5,4) NOT NULL,
    valor_deducao numeric(12,2) DEFAULT 0,
    numero_dependentes integer DEFAULT 0,
    valor_por_dependente numeric(10,2) DEFAULT 0,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_irrf_bracket_aliquota CHECK (((aliquota >= (0)::numeric) AND (aliquota <= (1)::numeric))),
    CONSTRAINT check_irrf_bracket_ano CHECK (((ano_vigencia >= 2020) AND (ano_vigencia <= 2030))),
    CONSTRAINT check_irrf_bracket_dependentes CHECK ((numero_dependentes >= 0)),
    CONSTRAINT check_irrf_bracket_mes CHECK (((mes_vigencia >= 1) AND (mes_vigencia <= 12))),
    CONSTRAINT check_irrf_bracket_valor_dependente CHECK ((valor_por_dependente >= (0)::numeric)),
    CONSTRAINT check_irrf_bracket_valores CHECK (((valor_maximo IS NULL) OR (valor_minimo <= valor_maximo)))
);


ALTER TABLE rh.irrf_brackets OWNER TO postgres;

--
-- Name: TABLE irrf_brackets; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.irrf_brackets IS 'Tabela de faixas do IRRF para c??lculo de imposto de renda';


--
-- Name: COLUMN irrf_brackets.ano_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.ano_vigencia IS 'Ano de vig??ncia da faixa IRRF';


--
-- Name: COLUMN irrf_brackets.mes_vigencia; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.mes_vigencia IS 'M??s de vig??ncia da faixa IRRF';


--
-- Name: COLUMN irrf_brackets.valor_minimo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.valor_minimo IS 'Valor m??nimo da faixa salarial';


--
-- Name: COLUMN irrf_brackets.valor_maximo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.valor_maximo IS 'Valor m??ximo da faixa salarial (NULL = sem limite)';


--
-- Name: COLUMN irrf_brackets.aliquota; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.aliquota IS 'Al??quota do IRRF (0.075 = 7,5%)';


--
-- Name: COLUMN irrf_brackets.valor_deducao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.valor_deducao IS 'Valor a ser deduzido do c??lculo';


--
-- Name: COLUMN irrf_brackets.numero_dependentes; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.numero_dependentes IS 'N??mero de dependentes considerados na faixa';


--
-- Name: COLUMN irrf_brackets.valor_por_dependente; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.irrf_brackets.valor_por_dependente IS 'Valor de dedu????o por dependente';


--
-- Name: job_openings; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.job_openings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    job_request_id uuid,
    position_name character varying(255) NOT NULL,
    department_name character varying(255),
    job_description text NOT NULL,
    requirements text,
    benefits text,
    salary_range character varying(100),
    status character varying(20) DEFAULT 'aberta'::character varying,
    created_by uuid NOT NULL,
    published_at timestamp with time zone,
    closed_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT job_openings_status_check CHECK (((status)::text = ANY ((ARRAY['aberta'::character varying, 'pausada'::character varying, 'fechada'::character varying, 'preenchida'::character varying])::text[])))
);


ALTER TABLE rh.job_openings OWNER TO postgres;

--
-- Name: job_requests; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.job_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    position_name character varying(255) NOT NULL,
    department_name character varying(255),
    job_description text NOT NULL,
    requirements text,
    benefits text,
    salary_range character varying(100),
    urgency_level character varying(20) DEFAULT 'media'::character varying,
    status character varying(20) DEFAULT 'solicitado'::character varying,
    requested_by uuid NOT NULL,
    approved_by uuid,
    approved_at timestamp with time zone,
    expected_start_date date,
    rejection_reason text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT job_requests_status_check CHECK (((status)::text = ANY ((ARRAY['solicitado'::character varying, 'em_analise'::character varying, 'aprovado'::character varying, 'reprovado'::character varying])::text[]))),
    CONSTRAINT job_requests_urgency_level_check CHECK (((urgency_level)::text = ANY ((ARRAY['baixa'::character varying, 'media'::character varying, 'alta'::character varying, 'critica'::character varying])::text[])))
);


ALTER TABLE rh.job_requests OWNER TO postgres;

--
-- Name: medical_agreements; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.medical_agreements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    tipo character varying(50) NOT NULL,
    cnpj character varying(14),
    razao_social character varying(255),
    telefone character varying(20),
    email character varying(255),
    site character varying(255),
    endereco text,
    cidade character varying(100),
    estado character varying(2),
    cep character varying(8),
    contato_responsavel character varying(255),
    telefone_contato character varying(20),
    email_contato character varying(255),
    observacoes text,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT medical_agreements_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['medico'::character varying, 'odontologico'::character varying, 'ambos'::character varying])::text[])))
);


ALTER TABLE rh.medical_agreements OWNER TO postgres;

--
-- Name: TABLE medical_agreements; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.medical_agreements IS 'Convênios médicos e odontológicos disponíveis para os funcionários';


--
-- Name: COLUMN medical_agreements.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_agreements.tipo IS 'Tipo: medico, odontologico, ambos';


--
-- Name: medical_certificate_attachments; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.medical_certificate_attachments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    certificate_id uuid NOT NULL,
    file_name character varying(255) NOT NULL,
    file_url text NOT NULL,
    file_type character varying(50),
    file_size integer,
    uploaded_by uuid,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.medical_certificate_attachments OWNER TO postgres;

--
-- Name: TABLE medical_certificate_attachments; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.medical_certificate_attachments IS 'Anexos dos atestados mÃ©dicos';


--
-- Name: COLUMN medical_certificate_attachments.certificate_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificate_attachments.certificate_id IS 'ID do atestado mÃ©dico';


--
-- Name: COLUMN medical_certificate_attachments.file_name; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificate_attachments.file_name IS 'Nome do arquivo anexado';


--
-- Name: COLUMN medical_certificate_attachments.file_url; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificate_attachments.file_url IS 'URL do arquivo no storage';


--
-- Name: COLUMN medical_certificate_attachments.file_type; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificate_attachments.file_type IS 'Tipo do arquivo (PDF, JPG, etc.)';


--
-- Name: COLUMN medical_certificate_attachments.file_size; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificate_attachments.file_size IS 'Tamanho do arquivo em bytes';


--
-- Name: medical_certificates; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.medical_certificates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    numero_atestado character varying(100),
    data_emissao date NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    dias_afastamento integer NOT NULL,
    cid_codigo character varying(10),
    cid_descricao text,
    observacoes text,
    anexo_url text,
    status character varying(20) DEFAULT 'pendente'::character varying,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    medico_nome character varying(255),
    crm_crmo character varying(50),
    especialidade character varying(255),
    tipo_atestado character varying(50) DEFAULT 'medico'::character varying,
    valor_beneficio numeric(10,2) DEFAULT 0,
    data_aprovacao timestamp with time zone,
    CONSTRAINT medical_certificates_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'em_andamento'::character varying, 'concluido'::character varying])::text[]))),
    CONSTRAINT medical_certificates_tipo_atestado_check CHECK (((tipo_atestado)::text = ANY ((ARRAY['medico'::character varying, 'odontologico'::character varying, 'psicologico'::character varying])::text[])))
);


ALTER TABLE rh.medical_certificates OWNER TO postgres;

--
-- Name: TABLE medical_certificates; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.medical_certificates IS 'Tabela de atestados mÃ©dicos dos funcionÃ¡rios';


--
-- Name: COLUMN medical_certificates.medico_nome; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.medico_nome IS 'Nome do mÃ©dico que emitiu o atestado';


--
-- Name: COLUMN medical_certificates.crm_crmo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.crm_crmo IS 'CRM/CRMO do mÃ©dico';


--
-- Name: COLUMN medical_certificates.especialidade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.especialidade IS 'Especialidade mÃ©dica';


--
-- Name: COLUMN medical_certificates.tipo_atestado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.tipo_atestado IS 'Tipo do atestado: medico, odontologico, psicologico';


--
-- Name: COLUMN medical_certificates.valor_beneficio; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.valor_beneficio IS 'Valor do benefÃ­cio a ser pago';


--
-- Name: COLUMN medical_certificates.data_aprovacao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_certificates.data_aprovacao IS 'Data de aprovaÃ§Ã£o do atestado';


--
-- Name: medical_plan_pricing_history; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.medical_plan_pricing_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    plan_id uuid NOT NULL,
    data_vigencia date NOT NULL,
    valor_titular_anterior numeric(10,2),
    valor_titular_novo numeric(10,2) NOT NULL,
    valor_dependente_anterior numeric(10,2),
    valor_dependente_novo numeric(10,2) NOT NULL,
    valor_familia_anterior numeric(10,2),
    valor_familia_novo numeric(10,2),
    percentual_reajuste numeric(5,2),
    motivo_reajuste text,
    aprovado_por uuid,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.medical_plan_pricing_history OWNER TO postgres;

--
-- Name: TABLE medical_plan_pricing_history; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.medical_plan_pricing_history IS 'Histórico de reajustes de preços dos planos';


--
-- Name: medical_plans; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.medical_plans (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    agreement_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    categoria character varying(50) NOT NULL,
    cobertura text,
    carencia_dias integer DEFAULT 0,
    faixa_etaria_min integer DEFAULT 0,
    faixa_etaria_max integer DEFAULT 99,
    limite_dependentes integer DEFAULT 0,
    valor_titular numeric(10,2) NOT NULL,
    valor_dependente numeric(10,2) NOT NULL,
    valor_familia numeric(10,2),
    desconto_funcionario numeric(5,2) DEFAULT 0,
    desconto_dependente numeric(5,2) DEFAULT 0,
    ativo boolean DEFAULT true,
    data_inicio_vigencia date,
    data_fim_vigencia date,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    entra_no_calculo_folha boolean DEFAULT true NOT NULL,
    tipo_folha character varying(20) DEFAULT 'desconto'::character varying NOT NULL,
    categoria_desconto character varying(50) DEFAULT 'convenio_medico'::character varying NOT NULL,
    CONSTRAINT medical_plans_categoria_check CHECK (((categoria)::text = ANY ((ARRAY['basico'::character varying, 'intermediario'::character varying, 'premium'::character varying, 'executivo'::character varying, 'familia'::character varying, 'individual'::character varying])::text[]))),
    CONSTRAINT medical_plans_categoria_desconto_check CHECK (((categoria_desconto)::text = ANY ((ARRAY['convenio_medico'::character varying, 'convenio_odontologico'::character varying, 'seguro_vida'::character varying, 'outros'::character varying])::text[]))),
    CONSTRAINT medical_plans_tipo_folha_check CHECK (((tipo_folha)::text = ANY ((ARRAY['provento'::character varying, 'desconto'::character varying])::text[])))
);


ALTER TABLE rh.medical_plans OWNER TO postgres;

--
-- Name: TABLE medical_plans; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.medical_plans IS 'Planos oferecidos por cada convênio médico/odontológico';


--
-- Name: COLUMN medical_plans.categoria; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_plans.categoria IS 'Categoria: basico, intermediario, premium, executivo, familia, individual';


--
-- Name: COLUMN medical_plans.entra_no_calculo_folha; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_plans.entra_no_calculo_folha IS 'Se o plano mÃ©dico deve ser incluÃ­do no cÃ¡lculo da folha de pagamento';


--
-- Name: COLUMN medical_plans.tipo_folha; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_plans.tipo_folha IS 'Tipo: provento (benefÃ­cio) ou desconto (desconto do salÃ¡rio)';


--
-- Name: COLUMN medical_plans.categoria_desconto; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.medical_plans.categoria_desconto IS 'Categoria do desconto para agrupamento na folha';


--
-- Name: monthly_benefit_processing; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.monthly_benefit_processing (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    benefit_config_id uuid NOT NULL,
    company_id uuid NOT NULL,
    month_reference integer NOT NULL,
    year_reference integer NOT NULL,
    base_value numeric(10,2),
    work_days integer,
    absence_days integer,
    discount_value numeric(10,2) DEFAULT 0,
    final_value numeric(10,2),
    status character varying(20) DEFAULT 'pending'::character varying,
    processed_at timestamp with time zone,
    validated_at timestamp with time zone,
    processed_by uuid,
    validated_by uuid,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT monthly_benefit_processing_month_reference_check CHECK (((month_reference >= 1) AND (month_reference <= 12))),
    CONSTRAINT monthly_benefit_processing_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'processed'::character varying, 'validated'::character varying, 'rejected'::character varying])::text[])))
);


ALTER TABLE rh.monthly_benefit_processing OWNER TO postgres;

--
-- Name: payroll; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.payroll (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    mes_referencia integer NOT NULL,
    ano_referencia integer NOT NULL,
    salario_base numeric(10,2) NOT NULL,
    horas_trabalhadas numeric(4,2) DEFAULT 0,
    horas_extras numeric(4,2) DEFAULT 0,
    valor_horas_extras numeric(10,2) DEFAULT 0,
    total_vencimentos numeric(10,2) DEFAULT 0,
    total_descontos numeric(10,2) DEFAULT 0,
    salario_liquido numeric(10,2) DEFAULT 0,
    status character varying(20) DEFAULT 'pendente'::character varying,
    data_pagamento date,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    total_beneficios_convenios_medicos numeric(10,2) DEFAULT 0,
    total_descontos_convenios_medicos numeric(10,2) DEFAULT 0,
    total_beneficios_tradicionais numeric(10,2) DEFAULT 0,
    CONSTRAINT payroll_mes_referencia_check CHECK (((mes_referencia >= 1) AND (mes_referencia <= 12))),
    CONSTRAINT payroll_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'processado'::character varying, 'pago'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE rh.payroll OWNER TO postgres;

--
-- Name: COLUMN payroll.total_beneficios_convenios_medicos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll.total_beneficios_convenios_medicos IS 'Total de benefÃ­cios de convÃªnios mÃ©dicos (proventos)';


--
-- Name: COLUMN payroll.total_descontos_convenios_medicos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll.total_descontos_convenios_medicos IS 'Total de descontos de convÃªnios mÃ©dicos';


--
-- Name: COLUMN payroll.total_beneficios_tradicionais; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll.total_beneficios_tradicionais IS 'Total de benefÃ­cios tradicionais (VR, VA, etc.)';


--
-- Name: payroll_config; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.payroll_config (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    descricao character varying(255) NOT NULL,
    ativo boolean DEFAULT true,
    ano_vigencia integer NOT NULL,
    mes_vigencia integer NOT NULL,
    dias_uteis_mes integer DEFAULT 22,
    horas_dia_trabalho numeric(4,2) DEFAULT 8.00,
    percentual_hora_extra numeric(5,4) DEFAULT 0.5000,
    percentual_hora_noturna numeric(5,4) DEFAULT 0.2000,
    percentual_dsr numeric(5,4) DEFAULT 0.0455,
    aplicar_inss boolean DEFAULT true,
    aplicar_irrf boolean DEFAULT true,
    aplicar_fgts boolean DEFAULT true,
    aplicar_vale_transporte boolean DEFAULT true,
    percentual_vale_transporte numeric(5,4) DEFAULT 0.0600,
    aplicar_adicional_noturno boolean DEFAULT true,
    percentual_adicional_noturno numeric(5,4) DEFAULT 0.2000,
    aplicar_periculosidade boolean DEFAULT false,
    percentual_periculosidade numeric(5,4) DEFAULT 0.3000,
    aplicar_insalubridade boolean DEFAULT false,
    grau_insalubridade character varying(20) DEFAULT 'medio'::character varying,
    aplicar_ferias_proporcionais boolean DEFAULT true,
    aplicar_terco_ferias boolean DEFAULT true,
    aplicar_13_salario boolean DEFAULT true,
    desconto_faltas boolean DEFAULT true,
    desconto_atrasos boolean DEFAULT true,
    tolerancia_atraso_minutos integer DEFAULT 5,
    arredondar_centavos boolean DEFAULT true,
    tipo_arredondamento character varying(20) DEFAULT 'matematico'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT payroll_config_ano_vigencia_check CHECK (((ano_vigencia >= 2000) AND (ano_vigencia <= 2100))),
    CONSTRAINT payroll_config_grau_insalubridade_check CHECK (((grau_insalubridade)::text = ANY ((ARRAY['minimo'::character varying, 'medio'::character varying, 'maximo'::character varying])::text[]))),
    CONSTRAINT payroll_config_mes_vigencia_check CHECK (((mes_vigencia >= 1) AND (mes_vigencia <= 12))),
    CONSTRAINT payroll_config_tipo_arredondamento_check CHECK (((tipo_arredondamento)::text = ANY ((ARRAY['matematico'::character varying, 'para_cima'::character varying, 'para_baixo'::character varying])::text[])))
);


ALTER TABLE rh.payroll_config OWNER TO postgres;

--
-- Name: TABLE payroll_config; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.payroll_config IS 'ConfiguraÃ§Ãµes especÃ­ficas para cÃ¡lculo de folha de pagamento';


--
-- Name: COLUMN payroll_config.dias_uteis_mes; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.dias_uteis_mes IS 'NÃºmero de dias Ãºteis no mÃªs (padrÃ£o 22)';


--
-- Name: COLUMN payroll_config.horas_dia_trabalho; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.horas_dia_trabalho IS 'Horas de trabalho por dia (padrÃ£o 8h)';


--
-- Name: COLUMN payroll_config.percentual_hora_extra; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.percentual_hora_extra IS 'Percentual de hora extra (padrÃ£o 50%)';


--
-- Name: COLUMN payroll_config.percentual_hora_noturna; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.percentual_hora_noturna IS 'Percentual de hora noturna (padrÃ£o 20%)';


--
-- Name: COLUMN payroll_config.percentual_dsr; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.percentual_dsr IS 'Percentual de DSR (1/22 = 4.55%)';


--
-- Name: COLUMN payroll_config.grau_insalubridade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.grau_insalubridade IS 'Grau de insalubridade: minimo, medio, maximo';


--
-- Name: COLUMN payroll_config.tolerancia_atraso_minutos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.tolerancia_atraso_minutos IS 'TolerÃ¢ncia para atrasos em minutos';


--
-- Name: COLUMN payroll_config.tipo_arredondamento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_config.tipo_arredondamento IS 'Tipo de arredondamento: matematico, para_cima, para_baixo';


--
-- Name: payroll_events; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.payroll_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    payroll_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    rubrica_id uuid NOT NULL,
    codigo_rubrica character varying(20) NOT NULL,
    descricao_rubrica character varying(255) NOT NULL,
    tipo_rubrica character varying(20) NOT NULL,
    quantidade numeric(10,4) DEFAULT 1.0,
    valor_unitario numeric(10,2) DEFAULT 0.00,
    valor_total numeric(10,2) DEFAULT 0.00 NOT NULL,
    percentual numeric(5,4) DEFAULT 0.0000,
    mes_referencia integer NOT NULL,
    ano_referencia integer NOT NULL,
    calculado_automaticamente boolean DEFAULT true,
    origem_evento character varying(50) DEFAULT 'sistema'::character varying,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT payroll_events_ano_referencia_check CHECK (((ano_referencia >= 2000) AND (ano_referencia <= 2100))),
    CONSTRAINT payroll_events_mes_referencia_check CHECK (((mes_referencia >= 1) AND (mes_referencia <= 12))),
    CONSTRAINT payroll_events_tipo_rubrica_check CHECK (((tipo_rubrica)::text = ANY ((ARRAY['provento'::character varying, 'desconto'::character varying, 'base_calculo'::character varying, 'informacao'::character varying])::text[])))
);


ALTER TABLE rh.payroll_events OWNER TO postgres;

--
-- Name: TABLE payroll_events; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.payroll_events IS 'Eventos individuais de cada funcionÃ¡rio por perÃ­odo de folha';


--
-- Name: COLUMN payroll_events.payroll_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.payroll_id IS 'ReferÃªncia Ã  folha de pagamento';


--
-- Name: COLUMN payroll_events.rubrica_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.rubrica_id IS 'Rubrica que originou o evento';


--
-- Name: COLUMN payroll_events.tipo_rubrica; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.tipo_rubrica IS 'Tipo da rubrica: provento, desconto, base_calculo, informacao';


--
-- Name: COLUMN payroll_events.quantidade; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.quantidade IS 'Quantidade para cÃ¡lculo (horas, dias, etc.)';


--
-- Name: COLUMN payroll_events.valor_unitario; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.valor_unitario IS 'Valor por unidade';


--
-- Name: COLUMN payroll_events.valor_total; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.valor_total IS 'Valor total calculado';


--
-- Name: COLUMN payroll_events.percentual; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.percentual IS 'Percentual aplicado (para rubricas percentuais)';


--
-- Name: COLUMN payroll_events.calculado_automaticamente; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.calculado_automaticamente IS 'Se o evento foi calculado automaticamente pelo sistema';


--
-- Name: COLUMN payroll_events.origem_evento; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.payroll_events.origem_evento IS 'Origem do evento: sistema, manual, importado';


--
-- Name: periodic_exams; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.periodic_exams (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    tipo_exame character varying(30) NOT NULL,
    data_agendamento date NOT NULL,
    data_realizacao date,
    data_vencimento date NOT NULL,
    status character varying(20) DEFAULT 'agendado'::character varying NOT NULL,
    medico_responsavel character varying(255),
    clinica_local character varying(255),
    observacoes text,
    resultado character varying(20),
    restricoes text,
    anexos text[],
    custo numeric(10,2),
    pago boolean DEFAULT false,
    data_pagamento date,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT periodic_exams_resultado_check CHECK (((resultado)::text = ANY ((ARRAY['apto'::character varying, 'inapto'::character varying, 'apto_com_restricoes'::character varying, 'pendente'::character varying])::text[]))),
    CONSTRAINT periodic_exams_status_check CHECK (((status)::text = ANY ((ARRAY['agendado'::character varying, 'realizado'::character varying, 'vencido'::character varying, 'cancelado'::character varying, 'reagendado'::character varying])::text[]))),
    CONSTRAINT periodic_exams_tipo_exame_check CHECK (((tipo_exame)::text = ANY ((ARRAY['admissional'::character varying, 'periodico'::character varying, 'demissional'::character varying, 'retorno_trabalho'::character varying, 'mudanca_funcao'::character varying, 'ambiental'::character varying])::text[])))
);


ALTER TABLE rh.periodic_exams OWNER TO postgres;

--
-- Name: TABLE periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.periodic_exams IS 'Dados de exemplo inseridos para teste do sistema de exames periÃ³dicos';


--
-- Name: COLUMN periodic_exams.tipo_exame; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.periodic_exams.tipo_exame IS 'Tipo: admissional, periodico, demissional, retorno_trabalho, mudanca_funcao, ambiental';


--
-- Name: COLUMN periodic_exams.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.periodic_exams.status IS 'Status: agendado, realizado, vencido, cancelado, reagendado';


--
-- Name: COLUMN periodic_exams.resultado; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.periodic_exams.resultado IS 'Resultado: apto, inapto, apto_com_restricoes, pendente';


--
-- Name: COLUMN periodic_exams.anexos; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.periodic_exams.anexos IS 'Array de URLs dos arquivos anexados (laudos, atestados, etc.)';


--
-- Name: COLUMN periodic_exams.custo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.periodic_exams.custo IS 'Custo do exame para controle financeiro';


--
-- Name: positions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.positions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    nivel_hierarquico integer DEFAULT 1,
    salario_minimo numeric(10,2),
    salario_maximo numeric(10,2),
    carga_horaria integer DEFAULT 40,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.positions OWNER TO postgres;

--
-- Name: reimbursement_requests; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.reimbursement_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    tipo_despesa character varying(50) NOT NULL,
    valor_solicitado numeric(10,2) NOT NULL,
    data_despesa date NOT NULL,
    descricao text NOT NULL,
    comprovante_url text,
    status character varying(20) DEFAULT 'pendente'::character varying,
    solicitado_por uuid,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT reimbursement_requests_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying])::text[]))),
    CONSTRAINT reimbursement_requests_tipo_despesa_check CHECK (((tipo_despesa)::text = ANY ((ARRAY['alimentacao'::character varying, 'transporte'::character varying, 'hospedagem'::character varying, 'combustivel'::character varying, 'outros'::character varying])::text[])))
);


ALTER TABLE rh.reimbursement_requests OWNER TO postgres;

--
-- Name: reports; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.reports (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    tipo character varying(50) NOT NULL,
    periodo character varying(20),
    status character varying(20) DEFAULT 'gerado'::character varying NOT NULL,
    data_geracao timestamp with time zone DEFAULT now(),
    arquivo_url text,
    parametros jsonb,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT reports_status_check CHECK (((status)::text = ANY ((ARRAY['gerado'::character varying, 'processando'::character varying, 'erro'::character varying])::text[])))
);


ALTER TABLE rh.reports OWNER TO postgres;

--
-- Name: TABLE reports; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.reports IS 'Tabela de relatÃ³rios gerados';


--
-- Name: COLUMN reports.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.reports.tipo IS 'Tipo do relatÃ³rio (ex: funcionarios, folha, horas, ferias)';


--
-- Name: COLUMN reports.periodo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.reports.periodo IS 'PerÃ­odo do relatÃ³rio (ex: 2024/01)';


--
-- Name: COLUMN reports.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.reports.status IS 'Status do relatÃ³rio: gerado, processando, erro';


--
-- Name: COLUMN reports.arquivo_url; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.reports.arquivo_url IS 'URL do arquivo do relatÃ³rio gerado';


--
-- Name: COLUMN reports.parametros; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.reports.parametros IS 'ParÃ¢metros utilizados para gerar o relatÃ³rio (JSON)';


--
-- Name: rubricas; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.rubricas (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    codigo character varying(20) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    tipo character varying(50) NOT NULL,
    categoria character varying(100),
    natureza character varying(50) DEFAULT 'normal'::character varying,
    calculo_automatico boolean DEFAULT false,
    formula_calculo text,
    valor_fixo numeric(12,2),
    percentual numeric(5,4),
    base_calculo character varying(50) DEFAULT 'salario_base'::character varying,
    incidencia_ir boolean DEFAULT false,
    incidencia_inss boolean DEFAULT false,
    incidencia_fgts boolean DEFAULT false,
    incidencia_contribuicao_sindical boolean DEFAULT false,
    ordem_exibicao integer DEFAULT 0,
    obrigatorio boolean DEFAULT false,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_rubrica_percentual CHECK (((percentual IS NULL) OR ((percentual >= (0)::numeric) AND (percentual <= (100)::numeric)))),
    CONSTRAINT check_rubrica_valor_formula CHECK ((((valor_fixo IS NOT NULL) AND (formula_calculo IS NULL)) OR ((valor_fixo IS NULL) AND (formula_calculo IS NOT NULL)) OR ((valor_fixo IS NULL) AND (formula_calculo IS NULL)))),
    CONSTRAINT rubricas_natureza_check CHECK (((natureza)::text = ANY ((ARRAY['normal'::character varying, 'eventual'::character varying, 'fixo'::character varying, 'variavel'::character varying])::text[]))),
    CONSTRAINT rubricas_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['provento'::character varying, 'desconto'::character varying, 'base_calculo'::character varying, 'informacao'::character varying])::text[])))
);


ALTER TABLE rh.rubricas OWNER TO postgres;

--
-- Name: TABLE rubricas; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.rubricas IS 'Tabela de rubricas para folha de pagamento';


--
-- Name: COLUMN rubricas.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.tipo IS 'Tipo da rubrica: provento, desconto, base_calculo, informacao';


--
-- Name: COLUMN rubricas.natureza; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.natureza IS 'Natureza da rubrica: normal, eventual, fixo, variavel';


--
-- Name: COLUMN rubricas.formula_calculo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.formula_calculo IS 'F??rmula para c??lculo autom??tico da rubrica';


--
-- Name: COLUMN rubricas.base_calculo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.base_calculo IS 'Base para c??lculo: salario_base, salario_familia, etc.';


--
-- Name: COLUMN rubricas.incidencia_ir; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.incidencia_ir IS 'Se a rubrica incide no c??lculo do IR';


--
-- Name: COLUMN rubricas.incidencia_inss; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.incidencia_inss IS 'Se a rubrica incide no c??lculo do INSS';


--
-- Name: COLUMN rubricas.incidencia_fgts; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.rubricas.incidencia_fgts IS 'Se a rubrica incide no c??lculo do FGTS';


--
-- Name: schedule_planning; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.schedule_planning (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    periodo_inicio date NOT NULL,
    periodo_fim date NOT NULL,
    status character varying(20) DEFAULT 'rascunho'::character varying NOT NULL,
    total_funcionarios integer DEFAULT 0,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_schedule_planning_periodo CHECK ((periodo_fim >= periodo_inicio)),
    CONSTRAINT schedule_planning_status_check CHECK (((status)::text = ANY ((ARRAY['rascunho'::character varying, 'aprovado'::character varying, 'ativo'::character varying, 'finalizado'::character varying])::text[])))
);


ALTER TABLE rh.schedule_planning OWNER TO postgres;

--
-- Name: TABLE schedule_planning; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.schedule_planning IS 'Tabela de programaÃ§Ã£o de escalas de trabalho';


--
-- Name: COLUMN schedule_planning.nome; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.schedule_planning.nome IS 'Nome da programaÃ§Ã£o de escala';


--
-- Name: COLUMN schedule_planning.periodo_inicio; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.schedule_planning.periodo_inicio IS 'Data de inÃ­cio do perÃ­odo da escala';


--
-- Name: COLUMN schedule_planning.periodo_fim; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.schedule_planning.periodo_fim IS 'Data de fim do perÃ­odo da escala';


--
-- Name: COLUMN schedule_planning.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.schedule_planning.status IS 'Status da programaÃ§Ã£o: rascunho, aprovado, ativo, finalizado';


--
-- Name: COLUMN schedule_planning.total_funcionarios; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.schedule_planning.total_funcionarios IS 'Total de funcionÃ¡rios incluÃ­dos na programaÃ§Ã£o';


--
-- Name: selection_processes; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.selection_processes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    job_opening_id uuid NOT NULL,
    candidate_id uuid NOT NULL,
    current_stage character varying(50) NOT NULL,
    status character varying(20) DEFAULT 'ativo'::character varying,
    started_at timestamp with time zone DEFAULT now(),
    completed_at timestamp with time zone,
    created_by uuid NOT NULL,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT selection_processes_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'pausado'::character varying, 'finalizado'::character varying, 'cancelado'::character varying])::text[])))
);


ALTER TABLE rh.selection_processes OWNER TO postgres;

--
-- Name: selection_stages; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.selection_stages (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    selection_process_id uuid NOT NULL,
    stage_name character varying(100) NOT NULL,
    stage_type character varying(50) NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    scheduled_at timestamp with time zone,
    completed_at timestamp with time zone,
    interviewer_id uuid,
    score numeric(3,1),
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT selection_stages_stage_type_check CHECK (((stage_type)::text = ANY ((ARRAY['triagem'::character varying, 'entrevista_telefonica'::character varying, 'entrevista_presencial'::character varying, 'teste_tecnico'::character varying, 'entrevista_final'::character varying, 'aprovacao'::character varying])::text[]))),
    CONSTRAINT selection_stages_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'em_andamento'::character varying, 'aprovado'::character varying, 'reprovado'::character varying, 'desistiu'::character varying])::text[])))
);


ALTER TABLE rh.selection_stages OWNER TO postgres;

--
-- Name: signature_notifications; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.signature_notifications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    signature_id uuid NOT NULL,
    notification_type character varying(50) NOT NULL,
    sent_at timestamp with time zone DEFAULT now(),
    sent_via character varying(20) NOT NULL,
    status character varying(20) DEFAULT 'sent'::character varying NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT signature_notifications_notification_type_check CHECK (((notification_type)::text = ANY ((ARRAY['initial'::character varying, 'reminder'::character varying, 'expiration_warning'::character varying, 'expired'::character varying])::text[]))),
    CONSTRAINT signature_notifications_sent_via_check CHECK (((sent_via)::text = ANY ((ARRAY['email'::character varying, 'sms'::character varying, 'system'::character varying])::text[]))),
    CONSTRAINT signature_notifications_status_check CHECK (((status)::text = ANY ((ARRAY['sent'::character varying, 'delivered'::character varying, 'failed'::character varying])::text[])))
);


ALTER TABLE rh.signature_notifications OWNER TO postgres;

--
-- Name: TABLE signature_notifications; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.signature_notifications IS 'HistÃ³rico de notificaÃ§Ãµes enviadas para assinatura de ponto';


--
-- Name: talent_pool; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.talent_pool (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    candidate_id uuid NOT NULL,
    category character varying(50) NOT NULL,
    skills text[],
    experience_level character varying(20),
    availability character varying(20) DEFAULT 'disponivel'::character varying,
    notes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT talent_pool_availability_check CHECK (((availability)::text = ANY ((ARRAY['disponivel'::character varying, 'interessado'::character varying, 'indisponivel'::character varying])::text[]))),
    CONSTRAINT talent_pool_experience_level_check CHECK (((experience_level)::text = ANY ((ARRAY['junior'::character varying, 'pleno'::character varying, 'senior'::character varying, 'especialista'::character varying])::text[])))
);


ALTER TABLE rh.talent_pool OWNER TO postgres;

--
-- Name: time_bank; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.time_bank (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    data_registro date NOT NULL,
    tipo_hora character varying(20) NOT NULL,
    quantidade_horas numeric(5,2) NOT NULL,
    motivo text,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    data_expiracao date,
    utilizado_em date,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT time_bank_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'negado'::character varying, 'utilizado'::character varying, 'expirado'::character varying])::text[]))),
    CONSTRAINT time_bank_tipo_hora_check CHECK (((tipo_hora)::text = ANY ((ARRAY['extra'::character varying, 'compensatoria'::character varying, 'sobreaviso'::character varying, 'adicional_noturno'::character varying])::text[])))
);


ALTER TABLE rh.time_bank OWNER TO postgres;

--
-- Name: TABLE time_bank; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.time_bank IS 'Banco de horas dos funcionÃ¡rios - controle de horas extras e compensatÃ³rias';


--
-- Name: COLUMN time_bank.tipo_hora; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_bank.tipo_hora IS 'Tipo da hora: extra, compensatoria, sobreaviso, adicional_noturno';


--
-- Name: COLUMN time_bank.quantidade_horas; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_bank.quantidade_horas IS 'Quantidade de horas em formato decimal (ex: 2.5 = 2h30min)';


--
-- Name: COLUMN time_bank.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_bank.status IS 'Status: pendente, aprovado, negado, utilizado, expirado';


--
-- Name: COLUMN time_bank.data_expiracao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_bank.data_expiracao IS 'Data limite para utilizaÃ§Ã£o das horas';


--
-- Name: COLUMN time_bank.utilizado_em; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_bank.utilizado_em IS 'Data em que as horas foram utilizadas';


--
-- Name: time_record_signatures; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.time_record_signatures (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    month_year character varying(7) NOT NULL,
    signature_data jsonb,
    signature_timestamp timestamp with time zone,
    ip_address inet,
    user_agent text,
    status character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    manager_approval_required boolean DEFAULT true NOT NULL,
    manager_approved_by uuid,
    manager_approved_at timestamp with time zone,
    rejection_reason text,
    expires_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT time_record_signatures_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'signed'::character varying, 'expired'::character varying, 'rejected'::character varying, 'approved'::character varying])::text[])))
);


ALTER TABLE rh.time_record_signatures OWNER TO postgres;

--
-- Name: TABLE time_record_signatures; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.time_record_signatures IS 'Assinaturas de registros de ponto mensais dos funcionÃ¡rios';


--
-- Name: COLUMN time_record_signatures.month_year; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signatures.month_year IS 'MÃªs e ano no formato YYYY-MM';


--
-- Name: COLUMN time_record_signatures.signature_data; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signatures.signature_data IS 'Dados da assinatura digital (coordenadas, timestamp, etc.)';


--
-- Name: COLUMN time_record_signatures.status; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signatures.status IS 'Status: pending, signed, expired, rejected, approved';


--
-- Name: COLUMN time_record_signatures.expires_at; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.time_record_signatures.expires_at IS 'Data e hora de expiraÃ§Ã£o da assinatura';


--
-- Name: time_records; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.time_records (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    data_registro date NOT NULL,
    entrada time without time zone,
    saida time without time zone,
    entrada_almoco time without time zone,
    saida_almoco time without time zone,
    horas_trabalhadas numeric(4,2) DEFAULT 0,
    horas_extras numeric(4,2) DEFAULT 0,
    horas_faltas numeric(4,2) DEFAULT 0,
    status character varying(20) DEFAULT 'pendente'::character varying,
    observacoes text,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    entrada_extra1 time without time zone,
    saida_extra1 time without time zone,
    CONSTRAINT time_records_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'corrigido'::character varying])::text[])))
);


ALTER TABLE rh.time_records OWNER TO postgres;

--
-- Name: training_attendance; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_attendance (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    data_treinamento date NOT NULL,
    hora_entrada time without time zone,
    hora_saida time without time zone,
    presenca character varying(50) DEFAULT 'ausente'::character varying NOT NULL,
    percentual_presenca numeric(5,2) DEFAULT 0,
    observacoes text,
    registrado_por uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_attendance OWNER TO postgres;

--
-- Name: training_certificates; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_certificates (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    numero_certificado character varying(100) NOT NULL,
    data_emissao date DEFAULT CURRENT_DATE NOT NULL,
    data_validade date,
    status character varying(50) DEFAULT 'valido'::character varying NOT NULL,
    nota_final numeric(5,2),
    percentual_presenca_final numeric(5,2),
    aprovado boolean DEFAULT false NOT NULL,
    observacoes text,
    template_certificado text,
    arquivo_certificado text,
    emitido_por uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_certificates OWNER TO postgres;

--
-- Name: training_enrollments; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_enrollments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    data_inscricao timestamp with time zone DEFAULT now(),
    status character varying(50) DEFAULT 'inscrito'::character varying NOT NULL,
    justificativa_cancelamento text,
    observacoes text,
    inscrito_por uuid,
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_enrollments OWNER TO postgres;

--
-- Name: training_evaluations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_evaluations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    nota_instrutor numeric(3,1),
    nota_conteudo numeric(3,1),
    nota_metodologia numeric(3,1),
    nota_recursos numeric(3,1),
    nota_geral numeric(3,1),
    comentarios text,
    sugestoes text,
    recomendaria boolean,
    data_avaliacao timestamp with time zone DEFAULT now(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT training_evaluations_nota_conteudo_check CHECK (((nota_conteudo >= (0)::numeric) AND (nota_conteudo <= (10)::numeric))),
    CONSTRAINT training_evaluations_nota_geral_check CHECK (((nota_geral >= (0)::numeric) AND (nota_geral <= (10)::numeric))),
    CONSTRAINT training_evaluations_nota_instrutor_check CHECK (((nota_instrutor >= (0)::numeric) AND (nota_instrutor <= (10)::numeric))),
    CONSTRAINT training_evaluations_nota_metodologia_check CHECK (((nota_metodologia >= (0)::numeric) AND (nota_metodologia <= (10)::numeric))),
    CONSTRAINT training_evaluations_nota_recursos_check CHECK (((nota_recursos >= (0)::numeric) AND (nota_recursos <= (10)::numeric)))
);


ALTER TABLE rh.training_evaluations OWNER TO postgres;

--
-- Name: training_notification_history; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_notification_history (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid,
    notification_type_id uuid NOT NULL,
    user_id uuid,
    employee_id uuid,
    titulo text NOT NULL,
    mensagem text NOT NULL,
    data_envio timestamp with time zone NOT NULL,
    status character varying(50) NOT NULL,
    metodo_envio character varying(50) NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_notification_history OWNER TO postgres;

--
-- Name: training_notification_queue; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_notification_queue (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid,
    notification_type_id uuid NOT NULL,
    user_id uuid,
    employee_id uuid,
    titulo text NOT NULL,
    mensagem text NOT NULL,
    data_agendamento timestamp with time zone NOT NULL,
    status character varying(50) DEFAULT 'pendente'::character varying NOT NULL,
    tentativas integer DEFAULT 0,
    max_tentativas integer DEFAULT 3,
    data_envio timestamp with time zone,
    erro_mensagem text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_notification_queue OWNER TO postgres;

--
-- Name: training_notification_rules; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_notification_rules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    training_id uuid,
    notification_type_id uuid NOT NULL,
    target_audience character varying(50) DEFAULT 'inscritos'::character varying NOT NULL,
    dias_antecedencia integer DEFAULT 0 NOT NULL,
    is_enabled boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_notification_rules OWNER TO postgres;

--
-- Name: training_notification_types; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_notification_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    tipo character varying(100) NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    template_titulo text NOT NULL,
    template_mensagem text NOT NULL,
    dias_antecedencia integer DEFAULT 0,
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_notification_types OWNER TO postgres;

--
-- Name: training_settings; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.training_settings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    notification_enabled boolean DEFAULT true,
    email_notifications boolean DEFAULT true,
    push_notifications boolean DEFAULT false,
    reminder_days_before integer DEFAULT 3,
    reminder_days_after integer DEFAULT 1,
    auto_enrollment boolean DEFAULT false,
    require_approval boolean DEFAULT true,
    max_participants integer DEFAULT 50,
    min_attendance_percentage integer DEFAULT 80,
    certificate_auto_generate boolean DEFAULT true,
    certificate_validity_days integer DEFAULT 365,
    training_duration_default numeric(4,2) DEFAULT 8.0,
    evaluation_required boolean DEFAULT true,
    feedback_required boolean DEFAULT true,
    auto_archive_days integer DEFAULT 90,
    allow_self_enrollment boolean DEFAULT true,
    allow_cancellation boolean DEFAULT true,
    cancellation_deadline_hours integer DEFAULT 24,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.training_settings OWNER TO postgres;

--
-- Name: trainings; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.trainings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    tipo_treinamento character varying(100) NOT NULL,
    categoria character varying(100),
    carga_horaria integer NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    data_limite_inscricao date,
    vagas_totais integer,
    vagas_disponiveis integer,
    local character varying(255),
    modalidade character varying(50) DEFAULT 'presencial'::character varying NOT NULL,
    instrutor character varying(255),
    instrutor_email character varying(255),
    instrutor_telefone character varying(20),
    custo_por_participante numeric(10,2) DEFAULT 0,
    requisitos text,
    objetivos text,
    conteudo_programatico text,
    metodologia text,
    recursos_necessarios text,
    status character varying(50) DEFAULT 'planejado'::character varying NOT NULL,
    aprovado_por uuid,
    data_aprovacao timestamp with time zone,
    observacoes text,
    anexos text[],
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.trainings OWNER TO postgres;

--
-- Name: union_contributions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.union_contributions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    union_id uuid NOT NULL,
    tipo_contribuicao character varying(50) NOT NULL,
    mes_referencia character varying(7) NOT NULL,
    valor numeric(10,2) NOT NULL,
    desconto_folha boolean DEFAULT false,
    data_vencimento date,
    data_pagamento date,
    status character varying(20) DEFAULT 'pendente'::character varying NOT NULL,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT union_contributions_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'pago'::character varying, 'atrasado'::character varying, 'isento'::character varying, 'cancelado'::character varying])::text[]))),
    CONSTRAINT union_contributions_tipo_contribuicao_check CHECK (((tipo_contribuicao)::text = ANY ((ARRAY['mensalidade'::character varying, 'contribuicao_assistencial'::character varying, 'contribuicao_confederativa'::character varying, 'taxa_negociacao'::character varying, 'outras'::character varying])::text[])))
);


ALTER TABLE rh.union_contributions OWNER TO postgres;

--
-- Name: TABLE union_contributions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.union_contributions IS 'Contribuições e mensalidades sindicais';


--
-- Name: COLUMN union_contributions.tipo_contribuicao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.union_contributions.tipo_contribuicao IS 'Tipo: mensalidade, contribuicao_assistencial, contribuicao_confederativa, taxa_negociacao, outras';


--
-- Name: union_negotiations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.union_negotiations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    union_id uuid NOT NULL,
    tipo_negociacao character varying(50) NOT NULL,
    titulo character varying(255) NOT NULL,
    descricao text,
    data_inicio date NOT NULL,
    data_fim date,
    status character varying(20) DEFAULT 'em_andamento'::character varying NOT NULL,
    responsavel_empresa character varying(255),
    responsavel_sindicato character varying(255),
    resultado text,
    valor_proposto numeric(10,2),
    valor_aceito numeric(10,2),
    percentual_proposto numeric(5,2),
    percentual_aceito numeric(5,2),
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT union_negotiations_status_check CHECK (((status)::text = ANY ((ARRAY['agendada'::character varying, 'em_andamento'::character varying, 'concluida'::character varying, 'suspensa'::character varying, 'cancelada'::character varying])::text[]))),
    CONSTRAINT union_negotiations_tipo_negociacao_check CHECK (((tipo_negociacao)::text = ANY ((ARRAY['salarial'::character varying, 'beneficios'::character varying, 'condicoes_trabalho'::character varying, 'seguranca'::character varying, 'outras'::character varying])::text[])))
);


ALTER TABLE rh.union_negotiations OWNER TO postgres;

--
-- Name: TABLE union_negotiations; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.union_negotiations IS 'Negociações e reuniões sindicais';


--
-- Name: COLUMN union_negotiations.tipo_negociacao; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.union_negotiations.tipo_negociacao IS 'Tipo: salarial, beneficios, condicoes_trabalho, seguranca, outras';


--
-- Name: union_representatives; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.union_representatives (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    employee_id uuid NOT NULL,
    union_id uuid NOT NULL,
    cargo character varying(100) NOT NULL,
    data_inicio date NOT NULL,
    data_fim date,
    status character varying(20) DEFAULT 'ativo'::character varying NOT NULL,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT union_representatives_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying, 'suspenso'::character varying])::text[])))
);


ALTER TABLE rh.union_representatives OWNER TO postgres;

--
-- Name: TABLE union_representatives; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.union_representatives IS 'Representantes sindicais na empresa';


--
-- Name: unions; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.unions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    sigla character varying(50),
    tipo character varying(50) NOT NULL,
    categoria character varying(100),
    cnpj character varying(14),
    inscricao_municipal character varying(50),
    inscricao_estadual character varying(50),
    razao_social character varying(255),
    telefone character varying(20),
    email character varying(255),
    site character varying(255),
    endereco text,
    cidade character varying(100),
    estado character varying(2),
    cep character varying(8),
    presidente character varying(255),
    telefone_presidente character varying(20),
    email_presidente character varying(255),
    data_fundacao date,
    numero_registro character varying(50),
    observacoes text,
    ativo boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT unions_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['patronal'::character varying, 'trabalhadores'::character varying, 'categoria'::character varying, 'profissional'::character varying, 'misto'::character varying])::text[])))
);


ALTER TABLE rh.unions OWNER TO postgres;

--
-- Name: TABLE unions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.unions IS 'Sindicatos patronais e de trabalhadores';


--
-- Name: COLUMN unions.tipo; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.unions.tipo IS 'Tipo: patronal, trabalhadores, categoria, profissional, misto';


--
-- Name: units; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.units (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    codigo character varying(20),
    responsavel_id uuid,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    cost_center_id uuid
);


ALTER TABLE rh.units OWNER TO postgres;

--
-- Name: COLUMN units.cost_center_id; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.units.cost_center_id IS 'Centro de custo associado ao departamento';


--
-- Name: vacation_entitlements; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.vacation_entitlements (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    ano_aquisitivo integer NOT NULL,
    data_inicio_periodo date NOT NULL,
    data_fim_periodo date NOT NULL,
    dias_disponiveis integer DEFAULT 30 NOT NULL,
    dias_gozados integer DEFAULT 0,
    dias_restantes integer GENERATED ALWAYS AS ((dias_disponiveis - dias_gozados)) STORED,
    status character varying(20) DEFAULT 'ativo'::character varying,
    data_vencimento date,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_entitlement_days_gozados CHECK ((dias_gozados <= dias_disponiveis)),
    CONSTRAINT check_entitlement_period_dates CHECK ((data_fim_periodo >= data_inicio_periodo)),
    CONSTRAINT vacation_entitlements_ano_aquisitivo_check CHECK (((ano_aquisitivo >= 2000) AND (ano_aquisitivo <= 2100))),
    CONSTRAINT vacation_entitlements_dias_disponiveis_check CHECK (((dias_disponiveis >= 0) AND (dias_disponiveis <= 30))),
    CONSTRAINT vacation_entitlements_dias_gozados_check CHECK ((dias_gozados >= 0)),
    CONSTRAINT vacation_entitlements_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'vencido'::character varying, 'gozado'::character varying, 'parcialmente_gozado'::character varying])::text[])))
);


ALTER TABLE rh.vacation_entitlements OWNER TO postgres;

--
-- Name: vacation_periods; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.vacation_periods (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    vacation_id uuid NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    dias_ferias integer NOT NULL,
    dias_abono integer DEFAULT 0,
    periodo_numero integer NOT NULL,
    observacoes text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT check_vacation_period_dates CHECK ((data_fim >= data_inicio)),
    CONSTRAINT check_vacation_period_days CHECK ((dias_ferias = ((data_fim - data_inicio) + 1))),
    CONSTRAINT vacation_periods_dias_abono_check CHECK (((dias_abono >= 0) AND (dias_abono <= 10))),
    CONSTRAINT vacation_periods_dias_ferias_check CHECK ((dias_ferias > 0)),
    CONSTRAINT vacation_periods_periodo_numero_check CHECK (((periodo_numero >= 1) AND (periodo_numero <= 3)))
);


ALTER TABLE rh.vacation_periods OWNER TO postgres;

--
-- Name: vacations; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.vacations (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    employee_id uuid NOT NULL,
    company_id uuid NOT NULL,
    tipo character varying(50) NOT NULL,
    data_inicio date NOT NULL,
    data_fim date NOT NULL,
    dias_solicitados integer NOT NULL,
    status character varying(20) DEFAULT 'pendente'::character varying,
    observacoes text,
    anexos text[],
    solicitado_por uuid,
    aprovado_por uuid,
    aprovado_em timestamp with time zone,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    CONSTRAINT vacations_status_check CHECK (((status)::text = ANY ((ARRAY['pendente'::character varying, 'aprovado'::character varying, 'rejeitado'::character varying, 'em_andamento'::character varying, 'concluido'::character varying])::text[]))),
    CONSTRAINT vacations_tipo_check CHECK (((tipo)::text = ANY ((ARRAY['ferias'::character varying, 'licenca_medica'::character varying, 'licenca_maternidade'::character varying, 'licenca_paternidade'::character varying, 'afastamento'::character varying, 'outros'::character varying])::text[])))
);


ALTER TABLE rh.vacations OWNER TO postgres;

--
-- Name: work_schedules; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.work_schedules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    descricao text,
    carga_horaria_semanal integer DEFAULT 40,
    dias_trabalho integer[] DEFAULT ARRAY[1, 2, 3, 4, 5],
    horario_inicio time without time zone DEFAULT '08:00:00'::time without time zone,
    horario_fim time without time zone DEFAULT '17:00:00'::time without time zone,
    intervalo_almoco integer DEFAULT 60,
    tolerancia_entrada integer DEFAULT 15,
    tolerancia_saida integer DEFAULT 15,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE rh.work_schedules OWNER TO postgres;

--
-- Name: work_shifts; Type: TABLE; Schema: rh; Owner: postgres
--

CREATE TABLE rh.work_shifts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    company_id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    codigo character varying(50),
    descricao text,
    hora_inicio time without time zone NOT NULL,
    hora_fim time without time zone NOT NULL,
    intervalo_inicio time without time zone,
    intervalo_fim time without time zone,
    horas_diarias numeric(4,2) DEFAULT 8.0 NOT NULL,
    dias_semana integer[] DEFAULT '{1,2,3,4,5}'::integer[],
    tipo_turno character varying(50) DEFAULT 'normal'::character varying,
    tolerancia_entrada integer DEFAULT 0,
    tolerancia_saida integer DEFAULT 0,
    status character varying(20) DEFAULT 'ativo'::character varying,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    tipo_escala character varying(50) DEFAULT 'fixa'::character varying,
    dias_trabalho integer DEFAULT 5,
    dias_folga integer DEFAULT 2,
    ciclo_dias integer DEFAULT 7,
    regras_clt jsonb DEFAULT '{}'::jsonb,
    template_escala boolean DEFAULT false,
    CONSTRAINT work_shifts_status_check CHECK (((status)::text = ANY ((ARRAY['ativo'::character varying, 'inativo'::character varying])::text[])))
);


ALTER TABLE rh.work_shifts OWNER TO postgres;

--
-- Name: TABLE work_shifts; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON TABLE rh.work_shifts IS 'Tabela de turnos de trabalho';


--
-- Name: COLUMN work_shifts.dias_semana; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.work_shifts.dias_semana IS 'Array com dias da semana: 1=Segunda, 2=Ter??a, 3=Quarta, 4=Quinta, 5=Sexta, 6=S??bado, 7=Domingo';


--
-- Name: COLUMN work_shifts.tolerancia_entrada; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.work_shifts.tolerancia_entrada IS 'Toler??ncia em minutos para entrada';


--
-- Name: COLUMN work_shifts.tolerancia_saida; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON COLUMN rh.work_shifts.tolerancia_saida IS 'Toler??ncia em minutos para sa??da';


--
-- Name: buckets; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets (
    id text NOT NULL,
    name text NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[],
    owner_id text,
    type storage.buckettype DEFAULT 'STANDARD'::storage.buckettype NOT NULL
);


ALTER TABLE storage.buckets OWNER TO supabase_storage_admin;

--
-- Name: COLUMN buckets.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.buckets.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: buckets_analytics; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets_analytics (
    id text NOT NULL,
    type storage.buckettype DEFAULT 'ANALYTICS'::storage.buckettype NOT NULL,
    format text DEFAULT 'ICEBERG'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.buckets_analytics OWNER TO supabase_storage_admin;

--
-- Name: migrations; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.migrations (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    hash character varying(40) NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE storage.migrations OWNER TO supabase_storage_admin;

--
-- Name: objects; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.objects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket_id text,
    name text,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text,
    owner_id text,
    user_metadata jsonb,
    level integer
);


ALTER TABLE storage.objects OWNER TO supabase_storage_admin;

--
-- Name: COLUMN objects.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.objects.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: prefixes; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.prefixes (
    bucket_id text NOT NULL,
    name text NOT NULL COLLATE pg_catalog."C",
    level integer GENERATED ALWAYS AS (storage.get_level(name)) STORED NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE storage.prefixes OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads (
    id text NOT NULL,
    in_progress_size bigint DEFAULT 0 NOT NULL,
    upload_signature text NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    version text NOT NULL,
    owner_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_metadata jsonb
);


ALTER TABLE storage.s3_multipart_uploads OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads_parts; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads_parts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    upload_id text NOT NULL,
    size bigint DEFAULT 0 NOT NULL,
    part_number integer NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    etag text NOT NULL,
    owner_id text,
    version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.s3_multipart_uploads_parts OWNER TO supabase_storage_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: supabase_migrations; Owner: postgres
--

CREATE TABLE supabase_migrations.schema_migrations (
    version text NOT NULL,
    statements text[],
    name text,
    created_by text,
    idempotency_key text
);


ALTER TABLE supabase_migrations.schema_migrations OWNER TO postgres;

--
-- Name: refresh_tokens id; Type: DEFAULT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens ALTER COLUMN id SET DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass);


--
-- Data for Name: almoxarifados; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.almoxarifados (id, company_id, nome, codigo, endereco, responsavel_id, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: checklist_recebimento; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.checklist_recebimento (id, entrada_id, item_id, criterio, aprovado, observacoes, usuario_id, data_verificacao, company_id) FROM stdin;
\.


--
-- Data for Name: entrada_itens; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.entrada_itens (id, entrada_id, material_equipamento_id, quantidade_recebida, quantidade_aprovada, valor_unitario, valor_total, centro_custo_id, projeto_id, lote, validade, observacoes, company_id) FROM stdin;
\.


--
-- Data for Name: entradas_materiais; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.entradas_materiais (id, company_id, nfe_id, fornecedor_id, numero_nota, data_entrada, valor_total, status, checklist_aprovado, usuario_recebimento_id, usuario_aprovacao_id, observacoes, created_at) FROM stdin;
\.


--
-- Data for Name: estoque_atual; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.estoque_atual (id, material_equipamento_id, almoxarifado_id, quantidade_atual, quantidade_reservada, valor_total, updated_at, company_id) FROM stdin;
\.


--
-- Data for Name: inventario_itens; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.inventario_itens (id, inventario_id, material_equipamento_id, quantidade_sistema, quantidade_contada, observacoes, contador_id, data_contagem, company_id) FROM stdin;
\.


--
-- Data for Name: inventarios; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.inventarios (id, company_id, almoxarifado_id, tipo, data_inicio, data_fim, status, responsavel_id, observacoes, created_at) FROM stdin;
\.


--
-- Data for Name: localizacoes_fisicas; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.localizacoes_fisicas (id, almoxarifado_id, rua, nivel, posicao, descricao, ativo, created_at, company_id) FROM stdin;
\.


--
-- Data for Name: materiais_equipamentos; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.materiais_equipamentos (id, company_id, material_id, codigo_interno, descricao, tipo, classe, unidade_medida, imagem_url, status, equipamento_proprio, localizacao_id, estoque_minimo, estoque_maximo, valor_unitario, validade_dias, created_at, updated_at, ncm, cfop, cst) FROM stdin;
\.


--
-- Data for Name: movimentacoes_estoque; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.movimentacoes_estoque (id, company_id, material_equipamento_id, almoxarifado_origem_id, almoxarifado_destino_id, tipo_movimentacao, quantidade, valor_unitario, valor_total, centro_custo_id, projeto_id, nfe_id, observacoes, usuario_id, data_movimentacao, status) FROM stdin;
\.


--
-- Data for Name: solicitacoes_compra; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.solicitacoes_compra (id, company_id, material_equipamento_id, almoxarifado_id, quantidade_solicitada, quantidade_minima, status, centro_custo_id, projeto_id, prioridade, created_at, atendido_at) FROM stdin;
\.


--
-- Data for Name: solicitacoes_saida_materiais; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.solicitacoes_saida_materiais (id, company_id, funcionario_solicitante_id, almoxarifado_id, centro_custo_id, projeto_id, data_solicitacao, data_aprovacao, data_saida, status, valor_total, observacoes, created_at, updated_at, funcionario_receptor_id) FROM stdin;
\.


--
-- Data for Name: solicitacoes_saida_materiais_itens; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.solicitacoes_saida_materiais_itens (id, company_id, solicitacao_id, material_id, quantidade_solicitada, quantidade_entregue, valor_unitario, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: transferencia_itens; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.transferencia_itens (id, transferencia_id, material_equipamento_id, quantidade_solicitada, quantidade_aprovada, centro_custo_id, projeto_id, company_id) FROM stdin;
\.


--
-- Data for Name: transferencias; Type: TABLE DATA; Schema: almoxarifado; Owner: postgres
--

COPY almoxarifado.transferencias (id, company_id, almoxarifado_origem_id, almoxarifado_destino_id, solicitante_id, aprovador_id, data_solicitacao, data_aprovacao, data_transferencia, status, observacoes) FROM stdin;
\.


--
-- Data for Name: audit_log_entries; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.audit_log_entries (instance_id, id, payload, created_at, ip_address) FROM stdin;
00000000-0000-0000-0000-000000000000	ca06e4d3-87ef-4648-9327-3b1fbcab962d	{"action":"user_confirmation_requested","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"user","traits":{"provider":"email"}}	2025-10-03 21:28:18.176271+00	
00000000-0000-0000-0000-000000000000	f871026a-831d-48d1-bee1-4dc401434102	{"action":"user_signedup","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"team","traits":{"provider":"email"}}	2025-10-03 21:28:33.478268+00	
00000000-0000-0000-0000-000000000000	3fcf6684-9d3a-4119-a797-075fcb97163e	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-03 21:29:02.728474+00	
00000000-0000-0000-0000-000000000000	e618ee79-3144-4d1c-bead-510b6c37d987	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 09:07:03.122366+00	
00000000-0000-0000-0000-000000000000	73baf52b-312a-4718-a50e-2cdec5b8a081	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 09:07:03.12439+00	
00000000-0000-0000-0000-000000000000	dbc979ab-be9c-48bb-b9d1-9085fa9491ec	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-04 09:23:43.903809+00	
00000000-0000-0000-0000-000000000000	16356c66-3961-4f9a-b62d-eb1474c32605	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 13:01:30.132403+00	
00000000-0000-0000-0000-000000000000	0b632330-90c5-4c12-9a67-1eb2e65274ba	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 13:01:30.133836+00	
00000000-0000-0000-0000-000000000000	f4de405e-f076-4cf6-937b-e01cfc523ebd	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-04 14:15:05.376692+00	
00000000-0000-0000-0000-000000000000	3166199f-b0c9-4834-90e9-d4a7110c0e2a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 15:13:35.727896+00	
00000000-0000-0000-0000-000000000000	9f617853-6215-4f25-ba8b-a67e2874e6ee	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 15:13:35.728945+00	
00000000-0000-0000-0000-000000000000	63e098a9-1b20-4b1f-871e-7a2f2efd9bf2	{"action":"logout","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account"}	2025-10-04 15:26:48.778977+00	
00000000-0000-0000-0000-000000000000	01aa536d-c86e-45f7-8f2f-1ac8f991ab18	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-04 15:26:55.801682+00	
00000000-0000-0000-0000-000000000000	c0421909-fe56-45d6-bdd1-bfa3b8a16214	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 16:25:15.239401+00	
00000000-0000-0000-0000-000000000000	139f0f49-d072-49dc-86b0-8ea8e0d298d7	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 16:25:15.240743+00	
00000000-0000-0000-0000-000000000000	e907cecb-6b09-40bd-af0b-c7a8d969d851	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 21:14:07.144495+00	
00000000-0000-0000-0000-000000000000	0eb198d6-a776-4386-9a56-235785c8fa5e	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 21:14:07.145527+00	
00000000-0000-0000-0000-000000000000	3d4deedb-6247-4f29-8761-a38b151730c0	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 22:15:08.132913+00	
00000000-0000-0000-0000-000000000000	025cf92d-d912-4cca-9886-75b8ce03bcad	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 22:15:08.133881+00	
00000000-0000-0000-0000-000000000000	fe328852-a2b3-4ce4-9fe0-09cad3e3b57c	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 23:13:38.788389+00	
00000000-0000-0000-0000-000000000000	0d5ae63b-f321-4f76-af43-7c75248dabf5	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-04 23:13:38.789393+00	
00000000-0000-0000-0000-000000000000	fa73e94d-e1be-4f53-a5b0-c60828a3dcc8	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 00:15:56.532996+00	
00000000-0000-0000-0000-000000000000	ded864ac-973b-4d36-992b-90ff57279855	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 00:15:56.534453+00	
00000000-0000-0000-0000-000000000000	bd2df657-a345-4719-9a76-fb32edd6d53f	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 12:20:44.700922+00	
00000000-0000-0000-0000-000000000000	66f501e5-90f7-42d2-96e4-58cdb203ed3e	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 12:20:44.704088+00	
00000000-0000-0000-0000-000000000000	b620c392-7d1f-41b2-8347-df1b01c131f1	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 13:19:29.209392+00	
00000000-0000-0000-0000-000000000000	711f6c5d-e5ba-42e8-a1ce-ed0ae9be1a7f	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 13:19:29.210527+00	
00000000-0000-0000-0000-000000000000	2b1dd541-2609-4737-a8e3-c8f749958f53	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 16:15:11.86698+00	
00000000-0000-0000-0000-000000000000	d7329349-f004-467a-a226-1df2adf8d418	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 16:15:11.868359+00	
00000000-0000-0000-0000-000000000000	181558d6-91fa-4bac-a8b7-b482f3525b8d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 18:44:11.348916+00	
00000000-0000-0000-0000-000000000000	79c54b97-36b4-4554-a484-7ed455ecefa7	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 18:44:11.350147+00	
00000000-0000-0000-0000-000000000000	d758870b-1f9e-4d38-8434-51589f04cde7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 19:42:41.678387+00	
00000000-0000-0000-0000-000000000000	7bb5963b-3a44-4e24-87ea-a7d8caf0a6b5	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 19:42:41.679542+00	
00000000-0000-0000-0000-000000000000	9336fa0b-698d-4812-a301-cd650b8daa1b	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 20:46:55.469535+00	
00000000-0000-0000-0000-000000000000	69a983a1-9036-457e-8582-ccf88f38e2a4	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 20:46:55.470948+00	
00000000-0000-0000-0000-000000000000	075b5775-2d0b-4321-bcc5-e3a1a4257375	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 21:45:38.293993+00	
00000000-0000-0000-0000-000000000000	64bfffba-751d-4b90-b221-86b8196e9700	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 21:45:38.295006+00	
00000000-0000-0000-0000-000000000000	a5d5ab2f-07cb-4fe1-81ac-769e9f44f7a5	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 22:44:47.335965+00	
00000000-0000-0000-0000-000000000000	69dfaeea-22d8-4bce-a516-145818d69bd7	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-05 22:44:47.337605+00	
00000000-0000-0000-0000-000000000000	444fd2d7-0b14-4f9d-bde7-c85c9ea181fe	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 12:40:53.392529+00	
00000000-0000-0000-0000-000000000000	31abbc83-a0ad-493e-a287-46e8e0a25530	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 12:40:53.393934+00	
00000000-0000-0000-0000-000000000000	b584a05d-6cf2-4535-ae3b-b4455a8935ce	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 13:51:46.439054+00	
00000000-0000-0000-0000-000000000000	96597cf0-bc57-494c-8192-8a0ed3c983d9	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 13:51:46.440686+00	
00000000-0000-0000-0000-000000000000	28ee34b2-2a9a-460a-bd18-bc58f0be91ab	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-06 14:33:09.038671+00	
00000000-0000-0000-0000-000000000000	d0c003d8-015e-46f3-bb25-9ee482210d58	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 18:38:53.573522+00	
00000000-0000-0000-0000-000000000000	c73fef27-51de-4c3b-b601-108210d3ba01	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 18:38:53.574532+00	
00000000-0000-0000-0000-000000000000	bbfcd00f-1718-4553-a6a4-a3acb376e5e1	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 19:43:57.0577+00	
00000000-0000-0000-0000-000000000000	218e6a18-930f-4d29-a6a3-62bd665122d0	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-06 19:43:57.05929+00	
00000000-0000-0000-0000-000000000000	1f921146-cc8d-4c5f-b81c-fdf570aabcc5	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 00:36:47.623279+00	
00000000-0000-0000-0000-000000000000	647a87cf-424f-4e92-a526-407a71859e17	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 00:36:47.624901+00	
00000000-0000-0000-0000-000000000000	20ecb57e-4d52-4c82-a25c-5d6687b72057	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 01:36:28.504998+00	
00000000-0000-0000-0000-000000000000	6b2383bd-6a38-4463-9760-8bed6c7bd732	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 01:36:28.506346+00	
00000000-0000-0000-0000-000000000000	c6e8352f-a038-4937-bea9-ef62c1956c70	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 10:12:04.238532+00	
00000000-0000-0000-0000-000000000000	ff5c6183-5ff0-4e9b-9ca7-5b07e028a5f6	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 10:12:04.239587+00	
00000000-0000-0000-0000-000000000000	627cc8d2-be14-40ba-905c-5173abf51e1a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 20:35:14.764771+00	
00000000-0000-0000-0000-000000000000	5b96fa57-23cb-4f19-89d4-ba6866cf703c	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 20:35:14.765946+00	
00000000-0000-0000-0000-000000000000	2bca8c39-779f-44ba-9295-c7098346947e	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 22:54:51.178471+00	
00000000-0000-0000-0000-000000000000	13281016-2b94-458a-b682-e5cff0657376	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 22:54:51.179579+00	
00000000-0000-0000-0000-000000000000	7d34097e-7fa8-4184-8aa9-fdc640c70d77	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 23:56:12.431849+00	
00000000-0000-0000-0000-000000000000	d1b3d7bd-201b-4db0-8ca6-d088ac660382	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-07 23:56:12.432864+00	
00000000-0000-0000-0000-000000000000	a2ea01ae-4e78-4f13-85f0-68f80d1de45e	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 00:55:00.6123+00	
00000000-0000-0000-0000-000000000000	c100a726-a662-4c1f-bdfe-4f154bc77178	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 00:55:00.613849+00	
00000000-0000-0000-0000-000000000000	2c02f7dc-1d6f-4821-9527-ca760eacf6af	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 11:28:30.721939+00	
00000000-0000-0000-0000-000000000000	9bdb42a5-bbe9-4f37-90f0-53c2148b4cd3	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 11:28:30.72336+00	
00000000-0000-0000-0000-000000000000	3da3d010-b1b0-4626-9406-49c37c6eafda	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 18:50:34.677962+00	
00000000-0000-0000-0000-000000000000	b6420c04-7206-4838-a9a2-a0f252db44ee	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 18:50:34.679493+00	
00000000-0000-0000-0000-000000000000	eeafa7fc-9bfd-4ccd-865b-044f0a31f1a8	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 19:48:54.883463+00	
00000000-0000-0000-0000-000000000000	2082bed7-9ec3-4bd3-a7e0-72196f5fdb69	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 19:48:54.884755+00	
00000000-0000-0000-0000-000000000000	042e97d3-2282-47b1-8ba3-83fb2b2a48bf	{"action":"login","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-08 20:15:37.945934+00	
00000000-0000-0000-0000-000000000000	ce72423f-18b3-46fc-840c-3f0a81a11c31	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 22:42:56.069288+00	
00000000-0000-0000-0000-000000000000	006967bc-9866-4343-b05c-1a94de2270fa	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 22:42:56.070747+00	
00000000-0000-0000-0000-000000000000	5928ddc8-d03b-4d78-9d38-66b287f2c900	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 23:41:04.027426+00	
00000000-0000-0000-0000-000000000000	8ebd642b-913b-4313-8a27-d989ef35a19d	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-08 23:41:04.028782+00	
00000000-0000-0000-0000-000000000000	7475e0ef-3be2-4d61-8031-ef1e81626744	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 00:41:47.573087+00	
00000000-0000-0000-0000-000000000000	64b313db-d170-45de-9275-87b474b24a2c	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 00:41:47.574655+00	
00000000-0000-0000-0000-000000000000	b37b23a7-ac81-4331-89d5-e6056e99ea0d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 00:41:49.754514+00	
00000000-0000-0000-0000-000000000000	492274b1-da26-4355-8a30-d7a47acafc3a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 01:40:30.99757+00	
00000000-0000-0000-0000-000000000000	f2b4a61d-279c-428a-81bb-f2493388bdae	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 01:40:30.998988+00	
00000000-0000-0000-0000-000000000000	f1e655ce-d91a-445b-b599-215da56948a7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 23:25:56.510571+00	
00000000-0000-0000-0000-000000000000	334b089d-cbca-4100-accb-82617359b664	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-09 23:25:56.511614+00	
00000000-0000-0000-0000-000000000000	e94aa2ec-34c3-4cc4-9a1c-b965d09275f5	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 00:24:32.076784+00	
00000000-0000-0000-0000-000000000000	fc3e22d1-f72c-433b-b219-ea2e4832a510	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 00:24:32.078406+00	
00000000-0000-0000-0000-000000000000	8744795b-10d1-46f9-8b58-88e5d07a6a07	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 15:25:14.487717+00	
00000000-0000-0000-0000-000000000000	42662d62-f42e-4faf-b98d-79b4f6d59152	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 15:25:14.489151+00	
00000000-0000-0000-0000-000000000000	d90f9279-eac3-4304-8efb-50d08f748d78	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 20:11:29.558615+00	
00000000-0000-0000-0000-000000000000	7315545b-bf8f-49c7-86cb-a8b787ec1ee2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 20:11:29.559699+00	
00000000-0000-0000-0000-000000000000	56bd711e-7437-4ff3-b3ae-748e61d7e10f	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 21:09:47.693843+00	
00000000-0000-0000-0000-000000000000	78a3b1e1-6933-41c1-bbc5-550618e9f9c2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 21:09:47.695372+00	
00000000-0000-0000-0000-000000000000	9c5a36be-aae9-4def-bef9-d1f5d62e31bf	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 22:08:10.232043+00	
00000000-0000-0000-0000-000000000000	d64de665-6a34-47f7-95d3-355be53c73cf	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-10 22:08:10.234033+00	
00000000-0000-0000-0000-000000000000	bfd111d1-1771-493c-9e4b-42d7c7f7672a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 21:37:05.826176+00	
00000000-0000-0000-0000-000000000000	8fb4a9cb-8ef1-4511-8968-f3186b7d8d86	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 21:37:05.827332+00	
00000000-0000-0000-0000-000000000000	9d7786e3-398b-450d-b2b6-06623b950ff5	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 22:35:36.558886+00	
00000000-0000-0000-0000-000000000000	92d65cbd-1e5f-4c0a-9538-4a942c6211b2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 22:35:36.56019+00	
00000000-0000-0000-0000-000000000000	c8bd283c-c6f5-45b7-ace2-4f2e9ad5457a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 23:36:26.55426+00	
00000000-0000-0000-0000-000000000000	8e82aaaf-2af0-47a2-8c65-50a050a55cdd	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-11 23:36:26.55527+00	
00000000-0000-0000-0000-000000000000	dc5e1c18-a700-43e2-bc05-c383b4b5fd9d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 00:35:51.917713+00	
00000000-0000-0000-0000-000000000000	d048c017-113f-4c5e-b0fe-c40fc971230f	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 00:35:51.919334+00	
00000000-0000-0000-0000-000000000000	24052929-eb68-4470-a817-ad0d853696e8	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 10:01:58.275883+00	
00000000-0000-0000-0000-000000000000	b7159cb0-c21c-4403-8402-c8eef9b3bf5f	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 10:01:58.277254+00	
00000000-0000-0000-0000-000000000000	4a40aa97-af1c-422a-b904-b3c84fbf39e5	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 11:15:51.290981+00	
00000000-0000-0000-0000-000000000000	c61fcf83-83ed-448c-8d4c-bc04a4d8f20b	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 11:15:51.291972+00	
00000000-0000-0000-0000-000000000000	cbbc5ae3-8c56-4d27-81ab-c98b1882f769	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 12:18:58.863033+00	
00000000-0000-0000-0000-000000000000	b364365a-dd75-4f73-912d-6eaea10ec052	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 12:18:58.864062+00	
00000000-0000-0000-0000-000000000000	33b7162a-58ea-4c66-96c3-4fa4b69b98c1	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 13:26:58.050298+00	
00000000-0000-0000-0000-000000000000	6d8f32ba-c401-41be-a0a1-e06a61d98f4b	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 13:26:58.051746+00	
00000000-0000-0000-0000-000000000000	39d6a980-467c-47eb-87d1-38d540b6b3d7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 14:25:24.045818+00	
00000000-0000-0000-0000-000000000000	2c67d7f7-1c7d-46cc-bbdb-b765e13932a8	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-12 14:25:24.046923+00	
00000000-0000-0000-0000-000000000000	f39c9667-95a3-43dc-a335-edb43bf96ead	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 11:13:44.443659+00	
00000000-0000-0000-0000-000000000000	7d0a6b14-ce35-41c8-b5f5-ff419fd11aac	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 11:13:44.445128+00	
00000000-0000-0000-0000-000000000000	8c445ce2-6830-441b-8e3d-798db0ddb127	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 12:26:28.121921+00	
00000000-0000-0000-0000-000000000000	56ca55d1-8cbc-4584-8cb3-1a7046721076	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 12:26:28.123067+00	
00000000-0000-0000-0000-000000000000	3ebd6455-992c-472c-9441-e53b48c15b28	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 13:36:35.390462+00	
00000000-0000-0000-0000-000000000000	ddadc67a-b99e-433d-9da4-0e9a765b2249	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 13:36:35.391501+00	
00000000-0000-0000-0000-000000000000	57087f52-28b2-4039-9750-8c1fec7914ab	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 17:20:29.319869+00	
00000000-0000-0000-0000-000000000000	c2ed9c42-5751-4de3-b3fb-bd632aa20bae	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 17:20:29.321288+00	
00000000-0000-0000-0000-000000000000	f5c7d621-a297-45bf-b2bb-4030faea731b	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 18:19:17.219405+00	
00000000-0000-0000-0000-000000000000	99c26cc0-7625-451e-9ab7-5945f75878d8	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 18:19:17.22045+00	
00000000-0000-0000-0000-000000000000	943d1239-ff8f-4606-b0b3-cd2135df3401	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste1@estrategicengenharia.com.br","user_id":"a1aa1fde-03cb-42b3-bd67-4ac5def143db","user_phone":""}}	2025-10-13 18:36:25.137712+00	
00000000-0000-0000-0000-000000000000	e332a6f5-1c3f-453f-a82b-39c1a0820d52	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste2@estrategicengenharia.com.br","user_id":"3be90091-7fa2-45bd-9555-54fdf167fc1f","user_phone":""}}	2025-10-13 19:04:59.297219+00	
00000000-0000-0000-0000-000000000000	96aa4947-79c8-4456-9d95-a8f23c298178	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste6@estrategicengenharia.com.br","user_id":"973e7d99-94f8-4070-bd4f-e018ae92a6fd","user_phone":""}}	2025-10-13 19:12:22.263505+00	
00000000-0000-0000-0000-000000000000	5c739ff2-1472-4528-a2ae-44a7c2f16ac4	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 19:18:03.070453+00	
00000000-0000-0000-0000-000000000000	5f30055a-931c-44b3-ba7e-ab031873388f	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 19:18:03.0715+00	
00000000-0000-0000-0000-000000000000	cada3151-3f23-4515-808e-9ec6be5b2509	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste7@estrategicengenharia.com.br","user_id":"8d7ad676-3611-4a3c-ae09-f707ebb8d3dc","user_phone":""}}	2025-10-13 19:18:28.005126+00	
00000000-0000-0000-0000-000000000000	8f9ee24f-baf4-4d9c-9206-14fec7339c6d	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste8@estrategicengenharia.com.br","user_id":"4ef296f5-a364-4da7-a2d6-6450cf81975a","user_phone":""}}	2025-10-13 19:21:24.93637+00	
00000000-0000-0000-0000-000000000000	28e7332b-5ee8-441e-950a-f7175bdb6738	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste9@estrategicengenharia.com.br","user_id":"aece2423-01c8-4af2-bbed-4b7a1f7be300","user_phone":""}}	2025-10-13 19:28:48.613775+00	
00000000-0000-0000-0000-000000000000	c951d7c4-f646-4d10-b676-3766b052ee8a	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste10@estrategicengenharia.com.br","user_id":"95aff25e-1b9e-416d-87fd-a3f67ea9cc23","user_phone":""}}	2025-10-13 19:30:55.017644+00	
00000000-0000-0000-0000-000000000000	0d75c1ed-bfd9-4d85-8526-9d9d4c435cef	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste11@estrategicengenharia.com.br","user_id":"f1a67bda-bd84-40ff-8714-f5db1b62b18d","user_phone":""}}	2025-10-13 19:46:04.502023+00	
00000000-0000-0000-0000-000000000000	14fa5529-d314-4c36-aad4-20cab940cd12	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste12@estrategicengenharia.com.br","user_id":"42e98858-58ef-47e9-9f0c-64206d665990","user_phone":""}}	2025-10-13 19:49:25.102008+00	
00000000-0000-0000-0000-000000000000	214f21d2-e015-4552-af48-194cd81e6b88	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste13@estrategicengenharia.com.br","user_id":"90260bc3-dcdd-4905-8bd2-6b94569f5335","user_phone":""}}	2025-10-13 19:52:18.435334+00	
00000000-0000-0000-0000-000000000000	5b034d45-6243-4328-8196-bd36c5f01a5c	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste14@estrategicengenharia.com.br","user_id":"54cb536b-eb18-484a-b1db-1728ebbad218","user_phone":""}}	2025-10-13 19:56:50.134239+00	
00000000-0000-0000-0000-000000000000	6682fcdb-d0fd-4422-bd86-52422aa84118	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste15@estrategicengenharia.com.br","user_id":"a2d13349-cc6f-4fdb-8dfc-378326445973","user_phone":""}}	2025-10-13 20:00:20.38191+00	
00000000-0000-0000-0000-000000000000	f61da757-c414-4fc5-8f4d-02e2566c1468	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 20:18:20.914719+00	
00000000-0000-0000-0000-000000000000	682bda8e-8a8e-4889-b253-4e60a7d1d8e6	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 20:18:20.916129+00	
00000000-0000-0000-0000-000000000000	6c9d4448-8e9e-4a2e-ba4b-38984c907809	{"action":"user_signedup","actor_id":"00000000-0000-0000-0000-000000000000","actor_username":"service_role","actor_via_sso":false,"log_type":"team","traits":{"provider":"email","user_email":"teste16@estrategicengenharia.com.br","user_id":"83946149-becc-4501-8893-fc5a0decf6d7","user_phone":""}}	2025-10-13 20:23:40.125594+00	
00000000-0000-0000-0000-000000000000	2d2f2ad9-d5df-4847-b1fa-cde986c6d4d6	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 21:19:33.383051+00	
00000000-0000-0000-0000-000000000000	46e62ef5-43a6-48da-8a7d-fd58de72f729	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 21:19:33.38532+00	
00000000-0000-0000-0000-000000000000	c5370fc3-1807-450a-8c8e-bf023eb31f69	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 22:19:06.700437+00	
00000000-0000-0000-0000-000000000000	9fc6358c-c291-4052-85c8-c03f779ed75a	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-13 22:19:06.701659+00	
00000000-0000-0000-0000-000000000000	c4873ad8-9e51-4922-b0ed-618e025f88df	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 10:06:31.217272+00	
00000000-0000-0000-0000-000000000000	430b7df6-83c4-4fd3-89fd-ab356cefb03d	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 10:06:31.218387+00	
00000000-0000-0000-0000-000000000000	448e4c03-11c2-4f24-9891-c3dbaaca0935	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 14:54:42.378689+00	
00000000-0000-0000-0000-000000000000	6ed408b2-2c25-491b-a89f-8625cb693f92	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 14:54:42.379798+00	
00000000-0000-0000-0000-000000000000	b6f5a909-1881-4202-8cf9-63aab0b0badc	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 16:33:36.277748+00	
00000000-0000-0000-0000-000000000000	63fac57e-be7c-4576-ba23-925bf2ff0e07	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 16:33:36.279085+00	
00000000-0000-0000-0000-000000000000	083a2a3c-7691-4ffd-b46c-58e95614e6b4	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 20:05:49.284482+00	
00000000-0000-0000-0000-000000000000	48d32d1b-0e8b-4a40-b9a6-17e2100508be	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 20:05:49.285568+00	
00000000-0000-0000-0000-000000000000	371a99c0-325c-4f3e-88ae-6331d9b488a0	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 22:42:20.668645+00	
00000000-0000-0000-0000-000000000000	99360917-b74e-4cff-9b49-33452c815226	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 22:42:20.669667+00	
00000000-0000-0000-0000-000000000000	f82b4172-c26c-47cd-bd23-78452956f303	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 23:55:33.015124+00	
00000000-0000-0000-0000-000000000000	72fb8a09-cdad-45b0-b655-7b982f5dad33	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-14 23:55:33.016567+00	
00000000-0000-0000-0000-000000000000	0644eeef-5e1e-4211-bfd2-af9bb461c0ef	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 10:19:15.396044+00	
00000000-0000-0000-0000-000000000000	7f11bd60-a787-418b-9ff3-8f105ed004f3	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 10:19:15.397393+00	
00000000-0000-0000-0000-000000000000	44a40695-5291-4b80-be8f-b8a285bac163	{"action":"login","actor_id":"a1aa1fde-03cb-42b3-bd67-4ac5def143db","actor_username":"teste1@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-15 10:28:04.793848+00	
00000000-0000-0000-0000-000000000000	889b0730-72e4-4caa-bc56-c795c4ba5089	{"action":"login","actor_id":"a1aa1fde-03cb-42b3-bd67-4ac5def143db","actor_username":"teste1@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"account","traits":{"provider":"email"}}	2025-10-15 10:36:17.105004+00	
00000000-0000-0000-0000-000000000000	97b62910-38c0-4073-8123-282fdc5d9b15	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 11:22:34.891095+00	
00000000-0000-0000-0000-000000000000	52abef59-2c77-40d4-96e1-acae6309355d	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 11:22:34.892584+00	
00000000-0000-0000-0000-000000000000	25f2e0ae-bdff-4f6f-ae13-1dc416a6ac3d	{"action":"token_refreshed","actor_id":"a1aa1fde-03cb-42b3-bd67-4ac5def143db","actor_username":"teste1@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 11:34:37.431729+00	
00000000-0000-0000-0000-000000000000	388647f0-707b-436b-9de6-893c122654da	{"action":"token_revoked","actor_id":"a1aa1fde-03cb-42b3-bd67-4ac5def143db","actor_username":"teste1@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 11:34:37.432722+00	
00000000-0000-0000-0000-000000000000	bc4bcf5c-7fb7-402f-9927-39eb728abd3f	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 12:27:17.717446+00	
00000000-0000-0000-0000-000000000000	de96b3ac-3c70-4aa9-ba35-09e46d05bac9	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 12:27:17.718712+00	
00000000-0000-0000-0000-000000000000	ed17c90c-50c5-4232-a35b-b1ed50fb3e14	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 13:26:29.477032+00	
00000000-0000-0000-0000-000000000000	ca9cc6e2-83f2-40d0-b2c0-87e550046eb2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 13:26:29.483719+00	
00000000-0000-0000-0000-000000000000	d879b55a-43d2-489d-8049-7967a79c983e	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 14:32:53.381149+00	
00000000-0000-0000-0000-000000000000	8b8e0ce8-e27d-43ee-a843-55aecfd82a48	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 14:32:53.382748+00	
00000000-0000-0000-0000-000000000000	591b6e01-363f-473f-a49d-53fbca1e1ad6	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 15:31:18.905369+00	
00000000-0000-0000-0000-000000000000	e35bb96b-25ba-4cc5-b05b-a51ad8c2f918	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 15:31:18.906418+00	
00000000-0000-0000-0000-000000000000	cf49ffd6-a6cd-4029-b4ab-3987f133d3d1	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 17:24:54.088643+00	
00000000-0000-0000-0000-000000000000	5fefbbd4-9589-4681-b785-53810a12acc6	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 17:24:54.089793+00	
00000000-0000-0000-0000-000000000000	03488168-e23b-4aab-8d59-51add9550af7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 18:23:24.843601+00	
00000000-0000-0000-0000-000000000000	7d876db1-1413-4adc-a4f1-639160a53fcc	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 18:23:24.844941+00	
00000000-0000-0000-0000-000000000000	1258e59c-6c8b-4841-9f1b-b49b939c8425	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 19:39:08.542014+00	
00000000-0000-0000-0000-000000000000	733f4da7-31eb-4e46-b923-0757c8ee5c77	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 19:39:08.543407+00	
00000000-0000-0000-0000-000000000000	4e360457-f39e-44cd-94bb-ae4b0464eaeb	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 20:37:56.760957+00	
00000000-0000-0000-0000-000000000000	3bf31541-4ee5-4f6a-acc5-c413761e06af	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 20:37:56.762024+00	
00000000-0000-0000-0000-000000000000	3c5bb71f-5adc-4499-8263-5e23e1c2b6cc	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 21:39:43.571651+00	
00000000-0000-0000-0000-000000000000	85562b42-a3ae-41a3-ba15-263133028c99	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 21:39:43.572985+00	
00000000-0000-0000-0000-000000000000	6779c61e-40ba-476d-9fbf-61e1c2afffce	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 22:40:36.816581+00	
00000000-0000-0000-0000-000000000000	99176aff-fc39-4d43-97a1-4b188eafc7ea	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 22:40:36.817701+00	
00000000-0000-0000-0000-000000000000	e0631ac6-0836-489b-be1e-fa8a47cd4f4d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 23:50:01.412331+00	
00000000-0000-0000-0000-000000000000	ecfcc56a-69b3-4226-bd92-c84525149b00	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-15 23:50:01.413456+00	
00000000-0000-0000-0000-000000000000	d11d6ebc-e739-4684-9a04-0c7c22fc044d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 00:48:43.010913+00	
00000000-0000-0000-0000-000000000000	63491867-964b-4758-b66b-dfcf81a15c13	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 00:48:43.012256+00	
00000000-0000-0000-0000-000000000000	d8cfcc47-607c-42ed-b71e-ca3b728325fc	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 10:12:28.285556+00	
00000000-0000-0000-0000-000000000000	a27fc663-8946-490c-8828-f5e1353e7e8d	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 10:12:28.286817+00	
00000000-0000-0000-0000-000000000000	9c293887-7883-4385-a243-9f3db6e7ee5d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 20:04:29.307026+00	
00000000-0000-0000-0000-000000000000	5becb7b1-7f5f-49de-8984-c7595047b392	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-16 20:04:29.310683+00	
00000000-0000-0000-0000-000000000000	3ee614ef-a93b-4146-be20-dae2abe03e42	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 00:25:10.408044+00	
00000000-0000-0000-0000-000000000000	5399861f-e78f-4d9f-ab05-2ec0b5bdf677	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 00:25:10.409022+00	
00000000-0000-0000-0000-000000000000	4d973813-c8e7-4d53-9c3a-f17e4895f53d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 13:15:41.740805+00	
00000000-0000-0000-0000-000000000000	51cdf056-c46b-4380-8170-f184bc4dd144	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 13:15:41.742382+00	
00000000-0000-0000-0000-000000000000	ae67ef87-b8ba-457e-b801-6556d21b5efd	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 14:19:49.434924+00	
00000000-0000-0000-0000-000000000000	6c62c305-64f1-46a1-b443-6479caedf072	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 14:19:49.436272+00	
00000000-0000-0000-0000-000000000000	f585554e-5cbc-448c-b2d8-f8a3fb8d0268	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 16:57:23.337547+00	
00000000-0000-0000-0000-000000000000	8dd9708c-1f77-4c7a-aab8-d025aff69a7d	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 16:57:23.338618+00	
00000000-0000-0000-0000-000000000000	d6991ca0-7d10-4ecb-8eed-5b8a25df6ddb	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 17:55:50.655157+00	
00000000-0000-0000-0000-000000000000	29defb50-9f00-4ff6-918c-49ea2bcc417e	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 17:55:50.656213+00	
00000000-0000-0000-0000-000000000000	aabe2fac-a501-4029-a67c-4e393b3e5896	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 19:19:08.202239+00	
00000000-0000-0000-0000-000000000000	e446bb9b-d7b9-4f33-a656-c85c569e89de	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 19:19:08.203787+00	
00000000-0000-0000-0000-000000000000	e59f156f-613d-441a-ba3e-612f1d5c612d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 20:17:54.964671+00	
00000000-0000-0000-0000-000000000000	edfb4966-8700-447a-8e02-af495f5e153c	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 20:17:54.965809+00	
00000000-0000-0000-0000-000000000000	32e82e33-3107-4f11-a0c9-6dc8a2694659	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 21:16:16.540865+00	
00000000-0000-0000-0000-000000000000	4ef52a6d-792e-4483-a7e4-1385da51032a	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-17 21:16:16.541866+00	
00000000-0000-0000-0000-000000000000	9bc6216d-227e-4f33-874a-74451379c9a2	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 14:58:09.634269+00	
00000000-0000-0000-0000-000000000000	896e1ebf-4cee-4409-b3dc-25c8e0986067	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 14:58:09.638454+00	
00000000-0000-0000-0000-000000000000	4ccde70f-8725-4a3a-873e-64e84a3edd7a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 16:02:24.578511+00	
00000000-0000-0000-0000-000000000000	66bc9ac0-c98a-4aab-a872-1838618d4c95	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 16:02:24.579554+00	
00000000-0000-0000-0000-000000000000	7fcf99e1-f946-4b91-af1e-febc543a91f7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 17:01:12.612932+00	
00000000-0000-0000-0000-000000000000	6088492e-7bd2-4d91-9691-458fcd4b10db	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 17:01:12.614318+00	
00000000-0000-0000-0000-000000000000	968d9271-98fa-436d-a44e-fe135ed8ce9f	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 18:40:27.835342+00	
00000000-0000-0000-0000-000000000000	8211cc81-89ab-437a-ae7a-ca3d69b7ce4e	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 18:40:27.83683+00	
00000000-0000-0000-0000-000000000000	544bb04a-1228-4b09-9b09-e98941f50b64	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 19:38:43.094225+00	
00000000-0000-0000-0000-000000000000	e1d976a1-767e-48c0-aa94-1793dd941973	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 19:38:43.095722+00	
00000000-0000-0000-0000-000000000000	ea80f27f-307b-4385-b2af-99d144a52bba	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 20:45:53.891272+00	
00000000-0000-0000-0000-000000000000	f67add55-cf38-46e2-913d-d3b2cceee8a9	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 20:45:53.892946+00	
00000000-0000-0000-0000-000000000000	c5141c3c-d57f-4e67-8b01-771e0c8560cf	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 21:45:25.897952+00	
00000000-0000-0000-0000-000000000000	0009c0f7-1ee5-42a3-8bde-1cc0c1e3319a	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 21:45:25.898972+00	
00000000-0000-0000-0000-000000000000	a5898fb0-4a11-4e73-b2de-8229624454f7	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 22:50:04.283663+00	
00000000-0000-0000-0000-000000000000	17aa4a4c-4403-419e-a3c7-e0969429ffa3	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-18 22:50:04.284747+00	
00000000-0000-0000-0000-000000000000	428867c1-e08a-43b8-a354-fca5e789097d	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 00:02:10.075635+00	
00000000-0000-0000-0000-000000000000	579bb628-d51f-4956-beca-2234d5fd7ba2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 00:02:10.076817+00	
00000000-0000-0000-0000-000000000000	e47c021f-48be-4292-9f82-454cf003e317	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 10:11:21.513187+00	
00000000-0000-0000-0000-000000000000	7f756447-31e5-432b-a8e7-ea46e5a002b0	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 10:11:21.51506+00	
00000000-0000-0000-0000-000000000000	2862ac88-be62-4831-ad96-61d69f6bab52	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 11:09:22.941507+00	
00000000-0000-0000-0000-000000000000	2fecb139-7766-4c21-8f98-edbf01f26a21	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 11:09:22.942812+00	
00000000-0000-0000-0000-000000000000	c76a7d33-efeb-404e-bab1-a6ca615139fe	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 12:07:57.138455+00	
00000000-0000-0000-0000-000000000000	1297207c-66f7-468f-8fdd-7c3def995f84	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 12:07:57.139498+00	
00000000-0000-0000-0000-000000000000	869e0a7b-17a5-4180-bcf5-8a1687249ab1	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 13:05:58.905336+00	
00000000-0000-0000-0000-000000000000	57a7a484-2f3b-4ac0-a9f2-710f82837933	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 13:05:58.907116+00	
00000000-0000-0000-0000-000000000000	dd479d04-5a20-4e09-8db1-2cc7ee9bcea8	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 22:43:23.492334+00	
00000000-0000-0000-0000-000000000000	3f6dd290-e9cc-4ff3-abff-9351c61f266c	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 22:43:23.493421+00	
00000000-0000-0000-0000-000000000000	a723daf0-29eb-4c0a-bdab-270fa85b9d3e	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 23:43:36.852591+00	
00000000-0000-0000-0000-000000000000	b4c3b136-bf62-49fa-a680-0fbbbe298e03	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-19 23:43:36.853919+00	
00000000-0000-0000-0000-000000000000	38324589-7b0f-49d7-ba3a-8a64411a6443	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 00:02:42.608498+00	
00000000-0000-0000-0000-000000000000	8ed06a02-037c-43be-8027-0fab54c08f09	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 00:02:42.609593+00	
00000000-0000-0000-0000-000000000000	c1ef8905-877c-4229-9173-1d4059661d6a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 01:01:19.493065+00	
00000000-0000-0000-0000-000000000000	8479ec84-f532-47eb-85b7-1995d78c4ba2	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 01:01:19.49511+00	
00000000-0000-0000-0000-000000000000	8e369fc2-4143-408e-bbd1-e98e2f954e43	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 12:43:37.891463+00	
00000000-0000-0000-0000-000000000000	f1dd171f-ef94-4ba1-8b1d-78bffe4a40f3	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 12:43:37.892535+00	
00000000-0000-0000-0000-000000000000	c3b2a548-c2f2-4eb2-ac27-ea3fe282f62f	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 14:21:44.147037+00	
00000000-0000-0000-0000-000000000000	566d0a64-d2fd-4f97-8d84-9f9b2f542038	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 14:21:44.148111+00	
00000000-0000-0000-0000-000000000000	37a61b22-5b92-4701-a0a3-5ea5abc1808c	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 15:33:35.945261+00	
00000000-0000-0000-0000-000000000000	b328c914-a188-4eca-b869-b436aa865966	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 15:33:35.94633+00	
00000000-0000-0000-0000-000000000000	bc8f455c-ebd5-4299-a694-35cc6d87f618	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 17:23:39.561364+00	
00000000-0000-0000-0000-000000000000	fa02594c-9b45-4511-8ede-5e6934deab68	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 17:23:39.562395+00	
00000000-0000-0000-0000-000000000000	a29fbdd5-87b9-4fe3-a06b-f64dbaa65761	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 19:39:52.43965+00	
00000000-0000-0000-0000-000000000000	5ca0224d-de85-4679-aa61-9c25ec0142fe	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 19:39:52.440846+00	
00000000-0000-0000-0000-000000000000	b41ecfad-f435-4193-a912-1c0d915e9a12	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 20:45:25.21241+00	
00000000-0000-0000-0000-000000000000	1f45922b-23e3-4708-896c-40fe6ae700cc	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 20:45:25.213906+00	
00000000-0000-0000-0000-000000000000	760e6614-d456-41fa-9801-b6111baeef7a	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 22:50:40.503033+00	
00000000-0000-0000-0000-000000000000	41a954ae-d46d-4d9b-a76b-bedb22634e71	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 22:50:40.504087+00	
00000000-0000-0000-0000-000000000000	bb4bd09a-6c29-4268-9ab9-7544556af6af	{"action":"token_refreshed","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 23:48:42.839429+00	
00000000-0000-0000-0000-000000000000	78a8b671-bdc5-450d-b590-495524e4a13f	{"action":"token_revoked","actor_id":"e745168f-addb-4456-a6fa-f4a336d874ac","actor_username":"deiverson.medeiros@estrategicengenharia.com.br","actor_via_sso":false,"log_type":"token"}	2025-10-20 23:48:42.840414+00	
\.


--
-- Data for Name: flow_state; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.flow_state (id, user_id, auth_code, code_challenge_method, code_challenge, provider_type, provider_access_token, provider_refresh_token, created_at, updated_at, authentication_method, auth_code_issued_at) FROM stdin;
\.


--
-- Data for Name: identities; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.identities (provider_id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at, id) FROM stdin;
e745168f-addb-4456-a6fa-f4a336d874ac	e745168f-addb-4456-a6fa-f4a336d874ac	{"sub": "e745168f-addb-4456-a6fa-f4a336d874ac", "nome": "Deiverson Jorge Honorato Medeiros", "email": "deiverson.medeiros@estrategicengenharia.com.br", "email_verified": true, "phone_verified": false}	email	2025-10-03 21:28:18.172892+00	2025-10-03 21:28:18.172953+00	2025-10-03 21:28:18.172953+00	6864b197-fa82-488f-b525-f0f670ea98ff
a1aa1fde-03cb-42b3-bd67-4ac5def143db	a1aa1fde-03cb-42b3-bd67-4ac5def143db	{"sub": "a1aa1fde-03cb-42b3-bd67-4ac5def143db", "email": "teste1@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 18:36:25.135319+00	2025-10-13 18:36:25.135383+00	2025-10-13 18:36:25.135383+00	f3d13f2b-f7ed-451f-ab13-f688fe448ba5
3be90091-7fa2-45bd-9555-54fdf167fc1f	3be90091-7fa2-45bd-9555-54fdf167fc1f	{"sub": "3be90091-7fa2-45bd-9555-54fdf167fc1f", "email": "teste2@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:04:59.296259+00	2025-10-13 19:04:59.296313+00	2025-10-13 19:04:59.296313+00	7bd20ced-9227-4926-80df-b990e18b0c7f
973e7d99-94f8-4070-bd4f-e018ae92a6fd	973e7d99-94f8-4070-bd4f-e018ae92a6fd	{"sub": "973e7d99-94f8-4070-bd4f-e018ae92a6fd", "email": "teste6@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:12:22.262529+00	2025-10-13 19:12:22.262584+00	2025-10-13 19:12:22.262584+00	344421a3-e778-4d29-b6ab-55112930926d
8d7ad676-3611-4a3c-ae09-f707ebb8d3dc	8d7ad676-3611-4a3c-ae09-f707ebb8d3dc	{"sub": "8d7ad676-3611-4a3c-ae09-f707ebb8d3dc", "email": "teste7@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:18:28.004116+00	2025-10-13 19:18:28.004175+00	2025-10-13 19:18:28.004175+00	99107053-d021-410b-aaba-bbb417efe846
4ef296f5-a364-4da7-a2d6-6450cf81975a	4ef296f5-a364-4da7-a2d6-6450cf81975a	{"sub": "4ef296f5-a364-4da7-a2d6-6450cf81975a", "email": "teste8@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:21:24.935282+00	2025-10-13 19:21:24.935345+00	2025-10-13 19:21:24.935345+00	7eae0e6f-9720-4bc0-975c-37db122f7ae5
aece2423-01c8-4af2-bbed-4b7a1f7be300	aece2423-01c8-4af2-bbed-4b7a1f7be300	{"sub": "aece2423-01c8-4af2-bbed-4b7a1f7be300", "email": "teste9@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:28:48.612707+00	2025-10-13 19:28:48.612812+00	2025-10-13 19:28:48.612812+00	3cac9c03-4a76-47d4-b18f-b0ed09c98ff0
95aff25e-1b9e-416d-87fd-a3f67ea9cc23	95aff25e-1b9e-416d-87fd-a3f67ea9cc23	{"sub": "95aff25e-1b9e-416d-87fd-a3f67ea9cc23", "email": "teste10@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:30:55.016356+00	2025-10-13 19:30:55.016424+00	2025-10-13 19:30:55.016424+00	3e83fb41-9c36-4856-aa7c-43f204648034
f1a67bda-bd84-40ff-8714-f5db1b62b18d	f1a67bda-bd84-40ff-8714-f5db1b62b18d	{"sub": "f1a67bda-bd84-40ff-8714-f5db1b62b18d", "email": "teste11@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:46:04.500989+00	2025-10-13 19:46:04.501053+00	2025-10-13 19:46:04.501053+00	95511e58-16b2-4460-99c1-939fc5cfa77a
42e98858-58ef-47e9-9f0c-64206d665990	42e98858-58ef-47e9-9f0c-64206d665990	{"sub": "42e98858-58ef-47e9-9f0c-64206d665990", "email": "teste12@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:49:25.101011+00	2025-10-13 19:49:25.101072+00	2025-10-13 19:49:25.101072+00	de4d7d91-0922-4c35-8c0c-6ac775a2336b
90260bc3-dcdd-4905-8bd2-6b94569f5335	90260bc3-dcdd-4905-8bd2-6b94569f5335	{"sub": "90260bc3-dcdd-4905-8bd2-6b94569f5335", "email": "teste13@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:52:18.4343+00	2025-10-13 19:52:18.434367+00	2025-10-13 19:52:18.434367+00	2429deca-607d-4a33-ae52-b1309a04083b
54cb536b-eb18-484a-b1db-1728ebbad218	54cb536b-eb18-484a-b1db-1728ebbad218	{"sub": "54cb536b-eb18-484a-b1db-1728ebbad218", "email": "teste14@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 19:56:50.133226+00	2025-10-13 19:56:50.133283+00	2025-10-13 19:56:50.133283+00	aab89d19-4a6e-444c-943f-27705d13bb89
a2d13349-cc6f-4fdb-8dfc-378326445973	a2d13349-cc6f-4fdb-8dfc-378326445973	{"sub": "a2d13349-cc6f-4fdb-8dfc-378326445973", "email": "teste15@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 20:00:20.380821+00	2025-10-13 20:00:20.380878+00	2025-10-13 20:00:20.380878+00	5a3d750d-e469-406f-b66a-fc07927ab864
83946149-becc-4501-8893-fc5a0decf6d7	83946149-becc-4501-8893-fc5a0decf6d7	{"sub": "83946149-becc-4501-8893-fc5a0decf6d7", "email": "teste16@estrategicengenharia.com.br", "email_verified": false, "phone_verified": false}	email	2025-10-13 20:23:40.124467+00	2025-10-13 20:23:40.124526+00	2025-10-13 20:23:40.124526+00	cb4b2688-6d0f-427c-8a62-ccbbe02f2349
\.


--
-- Data for Name: instances; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.instances (id, uuid, raw_base_config, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: mfa_amr_claims; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_amr_claims (session_id, created_at, updated_at, authentication_method, id) FROM stdin;
5509758d-643d-49cd-8ecf-39e1ce5e2083	2025-10-04 15:26:55.806057+00	2025-10-04 15:26:55.806057+00	password	e72358c2-30e8-40b6-914f-f656b16bc7ad
e6638042-7039-46c6-a58e-f1bd168228c0	2025-10-06 14:33:09.046681+00	2025-10-06 14:33:09.046681+00	password	fc6088f7-f37f-49ef-8d13-e339e5cb10a0
0bf6bd5e-62f9-458b-9ec3-0f9c1bd7be05	2025-10-08 20:15:37.952739+00	2025-10-08 20:15:37.952739+00	password	0f9d3129-4efc-4812-9351-8fa57f244d66
13b95013-f826-4499-87c9-5a3a29a041bc	2025-10-15 10:28:04.804578+00	2025-10-15 10:28:04.804578+00	password	7833990f-ecdc-4ced-84f4-385eaa8f78ed
50d91ef4-7fbe-4fad-a6d2-9b3daf3bb4a3	2025-10-15 10:36:17.110145+00	2025-10-15 10:36:17.110145+00	password	883cfa87-ca7f-4921-9b8a-f0ff918c7c3f
\.


--
-- Data for Name: mfa_challenges; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_challenges (id, factor_id, created_at, verified_at, ip_address, otp_code, web_authn_session_data) FROM stdin;
\.


--
-- Data for Name: mfa_factors; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.mfa_factors (id, user_id, friendly_name, factor_type, status, created_at, updated_at, secret, phone, last_challenged_at, web_authn_credential, web_authn_aaguid) FROM stdin;
\.


--
-- Data for Name: oauth_authorizations; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_authorizations (id, authorization_id, client_id, user_id, redirect_uri, scope, state, resource, code_challenge, code_challenge_method, response_type, status, authorization_code, created_at, expires_at, approved_at) FROM stdin;
\.


--
-- Data for Name: oauth_clients; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_clients (id, client_secret_hash, registration_type, redirect_uris, grant_types, client_name, client_uri, logo_uri, created_at, updated_at, deleted_at, client_type) FROM stdin;
\.


--
-- Data for Name: oauth_consents; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.oauth_consents (id, user_id, client_id, scopes, granted_at, revoked_at) FROM stdin;
\.


--
-- Data for Name: one_time_tokens; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.one_time_tokens (id, user_id, token_type, token_hash, relates_to, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: refresh_tokens; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.refresh_tokens (instance_id, id, token, user_id, revoked, created_at, updated_at, parent, session_id) FROM stdin;
00000000-0000-0000-0000-000000000000	37	jihu3ro3mk5g	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 20:15:37.950398+00	2025-10-20 00:02:42.610378+00	\N	0bf6bd5e-62f9-458b-9ec3-0f9c1bd7be05
00000000-0000-0000-0000-000000000000	8	uabjyr45c3sa	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-04 15:26:55.804157+00	2025-10-04 16:25:15.241372+00	\N	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	9	kdww7tekwyzn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-04 16:25:15.242123+00	2025-10-04 21:14:07.146245+00	uabjyr45c3sa	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	10	hfbqrk6kvn53	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-04 21:14:07.146966+00	2025-10-04 22:15:08.134498+00	kdww7tekwyzn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	11	4ywwgcxziin7	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-04 22:15:08.135203+00	2025-10-04 23:13:38.790173+00	hfbqrk6kvn53	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	12	z4vw5m3phngh	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-04 23:13:38.790994+00	2025-10-05 00:15:56.535146+00	4ywwgcxziin7	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	13	4gjmemnugd3b	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 00:15:56.53599+00	2025-10-05 12:20:44.704788+00	z4vw5m3phngh	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	14	662t2gois2z3	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 12:20:44.705698+00	2025-10-05 13:19:29.21126+00	4gjmemnugd3b	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	15	5mxcttduv5hi	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 13:19:29.212091+00	2025-10-05 16:15:11.869028+00	662t2gois2z3	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	16	bsxnocies2v7	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 16:15:11.869743+00	2025-10-05 18:44:11.350902+00	5mxcttduv5hi	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	17	kzhz7b274otx	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 18:44:11.35168+00	2025-10-05 19:42:41.680306+00	bsxnocies2v7	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	18	vltsrie2wh4e	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 19:42:41.681124+00	2025-10-05 20:46:55.472865+00	kzhz7b274otx	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	19	varjiutwauw6	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 20:46:55.473689+00	2025-10-05 21:45:38.295597+00	vltsrie2wh4e	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	20	wv2r4aun3kaf	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 21:45:38.296345+00	2025-10-05 22:44:47.338254+00	varjiutwauw6	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	21	vh7loytxytx3	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-05 22:44:47.339054+00	2025-10-06 12:40:53.39454+00	wv2r4aun3kaf	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	22	lcwsgnusvngo	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-06 12:40:53.395452+00	2025-10-06 13:51:46.441388+00	vh7loytxytx3	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	24	2atvpcmsgcoh	e745168f-addb-4456-a6fa-f4a336d874ac	f	2025-10-06 14:33:09.043588+00	2025-10-06 14:33:09.043588+00	\N	e6638042-7039-46c6-a58e-f1bd168228c0
00000000-0000-0000-0000-000000000000	23	oq2yjhrkqhzj	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-06 13:51:46.442275+00	2025-10-06 18:38:53.575166+00	lcwsgnusvngo	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	25	i4cimsxekmnc	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-06 18:38:53.575925+00	2025-10-06 19:43:57.060056+00	oq2yjhrkqhzj	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	26	4xfvyuhldriw	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-06 19:43:57.060899+00	2025-10-07 00:36:47.625463+00	i4cimsxekmnc	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	27	6bnj2fgtydro	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 00:36:47.626304+00	2025-10-07 01:36:28.506971+00	4xfvyuhldriw	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	28	ibkgqstghawt	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 01:36:28.507709+00	2025-10-07 10:12:04.240411+00	6bnj2fgtydro	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	29	sbxriyfdaha6	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 10:12:04.241239+00	2025-10-07 20:35:14.766652+00	ibkgqstghawt	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	30	etn2ibinpv32	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 20:35:14.767498+00	2025-10-07 22:54:51.180364+00	sbxriyfdaha6	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	31	mej26c4el47n	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 22:54:51.181212+00	2025-10-07 23:56:12.433612+00	etn2ibinpv32	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	32	vtv2eeo2pad2	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-07 23:56:12.434399+00	2025-10-08 00:55:00.614534+00	mej26c4el47n	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	33	rm66tznknala	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 00:55:00.615354+00	2025-10-08 11:28:30.723985+00	vtv2eeo2pad2	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	34	kkhzjqphadym	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 11:28:30.724708+00	2025-10-08 18:50:34.680235+00	rm66tznknala	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	35	b534j5jcy2rp	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 18:50:34.681157+00	2025-10-08 19:48:54.885389+00	kkhzjqphadym	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	36	2q7did7tlf3m	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 19:48:54.886174+00	2025-10-08 22:42:56.071344+00	b534j5jcy2rp	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	38	lrce5frmlus4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 22:42:56.072161+00	2025-10-08 23:41:04.02939+00	2q7did7tlf3m	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	39	mix46aw27mpk	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-08 23:41:04.030162+00	2025-10-09 00:41:47.575319+00	lrce5frmlus4	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	40	hw7vmqbgfbgh	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-09 00:41:47.576139+00	2025-10-09 01:40:31.000108+00	mix46aw27mpk	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	41	qllntfzefly2	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-09 01:40:31.001116+00	2025-10-09 23:25:56.512254+00	hw7vmqbgfbgh	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	42	dzabpens45pn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-09 23:25:56.513055+00	2025-10-10 00:24:32.079126+00	qllntfzefly2	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	43	6lxv7tdnllsy	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-10 00:24:32.079965+00	2025-10-10 15:25:14.489774+00	dzabpens45pn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	44	vf7e3lldlgwj	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-10 15:25:14.490626+00	2025-10-10 20:11:29.560369+00	6lxv7tdnllsy	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	45	miq4g34hxpvy	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-10 20:11:29.561152+00	2025-10-10 21:09:47.6967+00	vf7e3lldlgwj	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	46	3rgxfepkd4hl	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-10 21:09:47.697538+00	2025-10-10 22:08:10.235531+00	miq4g34hxpvy	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	47	exbjld4i6ia4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-10 22:08:10.236392+00	2025-10-11 21:37:05.827922+00	3rgxfepkd4hl	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	48	fu2j6xku3o4x	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-11 21:37:05.828656+00	2025-10-11 22:35:36.56095+00	exbjld4i6ia4	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	49	vjjbopp5y7qg	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-11 22:35:36.56177+00	2025-10-11 23:36:26.555961+00	fu2j6xku3o4x	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	50	bixf6koe2l2i	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-11 23:36:26.55671+00	2025-10-12 00:35:51.920024+00	vjjbopp5y7qg	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	51	nhci6dtjtnch	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 00:35:51.92087+00	2025-10-12 10:01:58.27792+00	bixf6koe2l2i	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	52	5ycdleocq73d	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 10:01:58.278792+00	2025-10-12 11:15:51.292583+00	nhci6dtjtnch	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	53	2vuwoja4a4ca	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 11:15:51.293406+00	2025-10-12 12:18:58.86471+00	5ycdleocq73d	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	54	jxlumikyc5yc	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 12:18:58.865516+00	2025-10-12 13:26:58.052407+00	2vuwoja4a4ca	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	55	rypt5e6i36ns	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 13:26:58.053285+00	2025-10-12 14:25:24.047751+00	jxlumikyc5yc	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	56	nsavudguzrhn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-12 14:25:24.048534+00	2025-10-13 11:13:44.445806+00	rypt5e6i36ns	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	57	ukrlg3tcax56	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 11:13:44.446587+00	2025-10-13 12:26:28.123691+00	nsavudguzrhn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	60	owqok4ex5l2n	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 17:20:29.322719+00	2025-10-13 18:19:17.221119+00	3wx2vybfwcp4	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	58	fhtkotg6u3mk	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 12:26:28.124513+00	2025-10-13 13:36:35.392237+00	ukrlg3tcax56	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	59	3wx2vybfwcp4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 13:36:35.393397+00	2025-10-13 17:20:29.32192+00	fhtkotg6u3mk	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	61	o3ildxd4wsap	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 18:19:17.221931+00	2025-10-13 19:18:03.072147+00	owqok4ex5l2n	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	62	nwesv4jm74nn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 19:18:03.072957+00	2025-10-13 20:18:20.916738+00	o3ildxd4wsap	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	63	rpzlvid3xas2	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 20:18:20.917502+00	2025-10-13 21:19:33.386035+00	nwesv4jm74nn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	64	57lewye5jfcy	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 21:19:33.38688+00	2025-10-13 22:19:06.702323+00	rpzlvid3xas2	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	65	dl5wnm4466jv	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-13 22:19:06.703076+00	2025-10-14 10:06:31.219019+00	57lewye5jfcy	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	66	ku55heipnlmq	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 10:06:31.219871+00	2025-10-14 14:54:42.380424+00	dl5wnm4466jv	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	67	fi2klguwvxgy	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 14:54:42.381338+00	2025-10-14 16:33:36.279777+00	ku55heipnlmq	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	68	5mvfavrsc7kb	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 16:33:36.280534+00	2025-10-14 20:05:49.286318+00	fi2klguwvxgy	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	69	z7rarmjxz4mg	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 20:05:49.287119+00	2025-10-14 22:42:20.670392+00	5mvfavrsc7kb	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	70	5tfvsogfxrl3	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 22:42:20.671875+00	2025-10-14 23:55:33.017217+00	z7rarmjxz4mg	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	71	fjupeptnywmu	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-14 23:55:33.018122+00	2025-10-15 10:19:15.398032+00	5tfvsogfxrl3	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	73	xeiz2vaxmozj	a1aa1fde-03cb-42b3-bd67-4ac5def143db	f	2025-10-15 10:28:04.801843+00	2025-10-15 10:28:04.801843+00	\N	13b95013-f826-4499-87c9-5a3a29a041bc
00000000-0000-0000-0000-000000000000	72	2p6iu7zbdp5f	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 10:19:15.398723+00	2025-10-15 11:22:34.893198+00	fjupeptnywmu	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	74	phxhovjdxfqb	a1aa1fde-03cb-42b3-bd67-4ac5def143db	t	2025-10-15 10:36:17.107782+00	2025-10-15 11:34:37.433339+00	\N	50d91ef4-7fbe-4fad-a6d2-9b3daf3bb4a3
00000000-0000-0000-0000-000000000000	76	4tn4nzgzbpof	a1aa1fde-03cb-42b3-bd67-4ac5def143db	f	2025-10-15 11:34:37.434174+00	2025-10-15 11:34:37.434174+00	phxhovjdxfqb	50d91ef4-7fbe-4fad-a6d2-9b3daf3bb4a3
00000000-0000-0000-0000-000000000000	75	nctnwjvzbmh7	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 11:22:34.893978+00	2025-10-15 12:27:17.719324+00	2p6iu7zbdp5f	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	77	xpk4f22xl2dd	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 12:27:17.720067+00	2025-10-15 13:26:29.484403+00	nctnwjvzbmh7	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	78	kihp43yosyzv	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 13:26:29.493995+00	2025-10-15 14:32:53.38347+00	xpk4f22xl2dd	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	79	fljatbv34pki	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 14:32:53.384385+00	2025-10-15 15:31:18.906971+00	kihp43yosyzv	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	80	r6wdta42ivzt	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 15:31:18.907738+00	2025-10-15 17:24:54.090483+00	fljatbv34pki	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	81	7tr4e6vn5odx	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 17:24:54.091318+00	2025-10-15 18:23:24.845543+00	r6wdta42ivzt	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	82	keoaortx4kzn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 18:23:24.846379+00	2025-10-15 19:39:08.544085+00	7tr4e6vn5odx	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	83	umjxdq5rrvsl	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 19:39:08.544861+00	2025-10-15 20:37:56.762812+00	keoaortx4kzn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	84	5s3xaoxxj4zk	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 20:37:56.763686+00	2025-10-15 21:39:43.573592+00	umjxdq5rrvsl	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	85	crnuuj4xgnnn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 21:39:43.57429+00	2025-10-15 22:40:36.818427+00	5s3xaoxxj4zk	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	86	yzyphr6eeg34	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 22:40:36.819274+00	2025-10-15 23:50:01.414179+00	crnuuj4xgnnn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	87	dtmt6pfw665s	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-15 23:50:01.415079+00	2025-10-16 00:48:43.012862+00	yzyphr6eeg34	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	88	omknktakyrpr	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-16 00:48:43.013601+00	2025-10-16 10:12:28.287365+00	dtmt6pfw665s	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	89	2oeazdseyuud	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-16 10:12:28.288121+00	2025-10-16 20:04:29.311285+00	omknktakyrpr	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	90	7u76bnxma7bp	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-16 20:04:29.317561+00	2025-10-17 00:25:10.40959+00	2oeazdseyuud	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	91	zu36vbwfzpc5	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 00:25:10.410402+00	2025-10-17 13:15:41.742983+00	7u76bnxma7bp	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	92	5hn54xvvrbdn	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 13:15:41.743827+00	2025-10-17 14:19:49.43683+00	zu36vbwfzpc5	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	93	d724swdmoz6z	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 14:19:49.437609+00	2025-10-17 16:57:23.33933+00	5hn54xvvrbdn	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	94	sat2t3mdwxkp	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 16:57:23.340165+00	2025-10-17 17:55:50.656887+00	d724swdmoz6z	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	95	kgx3svk6ze6h	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 17:55:50.657695+00	2025-10-17 19:19:08.204501+00	sat2t3mdwxkp	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	96	z6azipsuseee	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 19:19:08.205294+00	2025-10-17 20:17:54.966448+00	kgx3svk6ze6h	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	97	6rrfbb5l3cc5	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 20:17:54.96717+00	2025-10-17 21:16:16.542546+00	z6azipsuseee	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	98	vkvehls3wufh	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-17 21:16:16.543324+00	2025-10-18 14:58:09.641177+00	6rrfbb5l3cc5	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	99	ixtiac4qlv5p	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 14:58:09.646568+00	2025-10-18 16:02:24.580349+00	vkvehls3wufh	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	100	lecangu3sjuc	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 16:02:24.581137+00	2025-10-18 17:01:12.614907+00	ixtiac4qlv5p	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	101	kdd7epbqq6rd	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 17:01:12.615861+00	2025-10-18 18:40:27.837518+00	lecangu3sjuc	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	102	7fgzxmshs4ep	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 18:40:27.838255+00	2025-10-18 19:38:43.096318+00	kdd7epbqq6rd	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	103	x3v3r2jg563u	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 19:38:43.097097+00	2025-10-18 20:45:53.893614+00	7fgzxmshs4ep	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	104	4ddzh3gc3fj4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 20:45:53.894393+00	2025-10-18 21:45:25.899651+00	x3v3r2jg563u	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	105	zav5b6gdoin5	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 21:45:25.900393+00	2025-10-18 22:50:04.285473+00	4ddzh3gc3fj4	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	106	gdzy3qcbmk3p	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-18 22:50:04.286359+00	2025-10-19 00:02:10.077428+00	zav5b6gdoin5	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	107	fluzy4pzrpz5	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 00:02:10.078315+00	2025-10-19 10:11:21.515688+00	gdzy3qcbmk3p	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	108	3lqab2s3px56	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 10:11:21.516591+00	2025-10-19 11:09:22.943439+00	fluzy4pzrpz5	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	109	msgzpvsw4yxs	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 11:09:22.944196+00	2025-10-19 12:07:57.140165+00	3lqab2s3px56	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	110	rjzmtrjduhik	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 12:07:57.140986+00	2025-10-19 13:05:58.907823+00	msgzpvsw4yxs	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	111	v5a5eoynskwx	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 13:05:58.908583+00	2025-10-19 22:43:23.497866+00	rjzmtrjduhik	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	112	3nfwd2bcwjpd	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 22:43:23.498791+00	2025-10-19 23:43:36.854553+00	v5a5eoynskwx	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	114	wdjpnz7lseam	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 00:02:42.611187+00	2025-10-20 01:01:19.495894+00	jihu3ro3mk5g	0bf6bd5e-62f9-458b-9ec3-0f9c1bd7be05
00000000-0000-0000-0000-000000000000	115	2a75qa43lkgt	e745168f-addb-4456-a6fa-f4a336d874ac	f	2025-10-20 01:01:19.496745+00	2025-10-20 01:01:19.496745+00	wdjpnz7lseam	0bf6bd5e-62f9-458b-9ec3-0f9c1bd7be05
00000000-0000-0000-0000-000000000000	113	5iyfrj7b2zjl	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-19 23:43:36.855329+00	2025-10-20 12:43:37.89322+00	3nfwd2bcwjpd	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	116	iozdwxzuoal6	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 12:43:37.894058+00	2025-10-20 14:21:44.148748+00	5iyfrj7b2zjl	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	117	jgrvcitchumz	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 14:21:44.149653+00	2025-10-20 15:33:35.946916+00	iozdwxzuoal6	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	118	elkzxu37dgkc	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 15:33:35.947701+00	2025-10-20 17:23:39.563008+00	jgrvcitchumz	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	119	ktl6zqbmvwl3	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 17:23:39.563726+00	2025-10-20 19:39:52.441501+00	elkzxu37dgkc	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	120	s3nwikckillx	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 19:39:52.442236+00	2025-10-20 20:45:25.214575+00	ktl6zqbmvwl3	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	121	jrw5bdh5stx4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 20:45:25.215489+00	2025-10-20 22:50:40.504655+00	s3nwikckillx	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	122	xtnvbtp3jwk4	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-20 22:50:40.505362+00	2025-10-20 23:48:42.841076+00	jrw5bdh5stx4	5509758d-643d-49cd-8ecf-39e1ce5e2083
00000000-0000-0000-0000-000000000000	123	t53we34zzkqu	e745168f-addb-4456-a6fa-f4a336d874ac	f	2025-10-20 23:48:42.841797+00	2025-10-20 23:48:42.841797+00	xtnvbtp3jwk4	5509758d-643d-49cd-8ecf-39e1ce5e2083
\.


--
-- Data for Name: saml_providers; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.saml_providers (id, sso_provider_id, entity_id, metadata_xml, metadata_url, attribute_mapping, created_at, updated_at, name_id_format) FROM stdin;
\.


--
-- Data for Name: saml_relay_states; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.saml_relay_states (id, sso_provider_id, request_id, for_email, redirect_to, created_at, updated_at, flow_state_id) FROM stdin;
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.schema_migrations (version) FROM stdin;
20171026211738
20171026211808
20171026211834
20180103212743
20180108183307
20180119214651
20180125194653
00
20210710035447
20210722035447
20210730183235
20210909172000
20210927181326
20211122151130
20211124214934
20211202183645
20220114185221
20220114185340
20220224000811
20220323170000
20220429102000
20220531120530
20220614074223
20220811173540
20221003041349
20221003041400
20221011041400
20221020193600
20221021073300
20221021082433
20221027105023
20221114143122
20221114143410
20221125140132
20221208132122
20221215195500
20221215195800
20221215195900
20230116124310
20230116124412
20230131181311
20230322519590
20230402418590
20230411005111
20230508135423
20230523124323
20230818113222
20230914180801
20231027141322
20231114161723
20231117164230
20240115144230
20240214120130
20240306115329
20240314092811
20240427152123
20240612123726
20240729123726
20240802193726
20240806073726
20241009103726
20250717082212
20250731150234
20250804100000
20250901200500
20250903112500
20250904133000
\.


--
-- Data for Name: sessions; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sessions (id, user_id, created_at, updated_at, factor_id, aal, not_after, refreshed_at, user_agent, ip, tag, oauth_client_id) FROM stdin;
13b95013-f826-4499-87c9-5a3a29a041bc	a1aa1fde-03cb-42b3-bd67-4ac5def143db	2025-10-15 10:28:04.798299+00	2025-10-15 10:28:04.798299+00	\N	aal1	\N	\N	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	177.183.183.167	\N	\N
50d91ef4-7fbe-4fad-a6d2-9b3daf3bb4a3	a1aa1fde-03cb-42b3-bd67-4ac5def143db	2025-10-15 10:36:17.106201+00	2025-10-15 11:34:37.437369+00	\N	aal1	\N	2025-10-15 11:34:37.437275	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	179.156.68.13	\N	\N
e6638042-7039-46c6-a58e-f1bd168228c0	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-06 14:33:09.042257+00	2025-10-06 14:33:09.042257+00	\N	aal1	\N	\N	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36	170.245.161.246	\N	\N
0bf6bd5e-62f9-458b-9ec3-0f9c1bd7be05	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-08 20:15:37.949023+00	2025-10-20 01:01:19.50263+00	\N	aal1	\N	2025-10-20 01:01:19.502543	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	177.183.183.167	\N	\N
5509758d-643d-49cd-8ecf-39e1ce5e2083	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-04 15:26:55.803225+00	2025-10-20 23:48:42.844908+00	\N	aal1	\N	2025-10-20 23:48:42.844822	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36	177.183.183.167	\N	\N
\.


--
-- Data for Name: sso_domains; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sso_domains (id, sso_provider_id, domain, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: sso_providers; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.sso_providers (id, resource_id, created_at, updated_at, disabled) FROM stdin;
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: auth; Owner: supabase_auth_admin
--

COPY auth.users (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, invited_at, confirmation_token, confirmation_sent_at, recovery_token, recovery_sent_at, email_change_token_new, email_change, email_change_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, is_super_admin, created_at, updated_at, phone, phone_confirmed_at, phone_change, phone_change_token, phone_change_sent_at, email_change_token_current, email_change_confirm_status, banned_until, reauthentication_token, reauthentication_sent_at, is_sso_user, deleted_at, is_anonymous) FROM stdin;
\N	4b3ddff3-505b-4e3d-af3d-0c824c9c7756	\N	\N	teste5@estrategicengenharia.com.br	$2a$06$QdhvmF7L8YQtyzDBiL0Lu.ladmJHXSxyqqAPv5oSQdKSqyZdqczZm	2025-10-13 19:17:06.148135+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	{"nome": "Teste 5"}	\N	2025-10-13 19:17:06.148135+00	2025-10-13 19:17:06.148135+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	e745168f-addb-4456-a6fa-f4a336d874ac	authenticated	authenticated	deiverson.medeiros@estrategicengenharia.com.br	$2a$10$ClZWpoXmdxfg7vOqHPxvXO9fOcIYawlYla9hfwLFdBmBaFbbUt15m	2025-10-03 21:28:33.478982+00	\N		2025-10-03 21:28:18.178469+00		\N			\N	2025-10-08 20:15:37.94894+00	{"provider": "email", "providers": ["email"]}	{"sub": "e745168f-addb-4456-a6fa-f4a336d874ac", "nome": "Deiverson Jorge Honorato Medeiros", "email": "deiverson.medeiros@estrategicengenharia.com.br", "email_verified": true, "phone_verified": false}	\N	2025-10-03 21:28:18.159372+00	2025-10-20 23:48:42.843218+00	\N	\N			\N		0	\N		\N	f	\N	f
\N	10fa61fd-2af9-47e4-81ff-203e074f1db2	\N	\N	teste3@estrategicengenharia.com.br	$2a$06$b3K5ejk.pKC/vxnYRE1c/uDuaGFTezUXy9Hqk2xqVS3cI.N9J0h1C	2025-10-13 19:02:48.806842+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	{"nome": "Teste 3"}	\N	2025-10-13 19:02:48.806842+00	2025-10-13 19:02:48.806842+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	95aff25e-1b9e-416d-87fd-a3f67ea9cc23	authenticated	authenticated	teste10@estrategicengenharia.com.br	$2a$10$tOTv02D7xA67dmfKTBr/KeG4m2W4k6zHMG3xUf2AQ/qE12VhiavFC	2025-10-13 19:30:55.020304+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 10", "email_verified": true}	\N	2025-10-13 19:30:55.011944+00	2025-10-13 19:30:55.02169+00	\N	\N			\N		0	\N		\N	f	\N	f
\N	c732b045-65b9-4cb0-b84b-cfca9987ec6a	\N	\N	teste4@estrategicengenharia.com.br	$2a$06$nYHkkvVWZpLSAnlZYILmaOrnnXGG6DOfqT9MTcgIDr3ArDm3QOcZq	2025-10-13 19:03:34.552867+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	{"nome": "Teste 4"}	\N	2025-10-13 19:03:34.552867+00	2025-10-13 19:03:34.552867+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	8d7ad676-3611-4a3c-ae09-f707ebb8d3dc	authenticated	authenticated	teste7@estrategicengenharia.com.br	$2a$10$zIMMCCeUev6aK1Rw76s2/uzQ/PjDGakmw12RGSEla3V/7H5SUs29K	2025-10-13 19:18:28.006557+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 7", "email_verified": true}	\N	2025-10-13 19:18:28.000365+00	2025-10-13 19:18:28.00744+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	3be90091-7fa2-45bd-9555-54fdf167fc1f	authenticated	authenticated	teste2@estrategicengenharia.com.br	$2a$10$Bg2C5BQtx.bV1x7BZLGvyO0NnVZEsPDM5kSBsC07dWbqLuNprLvVO	2025-10-13 19:04:59.299147+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 2", "email_verified": true}	\N	2025-10-13 19:04:59.292634+00	2025-10-13 19:04:59.300051+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	83946149-becc-4501-8893-fc5a0decf6d7	authenticated	authenticated	teste16@estrategicengenharia.com.br	$2a$10$TViYeRRlk4/dcvn6iifF6Ow2.njU0940vJi19fnO1czib2969ZfXa	2025-10-13 20:23:40.127833+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 16", "email_verified": true}	\N	2025-10-13 20:23:40.121165+00	2025-10-13 20:23:40.128892+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	973e7d99-94f8-4070-bd4f-e018ae92a6fd	authenticated	authenticated	teste6@estrategicengenharia.com.br	$2a$10$z1tVufl/ip70GOrHOgWHEe1Uv66gVkUKal1UdsyOW0f1tpurLphpi	2025-10-13 19:12:22.265247+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 6", "email_verified": true}	\N	2025-10-13 19:12:22.258781+00	2025-10-13 19:12:22.266171+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	90260bc3-dcdd-4905-8bd2-6b94569f5335	authenticated	authenticated	teste13@estrategicengenharia.com.br	$2a$10$ybaVTNP/uxsFN6hUoqriy.GQl//2NA0Jp2206fYM8q0HJPRAevsfG	2025-10-13 19:52:18.437332+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 13", "email_verified": true}	\N	2025-10-13 19:52:18.430499+00	2025-10-13 19:52:18.438443+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	4ef296f5-a364-4da7-a2d6-6450cf81975a	authenticated	authenticated	teste8@estrategicengenharia.com.br	$2a$10$T9sK/6pb3ZFciKWjy5TA/utMATekxihwD4Xr2OXjkDNG4KZkT68A2	2025-10-13 19:21:24.938224+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 8", "email_verified": true}	\N	2025-10-13 19:21:24.931407+00	2025-10-13 19:21:24.939233+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	f1a67bda-bd84-40ff-8714-f5db1b62b18d	authenticated	authenticated	teste11@estrategicengenharia.com.br	$2a$10$sqZy4M9xfzuWttQ94h3ZvOn/GLZmyLHLlcxC9RXtPKWY2PK1aMkvS	2025-10-13 19:46:04.503906+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 11", "email_verified": true}	\N	2025-10-13 19:46:04.497156+00	2025-10-13 19:46:04.504929+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	aece2423-01c8-4af2-bbed-4b7a1f7be300	authenticated	authenticated	teste9@estrategicengenharia.com.br	$2a$10$XyUML/X0YXV6hY.h0rfvROqhNClZaaxIotC6FoiQpuVuy93Pp0lGS	2025-10-13 19:28:48.615502+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 9", "email_verified": true}	\N	2025-10-13 19:28:48.608997+00	2025-10-13 19:28:48.616446+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	a2d13349-cc6f-4fdb-8dfc-378326445973	authenticated	authenticated	teste15@estrategicengenharia.com.br	$2a$10$W4gUTWuhbXy2HALhAbEKLOflC8GAGGRW68rfsr7wWIVM2HnqofDiS	2025-10-13 20:00:20.383649+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 15", "email_verified": true}	\N	2025-10-13 20:00:20.377047+00	2025-10-13 20:00:20.384587+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	42e98858-58ef-47e9-9f0c-64206d665990	authenticated	authenticated	teste12@estrategicengenharia.com.br	$2a$10$S2P1WTY.Iqy1I9.7F44gdOqMKX6h0z5dEF4t7Mr15IGkOVoq3.pHe	2025-10-13 19:49:25.103886+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 12", "email_verified": true}	\N	2025-10-13 19:49:25.097031+00	2025-10-13 19:49:25.104874+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	54cb536b-eb18-484a-b1db-1728ebbad218	authenticated	authenticated	teste14@estrategicengenharia.com.br	$2a$10$Lj4XAK7GlJgT1ZLrLYnpUuLpxVJAdy4md/xGGXPWtb4tigKordYWW	2025-10-13 19:56:50.136092+00	\N		\N		\N			\N	\N	{"provider": "email", "providers": ["email"]}	{"nome": "Teste 14", "email_verified": true}	\N	2025-10-13 19:56:50.129457+00	2025-10-13 19:56:50.137038+00	\N	\N			\N		0	\N		\N	f	\N	f
00000000-0000-0000-0000-000000000000	a1aa1fde-03cb-42b3-bd67-4ac5def143db	authenticated	authenticated	teste1@estrategicengenharia.com.br	$2a$10$bWvSit5NEr3Tpd6PNl3XpuE/4/S653Mdlb1LHEw7wwsm6HxI9R5K6	2025-10-13 18:36:25.139694+00	\N		\N		\N			\N	2025-10-15 10:36:17.106113+00	{"provider": "email", "providers": ["email"]}	{"nome": "Teste1", "email_verified": true}	\N	2025-10-13 18:36:25.124503+00	2025-10-15 11:34:37.435371+00	\N	\N			\N		0	\N		\N	f	\N	f
\.


--
-- Data for Name: aprovacoes_cotacao; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.aprovacoes_cotacao (id, cotacao_id, aprovador_id, nivel_aprovacao, status, data_aprovacao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: aprovacoes_requisicao; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.aprovacoes_requisicao (id, requisicao_id, aprovador_id, nivel_aprovacao, status, data_aprovacao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: avaliacoes_fornecedor; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.avaliacoes_fornecedor (id, fornecedor_id, pedido_id, avaliador_id, company_id, nota_prazo, nota_qualidade, nota_preco, nota_atendimento, observacoes, data_avaliacao, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: compras_recorrentes; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.compras_recorrentes (id, contrato_id, material_id, company_id, quantidade_mensal, valor_unitario, proxima_compra, frequencia_dias, status, observacoes, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: configuracoes_aprovacao; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.configuracoes_aprovacao (id, company_id, tipo_documento, valor_limite, nivel_aprovacao, departamento_id, classe_financeira, perfil_id, ativo, created_at, updated_at, created_by) FROM stdin;
77895c12-7b42-44ff-9802-1d9c14408602	a9784891-9d58-4cc4-8404-18032105c335	requisicao	1000.00	1	\N	\N	\N	t	2025-10-16 11:01:04.003383+00	2025-10-16 11:01:04.003383+00	e745168f-addb-4456-a6fa-f4a336d874ac
9a68f6fb-6bd3-41b1-a47b-b86a141c847e	a9784891-9d58-4cc4-8404-18032105c335	requisicao	5000.00	2	\N	\N	\N	t	2025-10-16 11:01:04.003383+00	2025-10-16 11:01:04.003383+00	e745168f-addb-4456-a6fa-f4a336d874ac
753afec0-3a48-4517-bc88-9c0b02fcc4d8	a9784891-9d58-4cc4-8404-18032105c335	requisicao	10000.00	3	\N	\N	\N	t	2025-10-16 11:01:04.003383+00	2025-10-16 11:01:04.003383+00	e745168f-addb-4456-a6fa-f4a336d874ac
fd1bb340-e65c-417a-a0c9-8484ce84a474	a9784891-9d58-4cc4-8404-18032105c335	requisicao	50000.00	4	\N	\N	\N	t	2025-10-16 11:01:04.003383+00	2025-10-16 11:01:04.003383+00	e745168f-addb-4456-a6fa-f4a336d874ac
b57ad7b9-ce20-4119-94a7-a4a91f103ee5	a9784891-9d58-4cc4-8404-18032105c335	cotacao	2000.00	1	\N	\N	\N	t	2025-10-16 11:01:04.063506+00	2025-10-16 11:01:04.063506+00	e745168f-addb-4456-a6fa-f4a336d874ac
50dcb158-8bbb-47e4-a7d8-0f3ecd6b31ec	a9784891-9d58-4cc4-8404-18032105c335	cotacao	10000.00	2	\N	\N	\N	t	2025-10-16 11:01:04.063506+00	2025-10-16 11:01:04.063506+00	e745168f-addb-4456-a6fa-f4a336d874ac
309058be-9951-4050-ad8a-98fec59c8ea5	a9784891-9d58-4cc4-8404-18032105c335	cotacao	25000.00	3	\N	\N	\N	t	2025-10-16 11:01:04.063506+00	2025-10-16 11:01:04.063506+00	e745168f-addb-4456-a6fa-f4a336d874ac
62636d99-567f-4cb1-a03d-006fbde3eaff	a9784891-9d58-4cc4-8404-18032105c335	cotacao	100000.00	4	\N	\N	\N	t	2025-10-16 11:01:04.063506+00	2025-10-16 11:01:04.063506+00	e745168f-addb-4456-a6fa-f4a336d874ac
83deaf53-eb62-4588-9a0b-5c4ba08fb105	a9784891-9d58-4cc4-8404-18032105c335	pedido	2000.00	1	\N	\N	\N	t	2025-10-16 11:01:04.11939+00	2025-10-16 11:01:04.11939+00	e745168f-addb-4456-a6fa-f4a336d874ac
56b32e36-00cf-4348-a463-64a92cbf4e59	a9784891-9d58-4cc4-8404-18032105c335	pedido	10000.00	2	\N	\N	\N	t	2025-10-16 11:01:04.11939+00	2025-10-16 11:01:04.11939+00	e745168f-addb-4456-a6fa-f4a336d874ac
4c67f81f-9769-4ca0-9450-08e0f68eb252	a9784891-9d58-4cc4-8404-18032105c335	pedido	25000.00	3	\N	\N	\N	t	2025-10-16 11:01:04.11939+00	2025-10-16 11:01:04.11939+00	e745168f-addb-4456-a6fa-f4a336d874ac
2e3a2674-8930-4bb8-96ce-78f2ea21c768	a9784891-9d58-4cc4-8404-18032105c335	pedido	100000.00	4	\N	\N	\N	t	2025-10-16 11:01:04.11939+00	2025-10-16 11:01:04.11939+00	e745168f-addb-4456-a6fa-f4a336d874ac
\.


--
-- Data for Name: contratos; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.contratos (id, fornecedor_id, company_id, numero_contrato, descricao, data_inicio, data_fim, renovacao_automatica, valor_total, valor_mensal, tipo_reajuste, indice_reajuste, percentual_reajuste, status, observacoes, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: cotacao_itens; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.cotacao_itens (id, cotacao_id, requisicao_item_id, material_id, quantidade, valor_unitario, valor_total, prazo_entrega, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: cotacoes; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.cotacoes (id, requisicao_id, fornecedor_id, numero_cotacao, data_cotacao, data_validade, status, metodo_envio, link_fornecedor, valor_total, desconto_percentual, valor_final, prazo_entrega, condicoes_pagamento, observacoes, anexos, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: fornecedores_dados; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.fornecedores_dados (id, partner_id, company_id, contato_principal, email_cotacao, telefone, celular, uf, cidade, endereco, cep, prazo_pagamento, desconto_padrao, limite_credito, nota_media, total_avaliacoes, status, observacoes, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: historico_compras; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.historico_compras (id, pedido_id, material_id, fornecedor_id, company_id, quantidade, valor_unitario, valor_total, data_compra, data_entrega, status, observacoes, created_at) FROM stdin;
\.


--
-- Data for Name: historico_precos; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.historico_precos (id, material_id, fornecedor_id, company_id, valor_unitario, quantidade, cotacao_id, pedido_id, data_cotacao, observacoes, created_at) FROM stdin;
\.


--
-- Data for Name: pedido_itens; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.pedido_itens (id, pedido_id, cotacao_item_id, material_id, quantidade, valor_unitario, valor_total, status, prazo_entrega, quantidade_entregue, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: pedidos_compra; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.pedidos_compra (id, cotacao_id, fornecedor_id, company_id, numero_pedido, data_pedido, data_entrega_prevista, data_entrega_real, status, valor_total, desconto_percentual, valor_final, cnpj_emissor, razao_social_emissor, observacoes, condicoes_especiais, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: requisicao_itens; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.requisicao_itens (id, requisicao_id, material_id, almoxarifado_id, quantidade, unidade_medida, valor_unitario_estimado, valor_total_estimado, especificacao_tecnica, observacoes, status, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: requisicoes_compra; Type: TABLE DATA; Schema: compras; Owner: postgres
--

COPY compras.requisicoes_compra (id, company_id, solicitante_id, centro_custo_id, projeto_id, numero_requisicao, data_solicitacao, data_necessidade, status, prioridade, valor_total_estimado, valor_total_aprovado, aprovado_por, data_aprovacao, observacoes_aprovacao, observacoes, justificativa, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: aprovacoes; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.aprovacoes (id, company_id, entidade_tipo, entidade_id, nivel_aprovacao, aprovador_id, status, data_aprovacao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: borderos; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.borderos (id, company_id, numero_borderos, data_geracao, data_vencimento, valor_total, quantidade_titulos, status, banco_codigo, arquivo_remessa, arquivo_retorno, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: conciliacoes_bancarias; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.conciliacoes_bancarias (id, company_id, conta_bancaria_id, data_conciliacao, saldo_banco, saldo_sistema, diferenca, status, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: configuracao_bancaria; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.configuracao_bancaria (id, company_id, nome_configuracao, banco_codigo, banco_nome, ambiente, client_id, client_secret, api_key, access_token, refresh_token, base_url, auth_url, api_version, grant_type, scope, token_expires_at, configuracao_banco, credenciais_validas, conectividade_ok, ultima_validacao, erro_validacao, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
7b43ee11-4715-406c-8ab9-ef711be6bda6	a9784891-9d58-4cc4-8404-18032105c335	ConfiguraÃ§Ã£o PadrÃ£o Bradesco	237	Banco Bradesco S.A.	sandbox	\N	\N	\N	\N	\N	https://sandbox.api.bradesco.com.br	\N	v1	client_credentials	\N	\N	{}	f	f	\N	\N	ConfiguraÃ§Ã£o inicial para testes	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-21 00:23:16.897148+00	2025-10-21 00:23:16.897148+00
\.


--
-- Data for Name: configuracao_fiscal; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.configuracao_fiscal (id, company_id, nome_configuracao, uf, tipo_documento, ambiente, certificado_digital, senha_certificado, data_validade_certificado, webservice_url, versao_layout, serie_numeracao, numero_inicial, numero_final, configuracao_uf, certificado_valido, conectividade_ok, ultima_validacao, erro_validacao, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
e36aa275-8550-450e-9db7-2b658ccbee0c	a9784891-9d58-4cc4-8404-18032105c335	ConfiguraÃ§Ã£o PadrÃ£o SP - NFe	SP	nfe	homologacao	\N	\N	\N	https://nfe.fazenda.sp.gov.br/ws/nfeautorizacao4.asmx	4.00	1	1	\N	{}	f	f	\N	\N	ConfiguraÃ§Ã£o inicial para testes	e745168f-addb-4456-a6fa-f4a336d874ac	t	2025-10-21 00:23:16.823809+00	2025-10-21 00:23:16.823809+00
\.


--
-- Data for Name: configuracoes_aprovacao; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.configuracoes_aprovacao (id, company_id, tipo_aprovacao, valor_limite, centro_custo_id, departamento, classe_financeira, usuario_id, nivel_aprovacao, is_active, created_by, created_at, updated_at) FROM stdin;
ae14bd95-89f7-4ac9-bed1-0f1bb2dca75d	a9784891-9d58-4cc4-8404-18032105c335	conta_pagar	1000.00	\N	\N	\N	\N	1	t	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.752961+00	2025-10-14 10:26:04.752961+00
59fd92f3-b4e8-41f6-b341-99a16eec8adc	a9784891-9d58-4cc4-8404-18032105c335	conta_pagar	5000.00	\N	\N	\N	\N	2	t	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.752961+00	2025-10-14 10:26:04.752961+00
647f7115-5e80-4b46-892e-64890de506a5	a9784891-9d58-4cc4-8404-18032105c335	conta_pagar	10000.00	\N	\N	\N	\N	3	t	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.752961+00	2025-10-14 10:26:04.752961+00
6f839a1c-1506-434c-aefb-e01f40221558	a9784891-9d58-4cc4-8404-18032105c335	conta_pagar	999999.99	\N	\N	\N	\N	4	t	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.752961+00	2025-10-14 10:26:04.752961+00
633d803f-5a0f-41cc-9207-b3641f59c729	a9784891-9d58-4cc4-8404-18032105c335	conta_receber	999999.99	\N	\N	\N	\N	1	t	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.752961+00	2025-10-14 10:26:04.752961+00
\.


--
-- Data for Name: contas_bancarias; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.contas_bancarias (id, company_id, banco_codigo, banco_nome, agencia, conta, tipo_conta, moeda, saldo_atual, saldo_disponivel, limite_credito, data_saldo, is_active, observacoes, created_by, created_at, updated_at) FROM stdin;
21667a92-c70f-4fa3-95bf-cdfee08d8459	a9784891-9d58-4cc4-8404-18032105c335	237	BANCO BRADESCO S.A.	1234	12345-6	corrente	BRL	50000.00	50000.00	0.00	2025-10-14	t	Conta principal da empresa	e745168f-addb-4456-a6fa-f4a336d874ac	2025-10-14 10:26:04.886696+00	2025-10-14 10:26:04.886696+00
\.


--
-- Data for Name: contas_pagar; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.contas_pagar (id, company_id, numero_titulo, fornecedor_id, fornecedor_nome, fornecedor_cnpj, descricao, valor_original, valor_atual, data_emissao, data_vencimento, data_pagamento, centro_custo_id, projeto_id, departamento, classe_financeira, categoria, status, forma_pagamento, conta_bancaria_id, observacoes, anexos, valor_desconto, valor_juros, valor_multa, valor_pago, data_aprovacao, aprovado_por, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: contas_receber; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.contas_receber (id, company_id, numero_titulo, cliente_id, cliente_nome, cliente_cnpj, descricao, valor_original, valor_atual, data_emissao, data_vencimento, data_recebimento, centro_custo_id, projeto_id, departamento, classe_financeira, categoria, status, forma_recebimento, conta_bancaria_id, observacoes, anexos, valor_desconto, valor_juros, valor_multa, valor_recebido, data_confirmacao, confirmado_por, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: fluxo_caixa; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.fluxo_caixa (id, company_id, data_projecao, tipo_movimento, categoria, descricao, valor, conta_bancaria_id, centro_custo_id, projeto_id, status, data_confirmacao, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: lancamentos_contabeis; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.lancamentos_contabeis (id, company_id, data_lancamento, conta_debito_id, conta_credito_id, valor, historico, documento, centro_custo_id, projeto_id, tipo_lancamento, origem_id, origem_tipo, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: log_validacao_integracao; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.log_validacao_integracao (id, company_id, tipo_integracao, configuracao_id, status, mensagem, detalhes, tempo_resposta_ms, created_by, created_at) FROM stdin;
\.


--
-- Data for Name: nfe; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.nfe (id, company_id, chave_acesso, numero_nfe, serie, data_emissao, data_saida, valor_total, valor_icms, valor_ipi, valor_pis, valor_cofins, status_sefaz, xml_nfe, danfe_url, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: nfse; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.nfse (id, company_id, numero_nfse, codigo_verificacao, data_emissao, data_competencia, valor_servico, valor_iss, valor_pis, valor_cofins, valor_csll, valor_ir, status_sefaz, xml_nfse, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: plano_contas; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.plano_contas (id, company_id, codigo, descricao, tipo_conta, nivel, conta_pai_id, is_active, observacoes, created_by, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: remessas_bancarias; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.remessas_bancarias (id, company_id, borderos_id, numero_remessa, data_remessa, banco_codigo, agencia, conta, arquivo_cnab, status, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: retornos_bancarios; Type: TABLE DATA; Schema: financeiro; Owner: postgres
--

COPY financeiro.retornos_bancarios (id, company_id, remessa_id, numero_retorno, data_retorno, banco_codigo, arquivo_retorno, status, observacoes, created_by, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: aprovacoes_unificada; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.aprovacoes_unificada (id, company_id, processo_tipo, processo_id, nivel_aprovacao, aprovador_id, status, data_aprovacao, observacoes, aprovador_original_id, transferido_em, transferido_por, motivo_transferencia, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: companies; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.companies (id, razao_social, nome_fantasia, cnpj, inscricao_estadual, endereco, contato, ativo, created_at, updated_at, numero_empresa) FROM stdin;
a9784891-9d58-4cc4-8404-18032105c335	Empresa Teste	Nova Empresa Teste	11.222.333/0001-44	6512351	\N	71955557777	t	2025-10-03 21:31:32.06255+00	2025-10-13 22:41:26.86973+00	01
\.


--
-- Data for Name: configuracoes_aprovacao_unificada; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.configuracoes_aprovacao_unificada (id, company_id, processo_tipo, centro_custo_id, departamento, classe_financeira, usuario_id, valor_limite, nivel_aprovacao, aprovadores, ativo, created_at, updated_at, created_by) FROM stdin;
\.


--
-- Data for Name: cost_centers; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.cost_centers (id, company_id, nome, codigo, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: entity_permissions; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.entity_permissions (id, profile_id, entity_name, can_read, can_create, can_edit, can_delete, created_at, updated_at) FROM stdin;
f82823f8-8b3b-43ba-9e9f-44a62fd3394d	2242ce27-800c-494e-b7b9-c75cb832aa4d	contas_pagar	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
4b7fd8ab-a507-4d2c-9b99-fc580a6939a5	2242ce27-800c-494e-b7b9-c75cb832aa4d	contas_receber	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
3008485f-d1fc-4b41-9416-718ce38ea8ab	2242ce27-800c-494e-b7b9-c75cb832aa4d	borderos	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
55138ec3-3eb9-45ec-a868-c8df8c1de1d5	2242ce27-800c-494e-b7b9-c75cb832aa4d	remessas_bancarias	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
40106c9f-fe63-45b0-b759-ee9ae57e4ac6	2242ce27-800c-494e-b7b9-c75cb832aa4d	retornos_bancarios	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
10f90440-9761-47a3-90aa-ee10675f93ac	2242ce27-800c-494e-b7b9-c75cb832aa4d	contas_bancarias	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
c1644b76-9097-4b91-8d61-5b1ce4c712fa	2242ce27-800c-494e-b7b9-c75cb832aa4d	conciliacoes_bancarias	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
4d151ef5-a0b9-4b35-885c-1baa058663a0	2242ce27-800c-494e-b7b9-c75cb832aa4d	fluxo_caixa	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
d042a8af-a0b4-48c0-8000-379adf9b42ca	2242ce27-800c-494e-b7b9-c75cb832aa4d	nfe	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
7212d5f6-3a27-4a80-a382-0bbcd1f96151	2242ce27-800c-494e-b7b9-c75cb832aa4d	nfse	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
c92a7ea7-d488-4b80-b54f-8862f3d32c30	2242ce27-800c-494e-b7b9-c75cb832aa4d	plano_contas	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
a4404434-ed94-473c-b954-c56c13096b74	2242ce27-800c-494e-b7b9-c75cb832aa4d	lancamentos_contabeis	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
05c7ac3c-f0f1-4890-beac-444f7986c3eb	2242ce27-800c-494e-b7b9-c75cb832aa4d	configuracoes_aprovacao	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
00a21765-a42e-4544-b42f-f7728c021ae0	2242ce27-800c-494e-b7b9-c75cb832aa4d	aprovacoes	t	t	t	t	2025-10-14 10:26:04.532644+00	2025-10-14 10:26:04.532644+00
2352920b-5dca-4834-83a7-dace3dce07af	20bef50d-2e82-4e1c-926d-c47b659e3cfd	contas_pagar	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
6dfc60a9-02cf-49b1-b87a-1b71df6a7ffd	20bef50d-2e82-4e1c-926d-c47b659e3cfd	contas_receber	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
bbeb3473-e430-4866-a1ea-959f390e973e	20bef50d-2e82-4e1c-926d-c47b659e3cfd	borderos	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
3cee1066-1ea6-4c11-b2c8-4af99289b901	20bef50d-2e82-4e1c-926d-c47b659e3cfd	remessas_bancarias	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
f0e4745f-4ccf-4e15-8bd2-7a4986180e4e	20bef50d-2e82-4e1c-926d-c47b659e3cfd	retornos_bancarios	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
31bb6c41-4030-4c0b-aa52-f8c99c68e5be	20bef50d-2e82-4e1c-926d-c47b659e3cfd	contas_bancarias	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
ebf41699-45af-48d3-a775-34c6e2f5e071	20bef50d-2e82-4e1c-926d-c47b659e3cfd	conciliacoes_bancarias	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
2ed9395b-103e-4513-b61e-1de34c93e79e	20bef50d-2e82-4e1c-926d-c47b659e3cfd	fluxo_caixa	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
4dbf4299-a399-4ee8-ac78-4bff0bc8d5e7	20bef50d-2e82-4e1c-926d-c47b659e3cfd	nfe	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
61087e53-0236-4aa2-8265-8b915720744f	20bef50d-2e82-4e1c-926d-c47b659e3cfd	nfse	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
8db1ad55-4280-499b-9c8b-342cfa2395b6	20bef50d-2e82-4e1c-926d-c47b659e3cfd	plano_contas	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
fb4844b7-b3fb-4166-8dcb-f8e604db391e	20bef50d-2e82-4e1c-926d-c47b659e3cfd	lancamentos_contabeis	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
1c78af62-afc3-4754-adda-9dd806a2cd35	20bef50d-2e82-4e1c-926d-c47b659e3cfd	configuracoes_aprovacao	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
7a8b417c-1718-46df-8898-8b958b6e5dbc	20bef50d-2e82-4e1c-926d-c47b659e3cfd	aprovacoes	t	t	t	t	2025-10-14 10:26:04.590752+00	2025-10-14 10:26:04.590752+00
e0cf8273-ecd1-4147-a3fc-29f6a7888cb8	34632fe2-980b-4382-b104-ea244ed586f8	contas_pagar	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
e3a156ef-0239-4083-b878-dbf894c0259f	34632fe2-980b-4382-b104-ea244ed586f8	contas_receber	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
9307644c-9292-4876-969f-039b38ab4e7b	34632fe2-980b-4382-b104-ea244ed586f8	borderos	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
947643f5-d3c7-4d6b-ab6f-4c16a58ae4fd	34632fe2-980b-4382-b104-ea244ed586f8	remessas_bancarias	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
8d40907c-88d2-4618-8f97-e40dea4b08a0	34632fe2-980b-4382-b104-ea244ed586f8	retornos_bancarios	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
de109d1f-eb0e-448f-a8fe-35a577bd83ac	34632fe2-980b-4382-b104-ea244ed586f8	contas_bancarias	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
b17d2f6b-a65f-4db0-8554-83c21296b8d7	34632fe2-980b-4382-b104-ea244ed586f8	conciliacoes_bancarias	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
f4ff43ef-7661-4ee7-aa32-aab012e25b5d	34632fe2-980b-4382-b104-ea244ed586f8	fluxo_caixa	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
0601d2a2-674a-4645-bd02-7542ab38202f	34632fe2-980b-4382-b104-ea244ed586f8	nfe	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
1b2dedf0-074a-48eb-a99a-8b191aa6efd9	34632fe2-980b-4382-b104-ea244ed586f8	nfse	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
33c68d79-d8b0-40e2-8308-258a891acbb8	34632fe2-980b-4382-b104-ea244ed586f8	plano_contas	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
0a2f33cf-f736-4544-afe5-785840b8b823	34632fe2-980b-4382-b104-ea244ed586f8	lancamentos_contabeis	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
388cc9d9-3514-4f61-b641-5f53c6e52f61	34632fe2-980b-4382-b104-ea244ed586f8	configuracoes_aprovacao	t	f	f	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
702d7a04-520c-4ec3-b3ae-67ee877de156	34632fe2-980b-4382-b104-ea244ed586f8	aprovacoes	t	t	t	f	2025-10-14 10:26:04.642808+00	2025-10-14 10:26:04.642808+00
bb2e6fee-3543-4e9b-ae2f-fd0884b841d7	3ce71d8d-c9eb-4b18-9fd4-a72720421441	contas_pagar	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
17808fcf-e803-4857-9a85-11d41e9b80e8	3ce71d8d-c9eb-4b18-9fd4-a72720421441	contas_receber	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
1bfcdeb6-61b6-4afc-ad82-5fb6b1427989	3ce71d8d-c9eb-4b18-9fd4-a72720421441	borderos	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
6e32e64b-6e95-4526-a970-3e4dc9721280	3ce71d8d-c9eb-4b18-9fd4-a72720421441	remessas_bancarias	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
a3abdfed-0d5d-4e05-9bf6-2d7728b5ee69	3ce71d8d-c9eb-4b18-9fd4-a72720421441	retornos_bancarios	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
b29ab572-c3c9-43d1-a8d6-f1920e416141	3ce71d8d-c9eb-4b18-9fd4-a72720421441	contas_bancarias	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
eee94a8f-1241-4bc8-ac7e-f4068061dac4	3ce71d8d-c9eb-4b18-9fd4-a72720421441	conciliacoes_bancarias	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
c17062d4-669b-4a2b-ba41-e42d73f08794	3ce71d8d-c9eb-4b18-9fd4-a72720421441	fluxo_caixa	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
436839e4-de78-44ce-99ea-a4d9767b8546	3ce71d8d-c9eb-4b18-9fd4-a72720421441	nfe	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
f4007524-1b0d-4801-9749-2999efdd90af	3ce71d8d-c9eb-4b18-9fd4-a72720421441	nfse	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
ae4e3e27-da0a-4146-8fd0-1e6b6ac241d2	3ce71d8d-c9eb-4b18-9fd4-a72720421441	plano_contas	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
5df657f8-e61e-444c-8abf-30caaf4727cf	3ce71d8d-c9eb-4b18-9fd4-a72720421441	lancamentos_contabeis	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
ea13b7b5-3902-4ca4-ba28-f96bb58fa11c	3ce71d8d-c9eb-4b18-9fd4-a72720421441	configuracoes_aprovacao	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
8d64c488-2f8c-48a2-aecc-7dc04f2ec9c3	3ce71d8d-c9eb-4b18-9fd4-a72720421441	aprovacoes	t	f	f	f	2025-10-14 10:26:04.696868+00	2025-10-14 10:26:04.696868+00
c297f5a5-cddc-49f9-89c8-9c965de792e7	20bef50d-2e82-4e1c-926d-c47b659e3cfd	estoque_atual	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
5e128485-8029-4fa5-a97f-fda4e8fe019d	20bef50d-2e82-4e1c-926d-c47b659e3cfd	movimentacoes_estoque	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
e3b2a021-9b9a-466f-878b-89e3955d7acf	20bef50d-2e82-4e1c-926d-c47b659e3cfd	entradas_materiais	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
5a548ba3-57f3-4724-8147-b87761cded83	20bef50d-2e82-4e1c-926d-c47b659e3cfd	entrada_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
f27b3163-f376-4d0f-ad56-667eb2b3196c	20bef50d-2e82-4e1c-926d-c47b659e3cfd	checklist_recebimento	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
471cbf1f-4cd8-4eea-98e4-74ad5625c812	2242ce27-800c-494e-b7b9-c75cb832aa4d	materials_equipment	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:09:05.011423+00
79386cde-7b6c-459e-82e0-48b293ba57d7	2242ce27-800c-494e-b7b9-c75cb832aa4d	usuarios	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.48837+00
6459a74d-518c-4422-b806-911aa832ddee	2242ce27-800c-494e-b7b9-c75cb832aa4d	empresas	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.548438+00
5ae12ab1-2829-4e97-a30c-71175ee995f4	2242ce27-800c-494e-b7b9-c75cb832aa4d	perfis	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.615362+00
817ec223-e6fc-4d9a-8514-35b2a524cd76	2242ce27-800c-494e-b7b9-c75cb832aa4d	projetos	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.672392+00
ac37db67-1a89-4914-9b61-e24d9811698d	2242ce27-800c-494e-b7b9-c75cb832aa4d	parceiros	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.815273+00
9fab920d-3bdf-462b-a57d-e05a1db86a71	2242ce27-800c-494e-b7b9-c75cb832aa4d	centros_custo	t	t	t	t	2025-10-04 13:33:37.058081+00	2025-10-20 23:42:44.872079+00
cd53e23e-f403-46ee-af52-98651f6b09af	2242ce27-800c-494e-b7b9-c75cb832aa4d	exames_periodicos	t	t	t	t	2025-10-11 22:51:53.806373+00	2025-10-20 23:42:45.272349+00
7c3876ce-90db-4ca5-ab7f-2bf73636f40a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	exames_periodicos	t	t	t	t	2025-10-11 22:51:53.806373+00	2025-10-20 23:42:45.272349+00
9310b30d-9dbb-4e2f-839d-92d7a0baf28f	20bef50d-2e82-4e1c-926d-c47b659e3cfd	acoes_disciplinares	t	t	t	t	2025-10-12 00:29:45.10982+00	2025-10-20 23:42:45.337903+00
526afb9e-9d14-496a-b780-1f291c99787b	34632fe2-980b-4382-b104-ea244ed586f8	acoes_disciplinares	t	t	t	f	2025-10-12 00:29:45.10982+00	2025-10-20 23:42:45.337903+00
62007e95-9bcb-4ab5-a2d9-54fcec38e446	3ce71d8d-c9eb-4b18-9fd4-a72720421441	acoes_disciplinares	f	f	f	f	2025-10-12 00:29:45.10982+00	2025-10-20 23:42:45.337903+00
45e2b927-de5a-4e91-92e4-934338ab6804	2242ce27-800c-494e-b7b9-c75cb832aa4d	acoes_disciplinares	t	t	t	t	2025-10-12 00:29:45.10982+00	2025-10-20 23:42:45.337903+00
e57e4389-d1cc-44d8-985e-184c71d8bfbc	20bef50d-2e82-4e1c-926d-c47b659e3cfd	treinamentos	t	t	t	t	2025-10-12 11:58:29.133938+00	2025-10-20 23:42:45.396867+00
904ecce2-0eef-4d96-98f1-fa73acfbe325	34632fe2-980b-4382-b104-ea244ed586f8	treinamentos	t	t	t	f	2025-10-12 11:58:29.133938+00	2025-10-20 23:42:45.396867+00
7caa7e63-c3c6-458e-8abd-f3d68e05335f	3ce71d8d-c9eb-4b18-9fd4-a72720421441	treinamentos	t	f	f	f	2025-10-12 11:58:29.133938+00	2025-10-20 23:42:45.396867+00
f346ddd5-a5c2-46a0-8778-477a7bc4ae90	2242ce27-800c-494e-b7b9-c75cb832aa4d	treinamentos	t	t	t	t	2025-10-12 11:58:29.133938+00	2025-10-20 23:42:45.396867+00
b8d63aba-7404-4daf-b2b2-7bfe4b11c51b	20bef50d-2e82-4e1c-926d-c47b659e3cfd	transferencias	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
480217f7-40d2-462e-9e29-027b7abfa915	20bef50d-2e82-4e1c-926d-c47b659e3cfd	transferencia_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
a8497df0-6be6-43ba-a9e9-f0adefd5a5ff	20bef50d-2e82-4e1c-926d-c47b659e3cfd	inventarios	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
4170e6fd-f883-4691-87f1-3d01ef3c4a34	20bef50d-2e82-4e1c-926d-c47b659e3cfd	inventario_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
8d4f1c2f-d733-4794-982f-01da43ae3aa1	34632fe2-980b-4382-b104-ea244ed586f8	estoque_atual	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
e98529a5-a1f6-4228-b532-f30782426a4b	34632fe2-980b-4382-b104-ea244ed586f8	movimentacoes_estoque	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
11ef3aa4-fd98-445e-a4e9-8bf719d2adc3	34632fe2-980b-4382-b104-ea244ed586f8	entradas_materiais	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
ee72541b-f906-48d6-b117-95e9d14752c5	34632fe2-980b-4382-b104-ea244ed586f8	entrada_itens	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
7842a564-2543-4849-a092-c41921aeb53d	34632fe2-980b-4382-b104-ea244ed586f8	checklist_recebimento	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
11961ca7-0a6b-40e3-b81c-f8b217b2e620	34632fe2-980b-4382-b104-ea244ed586f8	transferencias	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
6f8621fa-b903-4a81-bb1a-e88f54aa8beb	34632fe2-980b-4382-b104-ea244ed586f8	transferencia_itens	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
a82dcee0-b052-4f95-b5ae-fa49eeb3c4f8	34632fe2-980b-4382-b104-ea244ed586f8	inventarios	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
41ddb65c-1333-4443-aefe-d300e1ac29a5	34632fe2-980b-4382-b104-ea244ed586f8	inventario_itens	t	t	t	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
39cb33f2-4bea-4bda-af2c-a8ca695f27ea	3ce71d8d-c9eb-4b18-9fd4-a72720421441	estoque_atual	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
f9384cee-c475-4cfa-8c75-7f45cbb1e355	3ce71d8d-c9eb-4b18-9fd4-a72720421441	movimentacoes_estoque	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
cccd695c-bd9b-49d1-b30c-d835b3180d10	3ce71d8d-c9eb-4b18-9fd4-a72720421441	entradas_materiais	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
36b9a933-62dc-4a78-8393-bc2b570870b2	3ce71d8d-c9eb-4b18-9fd4-a72720421441	entrada_itens	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
15bd18e5-42a5-4af4-8a86-9aa187629e18	3ce71d8d-c9eb-4b18-9fd4-a72720421441	checklist_recebimento	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
b7df89ce-38f1-42b6-b96c-706dc4c0c2a0	3ce71d8d-c9eb-4b18-9fd4-a72720421441	transferencias	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
997695fd-6c03-4099-9476-a07d48c48ee1	3ce71d8d-c9eb-4b18-9fd4-a72720421441	transferencia_itens	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
e931dc86-e342-4573-8c9d-b8212798333f	3ce71d8d-c9eb-4b18-9fd4-a72720421441	inventarios	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
01069dc8-2864-4257-8f60-49e4990fa7f2	3ce71d8d-c9eb-4b18-9fd4-a72720421441	inventario_itens	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
5101fd1f-27b5-4904-a2e3-7c3581980ddc	2242ce27-800c-494e-b7b9-c75cb832aa4d	estoque_atual	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
3bd3a407-3b10-490a-99e6-1d5e050e3696	2242ce27-800c-494e-b7b9-c75cb832aa4d	movimentacoes_estoque	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
2339a904-4053-4c43-9e38-433892c805e2	2242ce27-800c-494e-b7b9-c75cb832aa4d	entradas_materiais	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
c5dd1600-b3e8-4718-99db-813277e03489	2242ce27-800c-494e-b7b9-c75cb832aa4d	entrada_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
7e9ed6d2-4df3-4e78-8fca-ffddc73cb3fc	2242ce27-800c-494e-b7b9-c75cb832aa4d	checklist_recebimento	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
64789819-fdd1-4233-b686-0933b853dfcc	2242ce27-800c-494e-b7b9-c75cb832aa4d	transferencias	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
bc754240-1766-406e-a337-193e21308068	2242ce27-800c-494e-b7b9-c75cb832aa4d	transferencia_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
5a85e025-c78b-4c55-a058-486b3dfbffa8	2242ce27-800c-494e-b7b9-c75cb832aa4d	inventarios	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
0f7a50f0-5d5d-4262-bffc-da87a837320e	2242ce27-800c-494e-b7b9-c75cb832aa4d	inventario_itens	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.607459+00
db32c7ba-bf1b-4a08-a8a7-70fc1b5f9246	20bef50d-2e82-4e1c-926d-c47b659e3cfd	almoxarifados	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
080cb6e2-33ab-4ea2-9a7d-a66f53179adc	34632fe2-980b-4382-b104-ea244ed586f8	almoxarifados	t	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
a51f9865-7552-49b1-97e8-6d2c1ceed913	3ce71d8d-c9eb-4b18-9fd4-a72720421441	almoxarifados	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
5b710956-9b71-4804-87cb-ba12321a8518	2242ce27-800c-494e-b7b9-c75cb832aa4d	almoxarifados	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
d3748a03-8fad-4a9f-ab50-07637d3f7edd	20bef50d-2e82-4e1c-926d-c47b659e3cfd	materiais_equipamentos	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
4c862e6e-8dec-4d1a-9d28-a5597ba142fa	34632fe2-980b-4382-b104-ea244ed586f8	materiais_equipamentos	t	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
f1876ab7-8e39-4d0a-8444-603842bfdc95	3ce71d8d-c9eb-4b18-9fd4-a72720421441	materiais_equipamentos	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
35f6e2cf-5c14-4916-bb24-852e4f390e9a	2242ce27-800c-494e-b7b9-c75cb832aa4d	materiais_equipamentos	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
8c55bf55-1e7f-4542-a3e2-6c54a967c0b0	20bef50d-2e82-4e1c-926d-c47b659e3cfd	solicitacoes_compra	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
ae862c34-e25c-4bb8-a663-6bef39f921d8	34632fe2-980b-4382-b104-ea244ed586f8	solicitacoes_compra	t	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
85ad8c1a-e2e5-4526-9796-7fc7cf74f1d4	3ce71d8d-c9eb-4b18-9fd4-a72720421441	solicitacoes_compra	f	f	f	f	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
75700768-1069-4b34-bcfe-2adf36cab9ed	2242ce27-800c-494e-b7b9-c75cb832aa4d	solicitacoes_compra	t	t	t	t	2025-10-14 23:29:32.607459+00	2025-10-14 23:29:32.661574+00
4a53d78c-4368-4964-9a9e-51ca1907ac2e	2242ce27-800c-494e-b7b9-c75cb832aa4d	funcionarios	t	t	t	t	2025-10-15 18:50:53.072005+00	2025-10-20 23:42:44.987204+00
bdb6f967-402b-4bb6-a2c7-321d6c21169e	2242ce27-800c-494e-b7b9-c75cb832aa4d	registros_ponto	t	t	t	t	2025-10-15 18:50:53.072005+00	2025-10-20 23:42:45.102747+00
e397d27d-c2e3-4f63-9ae7-ac2b4bf973fb	34632fe2-980b-4382-b104-ea244ed586f8	registros_ponto	f	f	f	f	2025-10-15 21:15:27.645934+00	2025-10-20 23:42:45.102747+00
1b2a0234-1eb4-40e9-99cf-f9c14feea23f	2242ce27-800c-494e-b7b9-c75cb832aa4d	ferias	t	t	t	t	2025-10-15 18:50:53.072005+00	2025-10-20 23:42:45.158597+00
b087e98e-5795-4283-92c5-46ebb88c415a	2242ce27-800c-494e-b7b9-c75cb832aa4d	reembolsos	t	t	t	t	2025-10-15 18:50:53.072005+00	2025-10-20 23:42:45.217371+00
fcbad3a0-a733-4835-960f-4a2110b513cd	20bef50d-2e82-4e1c-926d-c47b659e3cfd	materials_equipment	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:13:42.951138+00
2fb1d551-18dc-4ede-b7f7-9e06856d922d	34632fe2-980b-4382-b104-ea244ed586f8	materials_equipment	t	f	f	f	2025-10-20 23:16:14.652174+00	2025-10-20 23:16:14.652174+00
8c4aafcd-1baf-4857-91cb-e2390d629e98	3ce71d8d-c9eb-4b18-9fd4-a72720421441	materials_equipment	t	f	f	f	2025-10-20 23:16:23.359602+00	2025-10-20 23:16:23.359602+00
29c2f8de-7616-4b35-95e9-5c161c473427	20bef50d-2e82-4e1c-926d-c47b659e3cfd	cotacoes	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
acfcddb0-d3dd-46cf-b808-359c04a1a1ed	20bef50d-2e82-4e1c-926d-c47b659e3cfd	pedidos_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
e085e548-7ac7-48f1-97fc-bc163ea268ca	20bef50d-2e82-4e1c-926d-c47b659e3cfd	aprovacoes_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
83c4c735-9fe3-4589-b1e7-26209dd8c38d	20bef50d-2e82-4e1c-926d-c47b659e3cfd	fornecedores	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
b2ff87df-21e5-467a-9c20-e981b964d18f	20bef50d-2e82-4e1c-926d-c47b659e3cfd	contratos_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
f3555244-fcee-4f2b-9251-f3dcfa8d00cd	20bef50d-2e82-4e1c-926d-c47b659e3cfd	historico_compras	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
34e25de8-3f20-41e2-9266-9347416132eb	20bef50d-2e82-4e1c-926d-c47b659e3cfd	avaliacao_fornecedores	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
0815e5e5-32af-44d2-98c5-281d3dea6e0f	2242ce27-800c-494e-b7b9-c75cb832aa4d	cotacoes	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
e89eddee-0632-4c60-87de-58b88e5075c3	2242ce27-800c-494e-b7b9-c75cb832aa4d	pedidos_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
f52b0051-cbe5-4d50-b059-ff7c64c15fb7	2242ce27-800c-494e-b7b9-c75cb832aa4d	aprovacoes_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
2c75f662-7fc4-4d93-8f3b-40fae5554237	2242ce27-800c-494e-b7b9-c75cb832aa4d	fornecedores	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
70cae9d0-ce14-4e74-8a53-3260abe16d9a	2242ce27-800c-494e-b7b9-c75cb832aa4d	contratos_compra	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
bdbee250-4056-44a4-a9df-3f2b4ef5e59c	2242ce27-800c-494e-b7b9-c75cb832aa4d	historico_compras	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
56e1b5ba-4ab3-4ddd-8d62-a3751262287a	2242ce27-800c-494e-b7b9-c75cb832aa4d	avaliacao_fornecedores	t	t	t	t	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
2b18f666-25ce-4726-a9ca-0d526bfe214d	20bef50d-2e82-4e1c-926d-c47b659e3cfd	empresas	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.548438+00
2f0a078b-aedd-4a1c-97bd-321959c719d6	34632fe2-980b-4382-b104-ea244ed586f8	empresas	t	f	f	f	2025-10-20 23:16:13.683912+00	2025-10-20 23:42:44.548438+00
d1c8be3b-5b19-40e8-8293-3e357b8ea8c2	3ce71d8d-c9eb-4b18-9fd4-a72720421441	empresas	t	f	f	f	2025-10-20 23:16:22.479568+00	2025-10-20 23:42:44.548438+00
49af9a81-40b5-4c3d-b8c2-48b162163d98	20bef50d-2e82-4e1c-926d-c47b659e3cfd	perfis	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.615362+00
cee7afaa-1365-4716-a658-1a734fa76068	34632fe2-980b-4382-b104-ea244ed586f8	perfis	t	f	f	f	2025-10-20 23:16:14.034754+00	2025-10-20 23:42:44.615362+00
a2f8dc3f-d0e4-491e-9d43-c9b9cebb1ae7	3ce71d8d-c9eb-4b18-9fd4-a72720421441	perfis	t	f	f	f	2025-10-20 23:16:22.743102+00	2025-10-20 23:42:44.615362+00
b007c2b3-ad65-49ec-a980-ebed52dbc8ba	20bef50d-2e82-4e1c-926d-c47b659e3cfd	projetos	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.672392+00
48246825-5547-4cea-93b7-b23b7fb8f5a6	34632fe2-980b-4382-b104-ea244ed586f8	projetos	t	f	f	f	2025-10-20 23:16:14.355427+00	2025-10-20 23:42:44.672392+00
79457d9a-1bf9-4e99-9ecb-71b7cccdf55c	3ce71d8d-c9eb-4b18-9fd4-a72720421441	projetos	t	f	f	f	2025-10-20 23:16:23.012278+00	2025-10-20 23:42:44.672392+00
4879353b-56f5-44bd-acd0-49fa32d1decb	20bef50d-2e82-4e1c-926d-c47b659e3cfd	parceiros	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.815273+00
9c16a521-e33d-4e31-8884-e791a762bcaa	34632fe2-980b-4382-b104-ea244ed586f8	parceiros	t	f	f	f	2025-10-20 23:16:14.927064+00	2025-10-20 23:42:44.815273+00
b4fa3735-5c62-4178-ae47-51fda12f578c	3ce71d8d-c9eb-4b18-9fd4-a72720421441	parceiros	t	f	f	f	2025-10-20 23:16:23.637061+00	2025-10-20 23:42:44.815273+00
e711ea4f-124e-40aa-9f17-451d5bf87111	20bef50d-2e82-4e1c-926d-c47b659e3cfd	centros_custo	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.872079+00
989c40b1-24a5-4340-99ea-c1a15f37b3f8	34632fe2-980b-4382-b104-ea244ed586f8	centros_custo	t	f	f	f	2025-10-20 23:16:15.17979+00	2025-10-20 23:42:44.872079+00
caf3c3dd-104d-4b64-b414-756299437804	3ce71d8d-c9eb-4b18-9fd4-a72720421441	centros_custo	t	f	f	f	2025-10-20 23:16:23.888289+00	2025-10-20 23:42:44.872079+00
0d3768cc-18fc-41db-aa04-6ab9efac9d4b	20bef50d-2e82-4e1c-926d-c47b659e3cfd	unidades	t	t	t	t	2025-10-19 22:49:18.462756+00	2025-10-20 23:42:44.930473+00
a7cc35b0-f4bb-4f43-9a14-b1b489d55b44	34632fe2-980b-4382-b104-ea244ed586f8	unidades	t	t	t	f	2025-10-19 22:49:18.462756+00	2025-10-20 23:42:44.930473+00
f7f0519d-8be1-486b-a22d-1325862df100	3ce71d8d-c9eb-4b18-9fd4-a72720421441	unidades	f	f	f	f	2025-10-19 22:49:18.462756+00	2025-10-20 23:42:44.930473+00
fc6aa9e4-4e55-4655-8518-3ec22c47fc37	2242ce27-800c-494e-b7b9-c75cb832aa4d	unidades	t	t	t	t	2025-10-19 22:49:18.462756+00	2025-10-20 23:42:44.930473+00
a5a8d612-6265-4047-bfe0-92b06511b333	20bef50d-2e82-4e1c-926d-c47b659e3cfd	funcionarios	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.987204+00
f4ce66a4-a9ff-451b-87cf-70100c3767e7	34632fe2-980b-4382-b104-ea244ed586f8	funcionarios	t	f	f	f	2025-10-20 23:16:15.608488+00	2025-10-20 23:42:44.987204+00
03bc736f-280e-47c2-ae40-29c9ecc49556	3ce71d8d-c9eb-4b18-9fd4-a72720421441	funcionarios	t	f	f	f	2025-10-20 23:16:24.340153+00	2025-10-20 23:42:44.987204+00
3b00f05c-49a7-443f-8f70-d5e15545fbdc	2242ce27-800c-494e-b7b9-c75cb832aa4d	cargos	t	t	t	t	2025-10-19 11:42:01.036017+00	2025-10-20 23:42:45.044257+00
c18854f2-67f1-465c-bcfa-fdd62fd555ee	20bef50d-2e82-4e1c-926d-c47b659e3cfd	cargos	t	t	t	t	2025-10-19 11:42:01.098594+00	2025-10-20 23:42:45.044257+00
83a599b6-4b5e-4e4f-9f7f-feb6750fd4c2	34632fe2-980b-4382-b104-ea244ed586f8	cargos	t	t	t	f	2025-10-19 11:42:01.152612+00	2025-10-20 23:42:45.044257+00
4a8c6cd4-8e8a-4e93-b0d0-44aab181aac1	3ce71d8d-c9eb-4b18-9fd4-a72720421441	cargos	t	f	f	f	2025-10-19 11:42:01.211945+00	2025-10-20 23:42:45.044257+00
ff456176-5336-4078-a216-dce5de73fcf3	20bef50d-2e82-4e1c-926d-c47b659e3cfd	registros_ponto	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:45.102747+00
e020ff4e-4449-472d-b2e0-913e143d3f2e	3ce71d8d-c9eb-4b18-9fd4-a72720421441	registros_ponto	t	f	f	f	2025-10-20 23:16:24.783212+00	2025-10-20 23:42:45.102747+00
0ce138aa-0976-46e2-968a-da284286591a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	ferias	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:45.158597+00
ff402302-11ca-4249-8d57-e03900251a1b	34632fe2-980b-4382-b104-ea244ed586f8	ferias	t	f	f	f	2025-10-20 23:16:16.308745+00	2025-10-20 23:42:45.158597+00
063e7b46-af77-4a04-ba3e-2da6988b2c3a	3ce71d8d-c9eb-4b18-9fd4-a72720421441	ferias	t	f	f	f	2025-10-20 23:16:25.04192+00	2025-10-20 23:42:45.158597+00
7d1da680-60c0-400c-84e7-0427e14f4fe7	20bef50d-2e82-4e1c-926d-c47b659e3cfd	reembolsos	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:45.217371+00
841d1731-7a87-44e1-a1ec-ef6946a3d2e9	34632fe2-980b-4382-b104-ea244ed586f8	reembolsos	t	f	f	f	2025-10-20 23:16:16.606102+00	2025-10-20 23:42:45.217371+00
078bc865-abda-4092-b707-8af3f37800d6	3ce71d8d-c9eb-4b18-9fd4-a72720421441	reembolsos	t	f	f	f	2025-10-20 23:16:25.331253+00	2025-10-20 23:42:45.217371+00
4b4b9562-ecba-498e-8a1c-33ebd6e0e22c	34632fe2-980b-4382-b104-ea244ed586f8	cotacoes	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
376bd1c4-310c-4202-851c-3facd0a5bb80	34632fe2-980b-4382-b104-ea244ed586f8	pedidos_compra	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
fdcd421a-08eb-40ae-85df-8985ac698c32	34632fe2-980b-4382-b104-ea244ed586f8	aprovacoes_compra	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
a0f8f650-6f6b-4748-9450-17444fbaeafc	34632fe2-980b-4382-b104-ea244ed586f8	fornecedores	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
45141aa5-8d7a-4eb9-a099-5868eb3e79d0	34632fe2-980b-4382-b104-ea244ed586f8	contratos_compra	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
c5085736-fe1a-4d5c-a235-431c731ded8a	34632fe2-980b-4382-b104-ea244ed586f8	historico_compras	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
f530fbaf-fc13-492b-8a97-d00310babf0c	34632fe2-980b-4382-b104-ea244ed586f8	avaliacao_fornecedores	t	t	t	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
3438e7e5-1601-4a00-8edc-f151529a5c42	3ce71d8d-c9eb-4b18-9fd4-a72720421441	cotacoes	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
c0505e41-4322-4dff-b7c7-b9672ef8d089	3ce71d8d-c9eb-4b18-9fd4-a72720421441	pedidos_compra	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
b206f159-4cda-4c67-a3bb-d5d662b5ec67	3ce71d8d-c9eb-4b18-9fd4-a72720421441	aprovacoes_compra	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
cf5dce51-cf79-4dd2-899b-2385182e51bc	3ce71d8d-c9eb-4b18-9fd4-a72720421441	fornecedores	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
8cf18c57-8d7a-4f95-b9a8-feb46fbf06df	3ce71d8d-c9eb-4b18-9fd4-a72720421441	contratos_compra	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
fa8bbf49-8fe5-4191-84e1-27967b621a6d	3ce71d8d-c9eb-4b18-9fd4-a72720421441	historico_compras	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
0444f4ee-d668-420b-9020-50690791f5b3	3ce71d8d-c9eb-4b18-9fd4-a72720421441	avaliacao_fornecedores	f	f	f	f	2025-10-20 23:34:04.087405+00	2025-10-20 23:34:04.087405+00
def4a359-24bc-443b-8ca4-991abe88eec8	34632fe2-980b-4382-b104-ea244ed586f8	usuarios	f	f	f	f	2025-10-15 18:55:32.2642+00	2025-10-20 23:42:44.48837+00
daac2da4-258e-4acc-ac87-f0ef94ce1536	20bef50d-2e82-4e1c-926d-c47b659e3cfd	usuarios	t	t	t	t	2025-10-20 23:13:42.951138+00	2025-10-20 23:42:44.48837+00
5977cbf9-3f4d-4b21-bedd-4c277c7303e7	3ce71d8d-c9eb-4b18-9fd4-a72720421441	usuarios	t	f	f	f	2025-10-20 23:16:22.229364+00	2025-10-20 23:42:44.48837+00
e86be6bc-cf7a-4bc6-b6db-0ed527ea08d6	34632fe2-980b-4382-b104-ea244ed586f8	exames_periodicos	t	t	t	f	2025-10-11 22:51:53.806373+00	2025-10-20 23:42:45.272349+00
658ad083-e144-4a99-8511-0b880032d4fd	3ce71d8d-c9eb-4b18-9fd4-a72720421441	exames_periodicos	t	f	f	f	2025-10-11 22:51:53.806373+00	2025-10-20 23:42:45.272349+00
\.


--
-- Data for Name: historico_edicoes_solicitacoes; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.historico_edicoes_solicitacoes (id, company_id, processo_tipo, processo_id, usuario_editor_id, data_edicao, campos_alterados, valores_anteriores, valores_novos, aprovacoes_resetadas, data_reset, created_at) FROM stdin;
\.


--
-- Data for Name: module_permissions; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.module_permissions (id, profile_id, module_name, can_read, can_create, can_edit, can_delete, created_at, updated_at) FROM stdin;
76e60de4-8d38-44b9-9db9-d9715ac94c6c	2242ce27-800c-494e-b7b9-c75cb832aa4d	dashboard	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-04 13:33:24.583874+00
ac3a661c-5a3b-4f16-83a8-08209809900f	2242ce27-800c-494e-b7b9-c75cb832aa4d	configuracoes	t	t	t	t	2025-10-04 15:43:12.157125+00	2025-10-04 15:43:12.157125+00
4d91e404-8b44-45a3-9834-d4228f1b4d30	20bef50d-2e82-4e1c-926d-c47b659e3cfd	configuracoes	t	t	t	t	2025-10-04 15:43:20.182753+00	2025-10-04 15:43:20.182753+00
dd7e8463-8d1d-4dd6-ba73-7f49b7f3906a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	cadastros	t	t	t	t	2025-10-19 22:49:25.970922+00	2025-10-19 22:49:25.970922+00
386fb80a-b109-44c2-b16e-07e3a3d2c656	34632fe2-980b-4382-b104-ea244ed586f8	cadastros	t	t	t	f	2025-10-19 22:49:25.970922+00	2025-10-19 22:49:25.970922+00
c2aed148-47de-4625-a14b-61bff908a918	20bef50d-2e82-4e1c-926d-c47b659e3cfd	dashboard	t	t	t	t	2025-10-04 16:10:13.938451+00	2025-10-04 16:13:01.058775+00
5aef9002-ff8f-49ec-98f5-472f9fda5008	3ce71d8d-c9eb-4b18-9fd4-a72720421441	cadastros	t	f	f	f	2025-10-19 22:49:25.970922+00	2025-10-19 22:49:25.970922+00
f8220c39-71a8-49c7-9f4a-3edf8305ee2a	2242ce27-800c-494e-b7b9-c75cb832aa4d	cadastros	t	t	t	t	2025-10-19 22:49:25.970922+00	2025-10-19 22:49:25.970922+00
7eaa9ee0-a551-4737-942a-d70ee2641e03	2242ce27-800c-494e-b7b9-c75cb832aa4d	rh	t	t	t	t	2025-10-11 22:51:53.867549+00	2025-10-11 22:51:53.867549+00
34b31638-8803-4ca2-b2df-37734f3c9c1a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	rh	t	t	t	t	2025-10-11 22:51:53.867549+00	2025-10-11 22:51:53.867549+00
07e490fa-db68-4535-ba67-3c4583a78841	34632fe2-980b-4382-b104-ea244ed586f8	rh	t	t	t	f	2025-10-11 22:51:53.867549+00	2025-10-11 22:51:53.867549+00
940b88d4-de25-4217-9827-58f3de6245a4	3ce71d8d-c9eb-4b18-9fd4-a72720421441	rh	t	f	f	f	2025-10-11 22:51:53.867549+00	2025-10-11 22:51:53.867549+00
2b862149-6eb3-480b-94a4-a7da65e3b401	20bef50d-2e82-4e1c-926d-c47b659e3cfd	treinamento	t	t	t	t	2025-10-12 11:58:17.757163+00	2025-10-12 11:58:17.757163+00
964604a4-7199-458c-b6fc-01cf417bde85	34632fe2-980b-4382-b104-ea244ed586f8	treinamento	t	t	t	f	2025-10-12 11:58:17.757163+00	2025-10-12 11:58:17.757163+00
a00ddfba-6689-4b53-bb7d-46c1f1767f61	3ce71d8d-c9eb-4b18-9fd4-a72720421441	treinamento	t	f	f	f	2025-10-12 11:58:17.757163+00	2025-10-12 11:58:17.757163+00
5de34c83-9584-47a0-8058-28df3f31c7e4	2242ce27-800c-494e-b7b9-c75cb832aa4d	treinamento	t	t	t	t	2025-10-12 11:58:17.757163+00	2025-10-12 11:58:17.757163+00
d8a3b8a0-2788-46c9-bfa8-caf52a6488d8	2242ce27-800c-494e-b7b9-c75cb832aa4d	financeiro	t	t	t	t	2025-10-10 15:42:04.216167+00	2025-10-14 10:26:04.310494+00
805bc22a-9519-4ebd-bc7e-524b62915127	20bef50d-2e82-4e1c-926d-c47b659e3cfd	financeiro	t	t	t	t	2025-10-14 10:26:04.368669+00	2025-10-14 10:26:04.368669+00
5bfe4794-184c-4615-9504-1061e7b4a8ae	34632fe2-980b-4382-b104-ea244ed586f8	financeiro	t	t	t	f	2025-10-14 10:26:04.420515+00	2025-10-14 10:26:04.420515+00
8a9fe3e7-89c0-4a5d-8c3d-53fdfb785d28	3ce71d8d-c9eb-4b18-9fd4-a72720421441	financeiro	t	f	f	f	2025-10-14 10:26:04.472562+00	2025-10-14 10:26:04.472562+00
d38aecf0-09a5-421b-bc63-5653415869eb	20bef50d-2e82-4e1c-926d-c47b659e3cfd	almoxarifado	t	t	t	t	2025-10-14 23:29:32.553181+00	2025-10-14 23:29:32.553181+00
f575bc69-7723-4d54-bf4b-98cd19c9bdc5	34632fe2-980b-4382-b104-ea244ed586f8	almoxarifado	t	t	t	f	2025-10-14 23:29:32.553181+00	2025-10-14 23:29:32.553181+00
059a894b-78d6-4eeb-bb37-5b2cb3b9bf63	3ce71d8d-c9eb-4b18-9fd4-a72720421441	almoxarifado	f	f	f	f	2025-10-14 23:29:32.553181+00	2025-10-14 23:29:32.553181+00
f8752bbc-01c8-4ae1-92d6-e60d9be9740b	2242ce27-800c-494e-b7b9-c75cb832aa4d	almoxarifado	t	t	t	t	2025-10-14 23:29:32.553181+00	2025-10-14 23:29:32.553181+00
431e3953-6e26-4f53-b31b-e17110f398b9	2242ce27-800c-494e-b7b9-c75cb832aa4d	portal_colaborador	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
a7163bc1-e4b6-476f-b5f6-bcedd78b575c	2242ce27-800c-494e-b7b9-c75cb832aa4d	compras	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
1554900c-e34f-48d9-aba7-59cfdb880589	2242ce27-800c-494e-b7b9-c75cb832aa4d	logistica	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
c03c1adc-6a4a-4f54-9978-aee5af091a06	2242ce27-800c-494e-b7b9-c75cb832aa4d	frota	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
1f2a8de4-3e30-4f3b-a6ab-6db74fad43b0	2242ce27-800c-494e-b7b9-c75cb832aa4d	metalurgica	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
e3e3edbe-5551-48ca-aea0-61588aca16f7	2242ce27-800c-494e-b7b9-c75cb832aa4d	portal_gestor	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
e0cb0425-575d-4684-8bfb-d070be00f645	2242ce27-800c-494e-b7b9-c75cb832aa4d	comercial	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
9f795a97-15f2-4184-8e22-836a429c9d4f	2242ce27-800c-494e-b7b9-c75cb832aa4d	combustivel	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
6455ec93-4661-4ed6-b1ae-81aaf1af5f5c	2242ce27-800c-494e-b7b9-c75cb832aa4d	implantacao	t	t	t	t	2025-10-15 18:50:52.998172+00	2025-10-15 18:50:52.998172+00
d3f38130-e7a5-414f-85db-b0df78c00930	20bef50d-2e82-4e1c-926d-c47b659e3cfd	portal_colaborador	t	t	t	t	2025-10-20 23:02:43.346371+00	2025-10-20 23:02:43.346371+00
4d7b21a8-3eb8-44c5-9fed-9c20f7199477	20bef50d-2e82-4e1c-926d-c47b659e3cfd	portal_gestor	t	t	t	t	2025-10-20 23:02:43.879503+00	2025-10-20 23:02:43.879503+00
beffabe3-6646-4504-97aa-da58bc139da2	20bef50d-2e82-4e1c-926d-c47b659e3cfd	frota	t	t	t	t	2025-10-20 23:02:44.810623+00	2025-10-20 23:02:44.810623+00
44b6d2d4-e927-4ed8-af2a-6c05c64f4e28	2242ce27-800c-494e-b7b9-c75cb832aa4d	empresas	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-20 23:42:45.512261+00
902229e8-5ecf-4566-bd81-f860f68f652c	20bef50d-2e82-4e1c-926d-c47b659e3cfd	logistica	t	t	t	t	2025-10-20 23:02:45.110213+00	2025-10-20 23:02:45.110213+00
4ae3d1b1-b995-498d-bac0-edae291a62b9	20bef50d-2e82-4e1c-926d-c47b659e3cfd	combustivel	t	t	t	t	2025-10-20 23:02:46.040814+00	2025-10-20 23:02:46.040814+00
f03e9405-63f0-4946-851c-16cec182b22c	20bef50d-2e82-4e1c-926d-c47b659e3cfd	metalurgica	t	t	t	t	2025-10-20 23:02:46.414933+00	2025-10-20 23:02:46.414933+00
aa205930-c1ab-43d1-9c20-f371a0b3f0de	20bef50d-2e82-4e1c-926d-c47b659e3cfd	comercial	t	t	t	t	2025-10-20 23:02:46.69837+00	2025-10-20 23:02:46.69837+00
9222d83c-c038-4dc7-a27e-e78de4495bbc	3ce71d8d-c9eb-4b18-9fd4-a72720421441	dashboard	t	f	f	f	2025-10-20 23:02:54.498495+00	2025-10-20 23:02:54.498495+00
b207d52f-2f84-40d9-8d3d-253794bbfb5a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	compras	t	t	t	t	2025-10-16 11:01:03.831391+00	2025-10-16 11:01:03.831391+00
b33cd29d-5dec-422c-a6e3-ac107a18f2f3	34632fe2-980b-4382-b104-ea244ed586f8	compras	t	t	t	f	2025-10-16 11:01:03.891236+00	2025-10-16 11:01:03.891236+00
1a40d759-6e93-4591-acfc-7404ffde45f6	3ce71d8d-c9eb-4b18-9fd4-a72720421441	compras	t	f	f	f	2025-10-16 11:01:03.947317+00	2025-10-16 11:01:03.947317+00
00d4fc0e-9eb2-487c-97ae-b1fe9883d72c	34632fe2-980b-4382-b104-ea244ed586f8	dashboard	t	t	f	f	2025-10-15 17:37:20.584258+00	2025-10-19 10:36:00.027564+00
4f2a5c8c-454f-4e3c-a1a6-d4f195830b3d	20bef50d-2e82-4e1c-926d-c47b659e3cfd	implantacao	t	t	t	t	2025-10-20 23:02:47.008939+00	2025-10-20 23:02:47.008939+00
605d0aa6-bbd1-419d-ad9e-74bf81403142	34632fe2-980b-4382-b104-ea244ed586f8	configuracoes	t	f	f	f	2025-10-20 23:02:50.350073+00	2025-10-20 23:02:50.350073+00
96a9b8c8-06c7-4206-8e3e-50beebc83926	34632fe2-980b-4382-b104-ea244ed586f8	portal_colaborador	t	f	f	f	2025-10-20 23:02:50.720045+00	2025-10-20 23:02:50.720045+00
76116756-d2a7-4109-85f7-b0e75c5006f2	34632fe2-980b-4382-b104-ea244ed586f8	portal_gestor	t	f	f	f	2025-10-20 23:02:51.081448+00	2025-10-20 23:02:51.081448+00
cf9336ab-449d-4828-acf9-3dc14c549928	34632fe2-980b-4382-b104-ea244ed586f8	frota	t	f	f	f	2025-10-20 23:02:51.976453+00	2025-10-20 23:02:51.976453+00
2702200e-7b49-40f0-9b61-4e42cf5c010c	34632fe2-980b-4382-b104-ea244ed586f8	logistica	t	f	f	f	2025-10-20 23:02:52.290242+00	2025-10-20 23:02:52.290242+00
e20ccd1e-3615-4a4e-ae13-b13d7c96b0ee	34632fe2-980b-4382-b104-ea244ed586f8	combustivel	t	f	f	f	2025-10-20 23:02:53.180147+00	2025-10-20 23:02:53.180147+00
23559ba4-e135-4630-a49c-fa85858c7846	34632fe2-980b-4382-b104-ea244ed586f8	metalurgica	t	f	f	f	2025-10-20 23:02:53.486572+00	2025-10-20 23:02:53.486572+00
c8080e80-ca08-4d95-af72-4d8283b7c6bf	34632fe2-980b-4382-b104-ea244ed586f8	comercial	t	f	f	f	2025-10-20 23:02:53.834186+00	2025-10-20 23:02:53.834186+00
ae30de16-4c84-4ccd-9850-314c654854c0	34632fe2-980b-4382-b104-ea244ed586f8	implantacao	t	f	f	f	2025-10-20 23:02:54.162387+00	2025-10-20 23:02:54.162387+00
a676d7cd-3624-4697-b679-837432796467	3ce71d8d-c9eb-4b18-9fd4-a72720421441	configuracoes	t	f	f	f	2025-10-20 23:02:56.683042+00	2025-10-20 23:02:56.683042+00
d2d3e997-ed81-4f96-a661-7407a9e98c62	3ce71d8d-c9eb-4b18-9fd4-a72720421441	portal_colaborador	t	f	f	f	2025-10-20 23:02:56.980941+00	2025-10-20 23:02:56.980941+00
0c79b88c-1cf7-420f-bf57-83c9bc0a7861	2242ce27-800c-494e-b7b9-c75cb832aa4d	usuarios	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-20 23:42:45.454215+00
717c6d7b-9a2b-4d8f-8454-71a45f66bb88	20bef50d-2e82-4e1c-926d-c47b659e3cfd	usuarios	t	f	f	f	2025-10-04 15:46:19.490698+00	2025-10-20 23:42:45.454215+00
8a2b0e07-4b17-4b1a-92f9-0a43d5d8f03a	20bef50d-2e82-4e1c-926d-c47b659e3cfd	empresas	t	t	t	t	2025-10-20 23:02:41.441681+00	2025-10-20 23:42:45.512261+00
465d83b3-b726-4cd3-9a90-8e95c200473a	34632fe2-980b-4382-b104-ea244ed586f8	empresas	t	f	f	f	2025-10-15 20:58:53.865523+00	2025-10-20 23:42:45.512261+00
cc9c1281-56d1-43a7-b154-64faeaf3dae9	3ce71d8d-c9eb-4b18-9fd4-a72720421441	empresas	t	f	f	f	2025-10-20 23:02:55.158579+00	2025-10-20 23:42:45.512261+00
abe9035f-1479-49bc-9cef-986bf70154f5	2242ce27-800c-494e-b7b9-c75cb832aa4d	projetos	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-20 23:42:45.570363+00
54b3dfb1-4d11-4884-bb4f-5d531d48be02	20bef50d-2e82-4e1c-926d-c47b659e3cfd	projetos	t	t	t	t	2025-10-20 23:02:41.879017+00	2025-10-20 23:42:45.570363+00
a952f1c0-6d6f-44c9-b755-c2b7362a92da	34632fe2-980b-4382-b104-ea244ed586f8	projetos	t	f	f	f	2025-10-15 20:58:53.865523+00	2025-10-20 23:42:45.570363+00
30325bde-969d-46f1-a936-b717e5e4a4ef	3ce71d8d-c9eb-4b18-9fd4-a72720421441	projetos	t	f	f	f	2025-10-20 23:02:55.467671+00	2025-10-20 23:42:45.570363+00
c92cac38-0b90-4f43-a5a4-42df07332048	20bef50d-2e82-4e1c-926d-c47b659e3cfd	materiais_equipamentos	t	t	t	t	2025-10-20 23:02:42.181867+00	2025-10-20 23:42:45.628329+00
50b13079-9dba-4667-b3fe-1e3ee1023da4	34632fe2-980b-4382-b104-ea244ed586f8	materiais_equipamentos	t	f	f	f	2025-10-20 23:02:48.298065+00	2025-10-20 23:42:45.628329+00
3e9918bf-ac8e-42ee-a8db-4b2847919521	3ce71d8d-c9eb-4b18-9fd4-a72720421441	materiais_equipamentos	t	f	f	f	2025-10-20 23:02:55.750226+00	2025-10-20 23:42:45.628329+00
6e14639e-90c4-4438-9850-d81066f11243	2242ce27-800c-494e-b7b9-c75cb832aa4d	parceiros	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-20 23:42:45.686279+00
33d364e0-af18-4f9b-8364-daf0255e0bd3	20bef50d-2e82-4e1c-926d-c47b659e3cfd	parceiros	t	t	t	t	2025-10-20 23:02:42.523577+00	2025-10-20 23:42:45.686279+00
5474f86e-96c4-414f-bc79-dc093a3b53b0	34632fe2-980b-4382-b104-ea244ed586f8	parceiros	t	f	f	f	2025-10-15 20:58:53.865523+00	2025-10-20 23:42:45.686279+00
808dc6dd-2b72-43d4-9b8c-698e7b4ebd9f	2242ce27-800c-494e-b7b9-c75cb832aa4d	centros_custo	t	t	t	t	2025-10-04 13:33:24.583874+00	2025-10-20 23:42:45.744396+00
577243aa-cccf-44d3-8620-152085d7d10c	20bef50d-2e82-4e1c-926d-c47b659e3cfd	centros_custo	t	t	t	t	2025-10-20 23:02:42.818518+00	2025-10-20 23:42:45.744396+00
e294f1ff-99fe-4c31-8601-bcb4a1fa965b	34632fe2-980b-4382-b104-ea244ed586f8	centros_custo	t	f	f	f	2025-10-15 20:58:53.865523+00	2025-10-20 23:42:45.744396+00
df743b2b-d33e-4f40-a3aa-9f65e318c9c7	3ce71d8d-c9eb-4b18-9fd4-a72720421441	centros_custo	t	f	f	f	2025-10-20 23:02:56.336168+00	2025-10-20 23:42:45.744396+00
c1c799d5-ec31-4d00-ba9f-5f627cdf49a5	20bef50d-2e82-4e1c-926d-c47b659e3cfd	recrutamento	t	t	t	t	2025-10-12 11:13:45.305992+00	2025-10-20 23:42:45.798236+00
aee9e7e6-f7d7-4d6b-8ad1-268e76825f3a	34632fe2-980b-4382-b104-ea244ed586f8	recrutamento	t	t	t	t	2025-10-12 11:13:45.305992+00	2025-10-20 23:42:45.798236+00
132ea428-2524-450d-9434-897e041663a5	2242ce27-800c-494e-b7b9-c75cb832aa4d	recrutamento	t	t	t	t	2025-10-12 11:13:45.305992+00	2025-10-20 23:42:45.798236+00
11fec3b7-7127-4ab4-b4fd-22d59a814111	3ce71d8d-c9eb-4b18-9fd4-a72720421441	recrutamento	t	f	f	f	2025-10-12 11:13:53.820277+00	2025-10-20 23:42:45.798236+00
85b5fe41-9bdf-45cf-8ab6-612bb324b039	3ce71d8d-c9eb-4b18-9fd4-a72720421441	portal_gestor	t	f	f	f	2025-10-20 23:02:57.312859+00	2025-10-20 23:02:57.312859+00
4dbdb858-d9a2-464b-9e69-41fcbfed49fe	3ce71d8d-c9eb-4b18-9fd4-a72720421441	combustivel	t	f	f	f	2025-10-20 23:02:59.4833+00	2025-10-20 23:02:59.4833+00
7300fd8d-b250-4f53-8d97-919723946cc5	3ce71d8d-c9eb-4b18-9fd4-a72720421441	metalurgica	t	f	f	f	2025-10-20 23:02:59.822921+00	2025-10-20 23:02:59.822921+00
160ef4a4-1f49-4dda-abcf-c6fa0051c55d	3ce71d8d-c9eb-4b18-9fd4-a72720421441	comercial	t	f	f	f	2025-10-20 23:03:00.162994+00	2025-10-20 23:03:00.162994+00
398f3aa5-b1d3-4a16-83c9-0f0907655da4	3ce71d8d-c9eb-4b18-9fd4-a72720421441	implantacao	t	f	f	f	2025-10-20 23:03:00.485235+00	2025-10-20 23:03:00.485235+00
0f37abcd-37e8-4452-a8b5-32ab5f8f9585	3ce71d8d-c9eb-4b18-9fd4-a72720421441	frota	t	f	f	f	2025-10-20 23:02:58.248478+00	2025-10-20 23:02:58.248478+00
221c7279-11f6-45e9-aaf0-b28cb74d082e	3ce71d8d-c9eb-4b18-9fd4-a72720421441	logistica	t	f	f	f	2025-10-20 23:02:58.56711+00	2025-10-20 23:02:58.56711+00
d6a7d30c-b599-4922-9af8-2fc316bd174a	34632fe2-980b-4382-b104-ea244ed586f8	usuarios	t	f	f	f	2025-10-15 18:54:32.573166+00	2025-10-20 23:42:45.454215+00
2086ea10-642c-483c-92c6-8d864256155c	3ce71d8d-c9eb-4b18-9fd4-a72720421441	usuarios	t	f	f	f	2025-10-20 23:02:54.840278+00	2025-10-20 23:42:45.454215+00
9cd52880-ab0f-4d4c-a6d1-1dd4ea6fb8ed	2242ce27-800c-494e-b7b9-c75cb832aa4d	materiais_equipamentos	t	t	t	t	2025-10-20 23:09:05.125008+00	2025-10-20 23:42:45.628329+00
682ad360-f8ad-44e8-a03c-0072fa90414f	3ce71d8d-c9eb-4b18-9fd4-a72720421441	parceiros	t	f	f	f	2025-10-20 23:02:56.045003+00	2025-10-20 23:42:45.686279+00
\.


--
-- Data for Name: notifications; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.notifications (id, user_id, company_id, type, title, message, data, is_read, read_at, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: partners; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.partners (id, company_id, tipo, razao_social, nome_fantasia, cnpj, matriz_id, endereco, contato, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: profiles; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.profiles (id, nome, descricao, permissoes, created_at, updated_at, is_active) FROM stdin;
20bef50d-2e82-4e1c-926d-c47b659e3cfd	Administrador	Acesso completo ao sistema	{"admin": true, "all_modules": true}	2025-10-03 21:23:40.043216+00	2025-10-03 21:23:40.043216+00	t
34632fe2-980b-4382-b104-ea244ed586f8	Gerente	Acesso de gerência	{"manager": true, "view_reports": true}	2025-10-03 21:23:40.043216+00	2025-10-03 21:23:40.043216+00	t
3ce71d8d-c9eb-4b18-9fd4-a72720421441	Usuário	Acesso básico	{"user": true, "view_only": false}	2025-10-03 21:23:40.043216+00	2025-10-03 21:23:40.043216+00	t
2242ce27-800c-494e-b7b9-c75cb832aa4d	Super Admin	Acesso total ao sistema	{"admin": true, "all_modules": true}	2025-10-04 13:33:13.175734+00	2025-10-04 15:22:40.252923+00	t
\.


--
-- Data for Name: projects; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.projects (id, company_id, cost_center_id, nome, codigo, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: user_companies; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.user_companies (id, user_id, company_id, profile_id, ativo, created_at) FROM stdin;
dc6eac5d-6ea7-4bb8-a753-b1a17e0cb00b	e745168f-addb-4456-a6fa-f4a336d874ac	a9784891-9d58-4cc4-8404-18032105c335	2242ce27-800c-494e-b7b9-c75cb832aa4d	t	2025-10-03 21:32:27.311286+00
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, nome, email, ativo, created_at, updated_at, company_id) FROM stdin;
e745168f-addb-4456-a6fa-f4a336d874ac	Deiverson Jorge Honorato Medeiros	deiverson.medeiros@estrategicengenharia.com.br	t	2025-10-03 21:28:18.158356+00	2025-10-04 16:23:23.061595+00	a9784891-9d58-4cc4-8404-18032105c335
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: realtime; Owner: supabase_admin
--

COPY realtime.schema_migrations (version, inserted_at) FROM stdin;
20211116024918	2025-10-03 10:30:36
20211116045059	2025-10-03 10:30:40
20211116050929	2025-10-03 10:30:43
20211116051442	2025-10-03 10:30:47
20211116212300	2025-10-03 10:30:51
20211116213355	2025-10-03 10:30:54
20211116213934	2025-10-03 10:30:57
20211116214523	2025-10-03 10:31:02
20211122062447	2025-10-03 10:31:05
20211124070109	2025-10-03 10:31:08
20211202204204	2025-10-03 10:31:11
20211202204605	2025-10-03 10:31:15
20211210212804	2025-10-03 10:31:25
20211228014915	2025-10-03 10:31:28
20220107221237	2025-10-03 10:31:31
20220228202821	2025-10-03 10:31:35
20220312004840	2025-10-03 10:31:38
20220603231003	2025-10-03 10:31:43
20220603232444	2025-10-03 10:31:47
20220615214548	2025-10-03 10:31:51
20220712093339	2025-10-03 10:31:54
20220908172859	2025-10-03 10:31:57
20220916233421	2025-10-03 10:32:00
20230119133233	2025-10-03 10:32:04
20230128025114	2025-10-03 10:32:08
20230128025212	2025-10-03 10:32:11
20230227211149	2025-10-03 10:32:15
20230228184745	2025-10-03 10:32:18
20230308225145	2025-10-03 10:32:21
20230328144023	2025-10-03 10:32:25
20231018144023	2025-10-03 10:32:29
20231204144023	2025-10-03 10:32:34
20231204144024	2025-10-03 10:32:37
20231204144025	2025-10-03 10:32:41
20240108234812	2025-10-03 10:32:44
20240109165339	2025-10-03 10:32:47
20240227174441	2025-10-03 10:32:53
20240311171622	2025-10-03 10:32:58
20240321100241	2025-10-03 10:33:05
20240401105812	2025-10-03 10:33:14
20240418121054	2025-10-03 10:33:18
20240523004032	2025-10-03 10:33:30
20240618124746	2025-10-03 10:33:33
20240801235015	2025-10-03 10:33:37
20240805133720	2025-10-03 10:33:40
20240827160934	2025-10-03 10:33:43
20240919163303	2025-10-03 10:33:48
20240919163305	2025-10-03 10:33:51
20241019105805	2025-10-03 10:33:54
20241030150047	2025-10-03 10:34:06
20241108114728	2025-10-03 10:34:11
20241121104152	2025-10-03 10:34:14
20241130184212	2025-10-03 10:34:18
20241220035512	2025-10-03 10:34:21
20241220123912	2025-10-03 10:34:25
20241224161212	2025-10-03 10:34:28
20250107150512	2025-10-03 10:34:31
20250110162412	2025-10-03 10:34:35
20250123174212	2025-10-03 10:34:38
20250128220012	2025-10-03 10:34:41
20250506224012	2025-10-03 10:34:44
20250523164012	2025-10-03 10:34:47
20250714121412	2025-10-03 10:34:50
20250905041441	2025-10-03 10:34:54
\.


--
-- Data for Name: subscription; Type: TABLE DATA; Schema: realtime; Owner: supabase_admin
--

COPY realtime.subscription (id, subscription_id, entity, filters, claims, created_at) FROM stdin;
\.


--
-- Data for Name: absence_types; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.absence_types (id, company_id, codigo, nome, descricao, tipo, maximo_dias, remunerado, desconta_salario, desconta_ferias, desconta_13_salario, requer_anexo, requer_aprovacao, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: allowance_types; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.allowance_types (id, company_id, nome, codigo, descricao, tipo, calculo_automatico, percentual_base, valor_fixo, incidencia_ferias, incidencia_13_salario, incidencia_aviso_previo, incidencia_fgts, incidencia_inss, incidencia_ir, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: approval_level_approvers; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.approval_level_approvers (id, approval_level_id, user_id, is_primary, is_active, created_at) FROM stdin;
\.


--
-- Data for Name: approval_levels; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.approval_levels (id, company_id, name, level_order, required_approvals, max_amount, max_hours, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: attendance_corrections; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.attendance_corrections (id, employee_id, company_id, data_original, entrada_original, saida_original, entrada_corrigida, saida_corrigida, justificativa, status, solicitado_por, aprovado_por, aprovado_em, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: audit_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.audit_config (id, company_id, entity_type, is_enabled, log_level, retention_days, created_at, updated_at) FROM stdin;
4c89f0f3-7f38-4efe-9585-566710783050	a9784891-9d58-4cc4-8404-18032105c335	compensation_requests	t	all	2555	2025-10-11 22:32:59.263204+00	2025-10-11 22:32:59.263204+00
0bec89c6-d73b-486d-8043-96823e344e64	a9784891-9d58-4cc4-8404-18032105c335	compensation_approvals	t	all	2555	2025-10-11 22:32:59.323396+00	2025-10-11 22:32:59.323396+00
49de6cf7-9db4-43fd-b819-57eb8a8e0c83	a9784891-9d58-4cc4-8404-18032105c335	approval_levels	t	changes	2555	2025-10-11 22:32:59.377319+00	2025-10-11 22:32:59.377319+00
\.


--
-- Data for Name: audit_logs; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.audit_logs (id, company_id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, session_id, created_at) FROM stdin;
\.


--
-- Data for Name: bank_hours_balance; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.bank_hours_balance (id, employee_id, company_id, current_balance, accumulated_hours, compensated_hours, expired_hours, last_calculation_date, next_expiration_date, is_locked, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: bank_hours_calculations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.bank_hours_calculations (id, company_id, calculation_date, period_start, period_end, employees_processed, hours_accumulated, hours_compensated, hours_expired, status, error_message, created_at, completed_at) FROM stdin;
\.


--
-- Data for Name: bank_hours_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.bank_hours_config (id, employee_id, company_id, has_bank_hours, accumulation_period_months, max_accumulation_hours, compensation_rate, auto_compensate, compensation_priority, expires_after_months, allow_negative_balance, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: bank_hours_transactions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.bank_hours_transactions (id, employee_id, company_id, transaction_type, transaction_date, hours_amount, time_record_id, reference_period_start, reference_period_end, description, compensation_rate, is_automatic, created_by, approved_by, approved_at, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: benefit_configurations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.benefit_configurations (id, company_id, benefit_type, name, description, calculation_type, base_value, percentage_value, min_value, max_value, daily_calculation_base, requires_approval, is_active, created_at, updated_at, entra_no_calculo_folha) FROM stdin;
1b8f7a5b-bda7-40ea-9535-237886882689	a9784891-9d58-4cc4-8404-18032105c335	vr_va	Vale RefeiÃ§Ã£o	Vale refeiÃ§Ã£o para funcionÃ¡rios	fixed_value	500.00	\N	300.00	800.00	30	f	t	2025-10-05 00:14:00.775452+00	2025-10-05 00:14:00.775452+00	t
98443a7a-f45b-4a0b-b43c-c6553d32f60c	a9784891-9d58-4cc4-8404-18032105c335	vr_va	Vale AlimentaÃ§Ã£o	Vale alimentaÃ§Ã£o para funcionÃ¡rios	daily_value	15.00	\N	10.00	25.00	22	f	t	2025-10-05 00:14:00.775452+00	2025-10-05 00:14:00.775452+00	t
861439ca-d5bc-4c82-924d-df6dc3f956bd	a9784891-9d58-4cc4-8404-18032105c335	transporte	Vale Transporte	AuxÃ­lio transporte para funcionÃ¡rios	percentage	200.00	6.00	50.00	300.00	30	f	t	2025-10-05 00:14:00.775452+00	2025-10-05 00:14:00.775452+00	t
44fcb871-73b8-45fd-8442-aad86f0c19f9	a9784891-9d58-4cc4-8404-18032105c335	equipment_rental	Aluguel de Equipamentos	AuxÃ­lio para aluguel de equipamentos de trabalho	fixed_value	200.00	\N	100.00	500.00	30	f	t	2025-10-05 00:14:00.775452+00	2025-10-05 00:14:00.775452+00	t
4501a9b1-9166-4773-8701-5dfd581adbaa	a9784891-9d58-4cc4-8404-18032105c335	premiacao	PremiaÃ§Ã£o por Performance	PremiaÃ§Ã£o mensal baseada em performance	percentage	0.00	5.00	100.00	1000.00	30	f	f	2025-10-05 00:14:00.775452+00	2025-10-05 00:14:00.775452+00	t
\.


--
-- Data for Name: calculation_logs; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.calculation_logs (id, company_id, processo_id, tipo_processo, descricao_processo, mes_referencia, ano_referencia, status, progresso, total_funcionarios, funcionarios_processados, eventos_calculados, erros_encontrados, inicio_processamento, fim_processamento, tempo_execucao_segundos, usuario_id, usuario_nome, logs_execucao, erros_execucao, resumo_calculos, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: candidate_documents; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.candidate_documents (id, company_id, candidate_id, document_type, file_name, file_path, file_size, mime_type, uploaded_by, created_at) FROM stdin;
\.


--
-- Data for Name: candidates; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.candidates (id, company_id, name, email, phone, cpf, birth_date, address, city, state, zip_code, linkedin_url, portfolio_url, source, status, notes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: cid_codes; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.cid_codes (id, company_id, codigo, descricao, categoria, subcategoria, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: collective_agreements; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.collective_agreements (id, company_id, union_id, tipo_documento, numero_documento, titulo, descricao, data_assinatura, data_vigencia_inicio, data_vigencia_fim, status, valor_beneficios, percentual_reajuste, clausulas, arquivo_url, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: compensation_approvals; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.compensation_approvals (id, compensation_request_id, approval_level_id, approver_id, status, comments, approved_at, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: compensation_requests; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.compensation_requests (id, company_id, employee_id, tipo, data_solicitacao, data_inicio, quantidade_horas, descricao, status, aprovado_por, data_aprovacao, observacoes, created_at, updated_at, data_fim, valor_hora, valor_total, motivo_rejeicao, anexos) FROM stdin;
\.


--
-- Data for Name: correction_history; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.correction_history (id, correction_id, action, old_values, new_values, changed_by, changed_at, reason) FROM stdin;
\.


--
-- Data for Name: correction_settings; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.correction_settings (id, company_id, dias_liberacao_correcao, permitir_correcao_futura, exigir_justificativa, permitir_correcao_apos_aprovacao, dias_limite_correcao, is_active, created_at, updated_at) FROM stdin;
1d4314b2-1c68-4a07-9d97-8afdf49079df	a9784891-9d58-4cc4-8404-18032105c335	7	f	t	f	30	t	2025-10-18 21:06:36.144979+00	2025-10-18 21:06:36.144979+00
\.


--
-- Data for Name: deficiency_types; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.deficiency_types (id, company_id, codigo, nome, descricao, tipo, grau, beneficios_lei_8213, beneficios_lei_13146, isento_contribuicao_sindical, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: delay_reasons; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.delay_reasons (id, company_id, codigo, nome, descricao, tipo, desconta_salario, desconta_horas, requer_justificativa, requer_anexo, ativo, created_at, updated_at) FROM stdin;
110e450f-9295-4cd1-8cff-327242799256	a9784891-9d58-4cc4-8404-18032105c335	TRA001	Problemas de Trânsito	Atraso devido a congestionamentos ou acidentes no trânsito	atraso	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
a8dff934-61bb-4f3f-9668-c65be255c1c9	a9784891-9d58-4cc4-8404-18032105c335	TRA002	Problemas de Transporte	Atraso devido a problemas com transporte público ou particular	atraso	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
356b74ab-cb74-40f7-947b-82aaedac5f91	a9784891-9d58-4cc4-8404-18032105c335	SAU001	Problemas de Saúde	Atraso devido a problemas de saúde pessoal ou familiar	justificado	f	f	t	t	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
66d55f89-2be2-4240-b675-f37d4be30242	a9784891-9d58-4cc4-8404-18032105c335	EME001	Emergência Familiar	Atraso devido a emergência ou problema familiar	justificado	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
d6931be8-7157-456b-b26e-b028ab496307	a9784891-9d58-4cc4-8404-18032105c335	TEC001	Problemas Técnicos	Atraso devido a problemas técnicos com equipamentos ou sistemas	atraso	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
99a666e0-c7c7-4567-9cca-7c5191c27690	a9784891-9d58-4cc4-8404-18032105c335	REU001	Reunião Externa	Atraso devido a reunião ou compromisso externo autorizado	justificado	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
cd7f7174-eef0-4a7f-adf1-27200996c604	a9784891-9d58-4cc4-8404-18032105c335	OUT001	Outros	Outros motivos não especificados	atraso	f	f	t	f	t	2025-10-18 21:09:15.792062+00	2025-10-18 21:09:15.792062+00
\.


--
-- Data for Name: dependents; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.dependents (id, company_id, employee_id, nome, cpf, rg, data_nascimento, parentesco, sexo, estado_civil, nacionalidade, naturalidade, nome_mae, nome_pai, cpf_mae, cpf_pai, telefone, email, endereco, cidade, estado, cep, data_casamento, data_uniao_estavel, data_separacao, data_obito, data_nascimento_mae, escolaridade, instituicao_ensino, possui_deficiencia, tipo_deficiencia, grau_deficiencia, necessita_cuidados_especiais, certidao_nascimento, certidao_casamento, certidao_uniao_estavel, comprovante_residencia, status, data_inclusao, data_exclusao, motivo_exclusao, observacoes, created_at, updated_at, created_by, updated_by) FROM stdin;
\.


--
-- Data for Name: disciplinary_actions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.disciplinary_actions (id, company_id, employee_id, tipo_acao, data_ocorrencia, data_aplicacao, gravidade, motivo, descricao_ocorrencia, medidas_corretivas, status, aplicado_por, aprovado_por, data_aprovacao, observacoes, anexos, data_arquivamento, motivo_arquivamento, created_at, updated_at, duration_days, start_date, end_date, documents, is_active) FROM stdin;
c8361eab-2449-4abb-9c80-65e61f1369f7	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	advertencia_verbal	2025-01-15	2025-01-15	leve	Atraso no trabalho	Funcionário chegou 30 minutos atrasado sem justificativa. Foi orientado sobre a importância da pontualidade.	\N	active	e745168f-addb-4456-a6fa-f4a336d874ac	\N	\N	Primeira ocorrência - orientação verbal aplicada.	\N	\N	\N	2025-10-12 00:29:28.399992+00	2025-10-12 00:29:28.399992+00	\N	\N	\N	\N	t
cb63e41c-0211-4e9d-b455-821f1ff01b3f	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	advertencia_escrita	2025-01-20	2025-01-20	moderada	Falta de comunicação	Funcionário não comunicou ausência em reunião importante, causando atraso no projeto. Documento de advertência escrita entregue.	\N	active	e745168f-addb-4456-a6fa-f4a336d874ac	\N	\N	Segunda ocorrência - advertência escrita aplicada.	\N	\N	\N	2025-10-12 00:29:28.399992+00	2025-10-12 00:29:28.399992+00	\N	\N	\N	\N	t
8f617273-facf-4912-9dcc-4c71f2319087	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	suspensao	2025-01-25	2025-01-25	grave	Descumprimento de normas de segurança	Funcionário não utilizou equipamentos de proteção individual obrigatórios, colocando em risco sua segurança e de outros colaboradores.	\N	active	e745168f-addb-4456-a6fa-f4a336d874ac	\N	\N	Suspensão de 3 dias por descumprimento de normas de segurança.	\N	\N	\N	2025-10-12 00:29:28.399992+00	2025-10-12 00:29:28.399992+00	3	2025-01-26	2025-01-28	\N	t
3d02e7eb-6eff-424d-ba3e-a1e6003cad5c	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	demissao_justa_causa	2025-02-01	2025-02-01	gravissima	Apropriação indébita	Funcionário foi flagrado desviando materiais da empresa para uso pessoal. Ação grave que configura apropriação indébita.	\N	active	e745168f-addb-4456-a6fa-f4a336d874ac	\N	\N	Demissão por justa causa aplicada devido à gravidade da infração.	\N	\N	\N	2025-10-12 00:29:28.399992+00	2025-10-12 00:29:28.399992+00	\N	\N	\N	\N	t
\.


--
-- Data for Name: employee_benefit_assignments; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_benefit_assignments (id, employee_id, benefit_config_id, company_id, start_date, end_date, custom_value, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: employee_correction_permissions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_correction_permissions (id, employee_id, company_id, mes_ano, liberado, liberado_por, liberado_em, observacoes, created_at, updated_at) FROM stdin;
4031d668-1ae2-4ae9-8a95-b19da71ac263	2e1c8d74-3a29-49c8-810f-f688c640e3ca	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.464482+00	2025-10-18 23:25:02.063362+00
d69d99db-542c-42c6-9c42-dd5c9bfe130c	608540eb-694a-411e-8f1f-1cff05d2fbd6	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.491857+00	2025-10-18 23:25:02.069705+00
17c7a173-117c-417c-84e6-a5e55e2cb6f4	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.449994+00	2025-10-18 23:25:02.069826+00
ac1f710a-cab7-422b-b9d8-e084a9c9a9af	2b525955-1d46-41ad-829f-faa8e0c3e78a	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.47149+00	2025-10-18 23:25:02.069704+00
c161683c-ff53-4a61-b1ea-937629b15816	d21cf624-818a-40cb-a95a-7a4b9d202e01	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.471276+00	2025-10-18 23:25:02.078066+00
3c358ae9-cd57-48ac-a04f-27ef96cfe6b0	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:14:32.22908+00	2025-10-18 23:25:02.075554+00
271ef73b-01bd-444b-bd5f-5e7d5a5c8cf7	40f8884c-a60b-4237-bc92-afcad528896b	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.464482+00	2025-10-18 23:25:02.076468+00
795582db-a87d-4687-9175-8b9a7c5a697d	ca822301-b341-4965-ab49-d98f844d3cf9	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.46941+00	2025-10-18 23:25:02.077725+00
e7aa5ecd-0f83-4593-83e8-89ac6d7bd23a	4331ff6e-1001-491e-80c8-3f9eecd5c27e	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.497866+00	2025-10-18 23:25:02.085808+00
02dc393e-2d8c-49a1-8535-0f758725666d	50e8e1b4-a061-4c57-be81-2178c224d1ca	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.49387+00	2025-10-18 23:25:02.092906+00
7f4e6a68-aee5-45ba-86ce-6091220938d2	01b9350d-0a99-4a84-ab6e-e9cc7b81b787	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.501567+00	2025-10-18 23:25:02.093779+00
12f874a0-7c78-4d0c-a8ba-536d44ec22bd	2d3391a7-ed62-4b5a-a82d-5fb9d4bebe0a	a9784891-9d58-4cc4-8404-18032105c335	2025-10	f	\N	2025-10-18 23:24:24.404+00		2025-10-18 23:24:27.496816+00	2025-10-18 23:25:02.095182+00
\.


--
-- Data for Name: employee_medical_plans; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_medical_plans (id, company_id, employee_id, plan_id, data_inicio, data_fim, status, valor_mensal, desconto_aplicado, motivo_suspensao, observacoes, created_at, updated_at, entra_no_calculo_folha) FROM stdin;
\.


--
-- Data for Name: employee_plan_dependents; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_plan_dependents (id, company_id, employee_plan_id, nome, cpf, data_nascimento, parentesco, status, valor_mensal, data_inclusao, data_exclusao, motivo_exclusao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: employee_schedules; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_schedules (id, employee_id, schedule_id, company_id, data_inicio, data_fim, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: employee_shifts; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_shifts (id, company_id, funcionario_id, turno_id, data_inicio, data_fim, ativo, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: employee_union_memberships; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employee_union_memberships (id, company_id, employee_id, union_id, data_filiacao, data_desfiliacao, status, numero_carteira, categoria_filiacao, valor_mensalidade, desconto_folha, motivo_desfiliacao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: employees; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employees (id, company_id, nome, matricula, cpf, rg, data_nascimento, data_admissao, data_demissao, cargo_id, departamento_id, salario_base, status, telefone, email, endereco, cidade, estado, cep, created_at, updated_at, user_id, gestor_imediato_id, certidao_nascimento, certidao_casamento, titulo_eleitor, ctps, pis_pasep, certificado_reservista, comprovante_endereco, foto_funcionario, escolaridade, tipo_cnh, cartao_sus, registros_profissionais, outros_vinculos_empregaticios, detalhes_outros_vinculos, banco_nome, banco_agencia, banco_conta, banco_tipo_conta, banco_pix) FROM stdin;
8e06f37d-c730-47b7-b0cd-d9c6c455ee32	a9784891-9d58-4cc4-8404-18032105c335	João Silva Teste	\N	123.456.789-00	\N	\N	2024-01-01	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-04 21:17:05.305611+00	2025-10-04 21:17:05.305611+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	a9784891-9d58-4cc4-8404-18032105c335	Deiverson Jorge Honorato Medeiros	\N	987.654.321-00	\N	\N	2024-01-01	\N	a9ab7789-6a00-40c4-9d19-9a04bc3a8387	2400ee57-5ca3-4b8c-8b61-8a6c30b388f4	5000.00	ativo	\N	\N	\N	\N	\N	\N	2025-10-07 00:48:05.618032+00	2025-10-07 00:48:05.618032+00	e745168f-addb-4456-a6fa-f4a336d874ac	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
2d3391a7-ed62-4b5a-a82d-5fb9d4bebe0a	a9784891-9d58-4cc4-8404-18032105c335	Teste1	\N	000.000.000-00	\N	\N	2025-10-13	\N	\N	\N	\N	ativo	\N	teste1@estrategicengenharia.com.br	\N	\N	\N	\N	2025-10-13 18:45:26.723425+00	2025-10-13 18:45:26.723425+00	a1aa1fde-03cb-42b3-bd67-4ac5def143db	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
4331ff6e-1001-491e-80c8-3f9eecd5c27e	a9784891-9d58-4cc4-8404-18032105c335	Teste 10	\N	111.111.111-11	\N	\N	2025-10-13	\N	\N	\N	\N	ativo	\N	teste10@estrategicengenharia.com.br	\N	\N	\N	\N	2025-10-13 19:37:18.060899+00	2025-10-13 19:37:18.060899+00	95aff25e-1b9e-416d-87fd-a3f67ea9cc23	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
608540eb-694a-411e-8f1f-1cff05d2fbd6	a9784891-9d58-4cc4-8404-18032105c335	JoÃ£o Silva Teste	\N	999.888.777-66	\N	\N	2024-01-01	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-13 22:23:21.776371+00	2025-10-13 22:23:21.776371+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
01b9350d-0a99-4a84-ab6e-e9cc7b81b787	a9784891-9d58-4cc4-8404-18032105c335	Teste 2	\N	123.456.789-11	\N	\N	2024-01-01	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-13 22:24:45.305772+00	2025-10-13 22:24:45.305772+00	3be90091-7fa2-45bd-9555-54fdf167fc1f	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
d21cf624-818a-40cb-a95a-7a4b9d202e01	a9784891-9d58-4cc4-8404-18032105c335	Maria Silva Teste	01001	111.222.333-44	\N	\N	2024-01-01	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-13 22:42:06.790394+00	2025-10-13 22:42:06.790394+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
2e1c8d74-3a29-49c8-810f-f688c640e3ca	a9784891-9d58-4cc4-8404-18032105c335	JoÃ£o Santos Teste	01002	555.666.777-88	\N	\N	2024-01-02	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-13 22:42:17.108499+00	2025-10-13 22:42:17.108499+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
50e8e1b4-a061-4c57-be81-2178c224d1ca	a9784891-9d58-4cc4-8404-18032105c335	Teste 4	01003	173.840.322-17	\N	\N	2025-04-03	\N	\N	\N	\N	ativo	\N	\N	\N	\N	\N	\N	2025-10-13 22:47:00.880648+00	2025-10-13 22:47:00.880648+00	c732b045-65b9-4cb0-b84b-cfca9987ec6a	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
40f8884c-a60b-4237-bc92-afcad528896b	a9784891-9d58-4cc4-8404-18032105c335	JoÃ£o Silva	EMP001	12345678901	\N	\N	2024-10-18	\N	\N	\N	\N	ativo	\N	joao.silva@empresa.com	\N	\N	\N	\N	2025-10-18 19:30:08.950903+00	2025-10-18 19:30:08.950903+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
2b525955-1d46-41ad-829f-faa8e0c3e78a	a9784891-9d58-4cc4-8404-18032105c335	Maria Santos	EMP002	12345678902	\N	\N	2025-04-18	\N	\N	\N	\N	ativo	\N	maria.santos@empresa.com	\N	\N	\N	\N	2025-10-18 19:30:08.950903+00	2025-10-18 19:30:08.950903+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
ca822301-b341-4965-ab49-d98f844d3cf9	a9784891-9d58-4cc4-8404-18032105c335	Pedro Costa	EMP003	12345678903	\N	\N	2025-07-18	\N	\N	\N	\N	ativo	\N	pedro.costa@empresa.com	\N	\N	\N	\N	2025-10-18 19:30:08.950903+00	2025-10-18 19:30:08.950903+00	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	f	\N	\N	\N	\N	\N	\N
\.


--
-- Data for Name: employment_contracts; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.employment_contracts (id, company_id, employee_id, numero_contrato, tipo_contrato, data_inicio, data_fim, periodo_experiencia, salario_base, carga_horaria_semanal, regime_trabalho, tipo_jornada, beneficios, clausulas_especiais, status, data_rescisao, motivo_rescisao, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: equipment_rental_approvals; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.equipment_rental_approvals (id, employee_id, company_id, tipo_equipamento, valor_mensal, data_inicio, data_fim, justificativa, status, aprovado_por, aprovado_em, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: esocial_batches; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.esocial_batches (id, company_id, batch_number, period, status, total_events, sent_events, accepted_events, rejected_events, error_events, xml_content, xml_response, protocol_number, sent_at, processed_at, error_message, created_at, updated_at, created_by, updated_by) FROM stdin;
\.


--
-- Data for Name: esocial_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.esocial_config (id, company_id, ambiente, tp_amb, cnpj_empregador, cpf_empregador, razao_social, codigo_empregador, codigo_esocial, versao_lote, versao_evento, url_consulta, url_envio, certificado_digital, senha_certificado, proxy_host, proxy_port, proxy_user, proxy_pass, timeout, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: esocial_events; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.esocial_events (id, company_id, employee_id, tipo_evento, numero_recibo, data_envio, data_recebimento, status, xml_content, xml_response, observacoes, tentativas_envio, ultimo_erro, data_proximo_envio, created_at, updated_at, batch_id) FROM stdin;
\.


--
-- Data for Name: esocial_integrations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.esocial_integrations (id, company_id, tipo_evento, codigo_evento, descricao, status, data_envio, data_processamento, protocolo, funcionario_id, observacoes, arquivo_retorno, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: esocial_logs; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.esocial_logs (id, company_id, event_id, tipo_operacao, status, mensagem, detalhes, tempo_execucao, created_at) FROM stdin;
\.


--
-- Data for Name: event_consolidations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.event_consolidations (id, company_id, periodo, status, total_eventos, eventos_processados, data_inicio, data_fim, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: fgts_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.fgts_config (id, company_id, codigo, descricao, ano_vigencia, mes_vigencia, aliquota_fgts, aliquota_multa, aliquota_juros, teto_salario, valor_minimo_contribuicao, multa_rescisao, ativo, created_at, updated_at) FROM stdin;
100d99fc-e6de-4c0b-bbe1-f824b90beaa0	a9784891-9d58-4cc4-8404-18032105c335	FGTS_2024	Configuração FGTS 2024	2024	1	0.0800	0.0000	0.0000	0.00	0.00	0.4000	t	2025-10-05 19:36:41.630043+00	2025-10-05 19:36:41.630043+00
\.


--
-- Data for Name: gestor_notifications; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.gestor_notifications (id, company_id, gestor_id, tipo_notificacao, titulo, mensagem, dados_extras, lida, created_at) FROM stdin;
\.


--
-- Data for Name: holidays; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.holidays (id, company_id, nome, data, tipo, descricao, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: income_statements; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.income_statements (id, employee_id, company_id, ano_referencia, mes_referencia, total_rendimentos, total_descontos, salario_liquido, inss_descontado, irrf_descontado, fgts_descontado, outros_descontos, status, arquivo_pdf, observacoes, data_geracao, data_vencimento, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: inss_brackets; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.inss_brackets (id, company_id, codigo, descricao, ano_vigencia, mes_vigencia, valor_minimo, valor_maximo, aliquota, valor_deducao, ativo, created_at, updated_at) FROM stdin;
7057f029-cc6c-4e24-ad77-dd7380a33dd7	a9784891-9d58-4cc4-8404-18032105c335	INSS_FAIXA_1	1ª Faixa - Até R$ 1.412,00	2024	1	0.00	1412.00	0.0750	0.00	t	2025-10-05 19:07:18.833084+00	2025-10-05 19:07:18.833084+00
b236f11f-88b6-4047-a53a-a7b9cc9d28d0	a9784891-9d58-4cc4-8404-18032105c335	INSS_FAIXA_2	2ª Faixa - De R$ 1.412,01 até R$ 2.666,68	2024	1	1412.01	2666.68	0.0900	21.18	t	2025-10-05 19:07:18.833084+00	2025-10-05 19:07:18.833084+00
\.


--
-- Data for Name: irrf_brackets; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.irrf_brackets (id, company_id, codigo, descricao, ano_vigencia, mes_vigencia, valor_minimo, valor_maximo, aliquota, valor_deducao, numero_dependentes, valor_por_dependente, ativo, created_at, updated_at) FROM stdin;
49c190f3-aade-4f9f-aaee-610827904a60	a9784891-9d58-4cc4-8404-18032105c335	IRRF_FAIXA_1	1ª Faixa - Isento	2024	1	0.00	1903.98	0.0000	0.00	0	0.00	t	2025-10-05 19:30:13.222409+00	2025-10-05 19:30:13.222409+00
1b4e8c21-b6d6-4c11-8a03-623607c76acb	a9784891-9d58-4cc4-8404-18032105c335	IRRF_FAIXA_2	2ª Faixa - 7,5%	2024	1	1903.99	2826.65	0.0750	142.80	0	0.00	t	2025-10-05 19:30:13.222409+00	2025-10-05 19:30:13.222409+00
03e5829b-04ef-486e-99a0-6aaa8a4839bc	a9784891-9d58-4cc4-8404-18032105c335	IRRF_FAIXA_3	3ª Faixa - 15%	2024	1	2826.66	3751.05	0.1500	354.80	0	0.00	t	2025-10-05 19:30:13.222409+00	2025-10-05 19:30:13.222409+00
d0001f64-a0b8-4f35-842b-5cb95bac0655	a9784891-9d58-4cc4-8404-18032105c335	IRRF_FAIXA_4	4ª Faixa - 22,5%	2024	1	3751.06	4664.68	0.2250	636.13	0	0.00	t	2025-10-05 19:30:13.222409+00	2025-10-05 19:30:13.222409+00
b2d31d1e-493b-4f7c-ab19-4590bedc8803	a9784891-9d58-4cc4-8404-18032105c335	IRRF_FAIXA_5	5ª Faixa - 27,5%	2024	1	4664.69	999999.99	0.2750	869.36	0	0.00	t	2025-10-05 19:30:13.222409+00	2025-10-05 19:30:13.222409+00
\.


--
-- Data for Name: job_openings; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.job_openings (id, company_id, job_request_id, position_name, department_name, job_description, requirements, benefits, salary_range, status, created_by, published_at, closed_at, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: job_requests; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.job_requests (id, company_id, position_name, department_name, job_description, requirements, benefits, salary_range, urgency_level, status, requested_by, approved_by, approved_at, expected_start_date, rejection_reason, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: medical_agreements; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.medical_agreements (id, company_id, nome, tipo, cnpj, razao_social, telefone, email, site, endereco, cidade, estado, cep, contato_responsavel, telefone_contato, email_contato, observacoes, ativo, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: medical_certificate_attachments; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.medical_certificate_attachments (id, certificate_id, file_name, file_url, file_type, file_size, uploaded_by, created_at) FROM stdin;
\.


--
-- Data for Name: medical_certificates; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.medical_certificates (id, employee_id, company_id, numero_atestado, data_emissao, data_inicio, data_fim, dias_afastamento, cid_codigo, cid_descricao, observacoes, anexo_url, status, aprovado_por, aprovado_em, created_at, updated_at, medico_nome, crm_crmo, especialidade, tipo_atestado, valor_beneficio, data_aprovacao) FROM stdin;
\.


--
-- Data for Name: medical_plan_pricing_history; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.medical_plan_pricing_history (id, company_id, plan_id, data_vigencia, valor_titular_anterior, valor_titular_novo, valor_dependente_anterior, valor_dependente_novo, valor_familia_anterior, valor_familia_novo, percentual_reajuste, motivo_reajuste, aprovado_por, created_at) FROM stdin;
\.


--
-- Data for Name: medical_plans; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.medical_plans (id, company_id, agreement_id, nome, descricao, categoria, cobertura, carencia_dias, faixa_etaria_min, faixa_etaria_max, limite_dependentes, valor_titular, valor_dependente, valor_familia, desconto_funcionario, desconto_dependente, ativo, data_inicio_vigencia, data_fim_vigencia, observacoes, created_at, updated_at, entra_no_calculo_folha, tipo_folha, categoria_desconto) FROM stdin;
\.


--
-- Data for Name: monthly_benefit_processing; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.monthly_benefit_processing (id, employee_id, benefit_config_id, company_id, month_reference, year_reference, base_value, work_days, absence_days, discount_value, final_value, status, processed_at, validated_at, processed_by, validated_by, created_at) FROM stdin;
\.


--
-- Data for Name: payroll; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.payroll (id, employee_id, company_id, mes_referencia, ano_referencia, salario_base, horas_trabalhadas, horas_extras, valor_horas_extras, total_vencimentos, total_descontos, salario_liquido, status, data_pagamento, observacoes, created_at, updated_at, total_beneficios_convenios_medicos, total_descontos_convenios_medicos, total_beneficios_tradicionais) FROM stdin;
c427b8b6-3d25-4e5e-99e9-f0f485ce5fe5	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	a9784891-9d58-4cc4-8404-18032105c335	10	2024	5000.00	44.00	2.00	200.00	5500.00	1100.00	4400.00	pago	2024-10-05	\N	2025-10-05 00:37:25.176445+00	2025-10-05 00:37:25.176445+00	0.00	0.00	0.00
\.


--
-- Data for Name: payroll_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.payroll_config (id, company_id, codigo, descricao, ativo, ano_vigencia, mes_vigencia, dias_uteis_mes, horas_dia_trabalho, percentual_hora_extra, percentual_hora_noturna, percentual_dsr, aplicar_inss, aplicar_irrf, aplicar_fgts, aplicar_vale_transporte, percentual_vale_transporte, aplicar_adicional_noturno, percentual_adicional_noturno, aplicar_periculosidade, percentual_periculosidade, aplicar_insalubridade, grau_insalubridade, aplicar_ferias_proporcionais, aplicar_terco_ferias, aplicar_13_salario, desconto_faltas, desconto_atrasos, tolerancia_atraso_minutos, arredondar_centavos, tipo_arredondamento, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: payroll_events; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.payroll_events (id, payroll_id, employee_id, company_id, rubrica_id, codigo_rubrica, descricao_rubrica, tipo_rubrica, quantidade, valor_unitario, valor_total, percentual, mes_referencia, ano_referencia, calculado_automaticamente, origem_evento, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: periodic_exams; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.periodic_exams (id, company_id, employee_id, tipo_exame, data_agendamento, data_realizacao, data_vencimento, status, medico_responsavel, clinica_local, observacoes, resultado, restricoes, anexos, custo, pago, data_pagamento, created_at, updated_at) FROM stdin;
d27d396a-2dd8-4c89-a8eb-ba35d369d71b	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	admissional	2024-01-15	2024-01-15	2024-01-15	realizado	Dr. JoÃ£o Silva	ClÃ­nica MÃ©dica Central	Exame admissional realizado com sucesso	apto	\N	\N	150.00	t	2024-01-20	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
f5755a74-e2d3-4329-af27-aa87236393bb	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2025-02-15	\N	2025-02-15	agendado	\N	ClÃ­nica MÃ©dica Central	Exame periÃ³dico anual	\N	\N	\N	200.00	f	\N	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
dd94e475-1cea-4631-9b09-ec695406fac3	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2025-10-18	\N	2025-10-18	agendado	\N	ClÃ­nica MÃ©dica Central	Exame periÃ³dico - lembrete prÃ³ximo	\N	\N	\N	200.00	f	\N	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
2d05d412-5a27-4938-8916-c02d28fd63dd	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2025-10-06	\N	2025-10-06	agendado	\N	ClÃ­nica MÃ©dica Central	Exame periÃ³dico vencido - precisa reagendamento	\N	\N	\N	200.00	f	\N	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
628c7c1a-0da3-41a7-ae51-ee766126b388	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	periodico	2024-12-01	2024-12-01	2024-12-01	realizado	Dra. Maria Santos	ClÃ­nica Ocupacional	Exame com restriÃ§Ãµes mÃ©dicas	apto_com_restricoes	NÃ£o pode trabalhar em altura superior a 2 metros	\N	180.00	t	2024-12-05	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
0a26a511-aeb0-4a9e-9056-9bc2f15fedbf	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	demissional	2024-11-30	2024-11-30	2024-11-30	realizado	Dr. Carlos Lima	ClÃ­nica MÃ©dica Central	Exame demissional realizado	apto	\N	\N	120.00	t	2024-12-01	2025-10-11 22:52:35.432831+00	2025-10-11 22:52:35.432831+00
b395e322-f689-4c92-8a98-a8baa0e1d10d	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2025-01-15	\N	2025-02-15	agendado	\N	\N	\N	\N	\N	\N	\N	f	\N	2025-10-11 23:24:22.467556+00	2025-10-11 23:24:22.467556+00
baeddbd5-c4bb-42a6-a6f6-65c39ce6c632	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-11 23:25:45.21148+00	2025-10-11 23:25:45.21148+00
9c67bd6a-cdab-4739-ae40-da5158669149	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-11 23:25:45.310375+00	2025-10-11 23:25:45.310375+00
341c8b5c-b707-4275-ae8d-30a143af0854	a9784891-9d58-4cc4-8404-18032105c335	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.287895+00	2025-10-19 12:42:45.287895+00
bcb9c236-38bf-40b3-9cc5-ac858857693e	a9784891-9d58-4cc4-8404-18032105c335	2e1c8d74-3a29-49c8-810f-f688c640e3ca	periodico	2026-01-02	\N	2026-01-02	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.384733+00	2025-10-19 12:42:45.384733+00
1dfa6781-493a-48c7-bb0d-ab01f91aad17	a9784891-9d58-4cc4-8404-18032105c335	40f8884c-a60b-4237-bc92-afcad528896b	periodico	2026-10-18	\N	2026-10-18	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.477737+00	2025-10-19 12:42:45.477737+00
3c13786e-cf80-4783-85d2-34ea555409e3	a9784891-9d58-4cc4-8404-18032105c335	608540eb-694a-411e-8f1f-1cff05d2fbd6	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.569107+00	2025-10-19 12:42:45.569107+00
d63c857e-b308-48ab-b134-e5c7251b60de	a9784891-9d58-4cc4-8404-18032105c335	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.646146+00	2025-10-19 12:42:45.646146+00
722cfc8e-21f9-46d9-9806-cedeacb4c236	a9784891-9d58-4cc4-8404-18032105c335	2b525955-1d46-41ad-829f-faa8e0c3e78a	periodico	2026-04-18	\N	2026-04-18	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.730096+00	2025-10-19 12:42:45.730096+00
05d2caec-1a13-42ce-b314-1f718d1afd36	a9784891-9d58-4cc4-8404-18032105c335	d21cf624-818a-40cb-a95a-7a4b9d202e01	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.821777+00	2025-10-19 12:42:45.821777+00
9267817b-d7ee-400c-a911-675fa53c6fb2	a9784891-9d58-4cc4-8404-18032105c335	ca822301-b341-4965-ab49-d98f844d3cf9	periodico	2026-07-18	\N	2026-07-18	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.909811+00	2025-10-19 12:42:45.909811+00
4ade6375-9949-41d1-b571-1466ca68ac7f	a9784891-9d58-4cc4-8404-18032105c335	4331ff6e-1001-491e-80c8-3f9eecd5c27e	periodico	2026-10-13	\N	2026-10-13	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:45.995328+00	2025-10-19 12:42:45.995328+00
7b8e4df3-da0c-4688-b1ca-f06aad7c6479	a9784891-9d58-4cc4-8404-18032105c335	01b9350d-0a99-4a84-ab6e-e9cc7b81b787	periodico	2026-01-01	\N	2026-01-01	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:46.086869+00	2025-10-19 12:42:46.086869+00
46d3edc1-0719-41e0-86cc-d2ed7c570339	a9784891-9d58-4cc4-8404-18032105c335	50e8e1b4-a061-4c57-be81-2178c224d1ca	periodico	2026-04-03	\N	2026-04-03	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:46.182343+00	2025-10-19 12:42:46.182343+00
ba511a1a-648a-41dd-b8d9-6f1eaed6b216	a9784891-9d58-4cc4-8404-18032105c335	2d3391a7-ed62-4b5a-a82d-5fb9d4bebe0a	periodico	2026-10-13	\N	2026-10-13	agendado	\N	\N	Exame periódico agendado automaticamente	\N	\N	\N	200.00	f	\N	2025-10-19 12:42:46.264062+00	2025-10-19 12:42:46.264062+00
\.


--
-- Data for Name: positions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.positions (id, company_id, nome, descricao, nivel_hierarquico, salario_minimo, salario_maximo, carga_horaria, is_active, created_at, updated_at) FROM stdin;
5a2c837b-92c0-4319-b7c8-1c0c7d8e885c	a9784891-9d58-4cc4-8404-18032105c335	Desenvolvedor	Desenvolvedor de Software	1	\N	\N	40	t	2025-10-04 23:36:12.904032+00	2025-10-04 23:36:12.904032+00
6c3f6b5c-2b35-46c6-8bc8-87d8b8e33367	a9784891-9d58-4cc4-8404-18032105c335	Analista	Analista de Sistemas	2	\N	\N	40	t	2025-10-04 23:36:12.904032+00	2025-10-04 23:36:12.904032+00
a9ab7789-6a00-40c4-9d19-9a04bc3a8387	a9784891-9d58-4cc4-8404-18032105c335	Desenvolvedor	Desenvolvedor de Software	1	\N	\N	40	t	2025-10-07 00:47:38.319853+00	2025-10-07 00:47:38.319853+00
\.


--
-- Data for Name: reimbursement_requests; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.reimbursement_requests (id, employee_id, company_id, tipo_despesa, valor_solicitado, data_despesa, descricao, comprovante_url, status, solicitado_por, aprovado_por, aprovado_em, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: reports; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.reports (id, company_id, nome, tipo, periodo, status, data_geracao, arquivo_url, parametros, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: rubricas; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.rubricas (id, company_id, codigo, nome, descricao, tipo, categoria, natureza, calculo_automatico, formula_calculo, valor_fixo, percentual, base_calculo, incidencia_ir, incidencia_inss, incidencia_fgts, incidencia_contribuicao_sindical, ordem_exibicao, obrigatorio, ativo, created_at, updated_at) FROM stdin;
c8546110-97d6-4b08-88bf-79d3692e0839	a9784891-9d58-4cc4-8404-18032105c335	SAL_BASE	Salário Base	Salário base do funcionário	provento	\N	normal	f	\N	0.00	\N	salario_base	f	f	f	f	0	f	t	2025-10-05 20:12:29.112434+00	2025-10-05 20:12:29.112434+00
9521f37b-bd37-4153-9db5-74d7a3bdb676	a9784891-9d58-4cc4-8404-18032105c335	VALE_ALIM	Vale Alimentação	Vale alimentação	provento	\N	normal	f	\N	0.00	\N	salario_base	f	f	f	f	0	f	t	2025-10-05 20:12:29.112434+00	2025-10-05 20:12:29.112434+00
9eaa301e-59f7-4c19-998e-e7222cfd6152	a9784891-9d58-4cc4-8404-18032105c335	VALE_TRANS	Vale Transporte	Vale transporte	desconto	\N	normal	f	\N	0.00	\N	salario_base	f	f	f	f	0	f	t	2025-10-05 20:12:29.112434+00	2025-10-05 20:12:29.112434+00
\.


--
-- Data for Name: schedule_planning; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.schedule_planning (id, company_id, nome, periodo_inicio, periodo_fim, status, total_funcionarios, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: selection_processes; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.selection_processes (id, company_id, job_opening_id, candidate_id, current_stage, status, started_at, completed_at, created_by, notes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: selection_stages; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.selection_stages (id, company_id, selection_process_id, stage_name, stage_type, status, scheduled_at, completed_at, interviewer_id, score, notes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: signature_notifications; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.signature_notifications (id, company_id, employee_id, signature_id, notification_type, sent_at, sent_via, status, created_at) FROM stdin;
\.


--
-- Data for Name: talent_pool; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.talent_pool (id, company_id, candidate_id, category, skills, experience_level, availability, notes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: time_bank; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.time_bank (id, company_id, employee_id, data_registro, tipo_hora, quantidade_horas, motivo, status, aprovado_por, data_aprovacao, data_expiracao, utilizado_em, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: time_record_signature_config; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.time_record_signature_config (id, company_id, is_enabled, signature_period_days, reminder_days, require_manager_approval, auto_close_month, created_at, updated_at) FROM stdin;
0ffca37e-8138-46be-81e5-143dc0e52b12	a9784891-9d58-4cc4-8404-18032105c335	t	5	3	t	t	2025-10-18 23:57:10.806238+00	2025-10-19 00:18:53.95542+00
\.


--
-- Data for Name: time_record_signatures; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.time_record_signatures (id, company_id, employee_id, month_year, signature_data, signature_timestamp, ip_address, user_agent, status, manager_approval_required, manager_approved_by, manager_approved_at, rejection_reason, expires_at, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: time_records; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.time_records (id, employee_id, company_id, data_registro, entrada, saida, entrada_almoco, saida_almoco, horas_trabalhadas, horas_extras, horas_faltas, status, observacoes, aprovado_por, aprovado_em, created_at, updated_at, entrada_extra1, saida_extra1) FROM stdin;
3181d4f5-8a1a-4dbe-a3a2-ed406aa053d7	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	a9784891-9d58-4cc4-8404-18032105c335	2025-10-05	08:00:00	17:00:00	12:00:00	13:00:00	8.00	0.00	0.00	pendente	Aguardando aprovaÃ§Ã£o	\N	\N	2025-10-05 00:07:54.604489+00	2025-10-05 00:07:54.604489+00	\N	\N
9def9a74-132c-4ced-bd6e-39752057166c	8e06f37d-c730-47b7-b0cd-d9c6c455ee32	a9784891-9d58-4cc4-8404-18032105c335	2025-09-29	09:00:00	18:00:00	12:30:00	13:30:00	8.00	1.00	0.00	pendente	HorÃ¡rio diferenciado - reuniÃ£o externa	\N	\N	2025-10-05 00:07:54.678062+00	2025-10-05 00:07:54.678062+00	\N	\N
\.


--
-- Data for Name: training_attendance; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_attendance (id, company_id, training_id, employee_id, data_treinamento, hora_entrada, hora_saida, presenca, percentual_presenca, observacoes, registrado_por, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_certificates; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_certificates (id, company_id, training_id, employee_id, numero_certificado, data_emissao, data_validade, status, nota_final, percentual_presenca_final, aprovado, observacoes, template_certificado, arquivo_certificado, emitido_por, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_enrollments; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_enrollments (id, company_id, training_id, employee_id, data_inscricao, status, justificativa_cancelamento, observacoes, inscrito_por, aprovado_por, data_aprovacao, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_evaluations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_evaluations (id, company_id, training_id, employee_id, nota_instrutor, nota_conteudo, nota_metodologia, nota_recursos, nota_geral, comentarios, sugestoes, recomendaria, data_avaliacao, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_notification_history; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_notification_history (id, company_id, training_id, notification_type_id, user_id, employee_id, titulo, mensagem, data_envio, status, metodo_envio, created_at) FROM stdin;
\.


--
-- Data for Name: training_notification_queue; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_notification_queue (id, company_id, training_id, notification_type_id, user_id, employee_id, titulo, mensagem, data_agendamento, status, tentativas, max_tentativas, data_envio, erro_mensagem, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_notification_rules; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_notification_rules (id, company_id, training_id, notification_type_id, target_audience, dias_antecedencia, is_enabled, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: training_notification_types; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_notification_types (id, company_id, tipo, nome, descricao, template_titulo, template_mensagem, dias_antecedencia, is_active, created_at, updated_at) FROM stdin;
9b99bdb3-2ffb-4d7a-ab4a-b5ee4499be37	a9784891-9d58-4cc4-8404-18032105c335	inscricao_aberta	Inscrições Abertas	Notificação quando as inscrições para um treinamento são abertas	Inscrições Abertas: {training_name}	As inscrições para o treinamento "{training_name}" estão abertas! Data: {training_date} | Local: {training_location} | Vagas: {available_slots}	0	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
4fe3984c-bd49-49f3-b77b-2d4a7ffdb24f	a9784891-9d58-4cc4-8404-18032105c335	lembrete_inscricao	Lembrete de Inscrição	Lembrete para funcionários se inscreverem em treinamentos	Lembrete: Inscrições para {training_name}	Não esqueça de se inscrever no treinamento "{training_name}". Prazo: {deadline_date}	3	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
60bfa2b3-93c2-41e8-ad51-4d556e281628	a9784891-9d58-4cc4-8404-18032105c335	inicio_treinamento	Início do Treinamento	Notificação do início de um treinamento	Início do Treinamento: {training_name}	O treinamento "{training_name}" começa hoje! Horário: {training_time} | Local: {training_location}	0	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
c0bb1705-c70f-4f79-bdad-356145de38e0	a9784891-9d58-4cc4-8404-18032105c335	fim_treinamento	Fim do Treinamento	Notificação do fim de um treinamento	Treinamento Concluído: {training_name}	O treinamento "{training_name}" foi concluído. Certificado disponível em breve!	0	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
fcd76657-bfed-422e-ab44-bfd000323c90	a9784891-9d58-4cc4-8404-18032105c335	certificado_disponivel	Certificado Disponível	Notificação quando o certificado está disponível	Certificado Disponível: {training_name}	Seu certificado do treinamento "{training_name}" está disponível para download!	0	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
ebc6f2a0-956d-497f-9a4b-e2ff2523378f	a9784891-9d58-4cc4-8404-18032105c335	treinamento_atrasado	Treinamento Atrasado	Notificação de treinamento atrasado	Treinamento Atrasado: {training_name}	O treinamento "{training_name}" foi atrasado. Nova data: {new_date}	0	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
c3aa4938-7ef8-4ce2-9437-3b933477d246	a9784891-9d58-4cc4-8404-18032105c335	presenca_obrigatoria	Presença Obrigatória	Lembrete de presença obrigatória	Presença Obrigatória: {training_name}	Lembrete: Sua presença é obrigatória no treinamento "{training_name}" hoje às {training_time}	1	t	2025-10-12 13:27:12.348272+00	2025-10-12 13:27:12.348272+00
\.


--
-- Data for Name: training_settings; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.training_settings (id, company_id, notification_enabled, email_notifications, push_notifications, reminder_days_before, reminder_days_after, auto_enrollment, require_approval, max_participants, min_attendance_percentage, certificate_auto_generate, certificate_validity_days, training_duration_default, evaluation_required, feedback_required, auto_archive_days, allow_self_enrollment, allow_cancellation, cancellation_deadline_hours, is_active, created_at, updated_at) FROM stdin;
46238b6c-e61b-4c4a-ace7-e52341492a09	a9784891-9d58-4cc4-8404-18032105c335	t	t	f	3	1	f	t	50	80	t	365	8.00	t	t	90	t	t	24	t	2025-10-12 14:31:00.952675+00	2025-10-12 14:31:00.952675+00
\.


--
-- Data for Name: trainings; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.trainings (id, company_id, nome, descricao, tipo_treinamento, categoria, carga_horaria, data_inicio, data_fim, data_limite_inscricao, vagas_totais, vagas_disponiveis, local, modalidade, instrutor, instrutor_email, instrutor_telefone, custo_por_participante, requisitos, objetivos, conteudo_programatico, metodologia, recursos_necessarios, status, aprovado_por, data_aprovacao, observacoes, anexos, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: union_contributions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.union_contributions (id, company_id, employee_id, union_id, tipo_contribuicao, mes_referencia, valor, desconto_folha, data_vencimento, data_pagamento, status, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: union_negotiations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.union_negotiations (id, company_id, union_id, tipo_negociacao, titulo, descricao, data_inicio, data_fim, status, responsavel_empresa, responsavel_sindicato, resultado, valor_proposto, valor_aceito, percentual_proposto, percentual_aceito, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: union_representatives; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.union_representatives (id, company_id, employee_id, union_id, cargo, data_inicio, data_fim, status, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: unions; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.unions (id, company_id, nome, sigla, tipo, categoria, cnpj, inscricao_municipal, inscricao_estadual, razao_social, telefone, email, site, endereco, cidade, estado, cep, presidente, telefone_presidente, email_presidente, data_fundacao, numero_registro, observacoes, ativo, created_at, updated_at) FROM stdin;
c78dc32b-3a07-4c1b-9a40-eabbbecc41ec	a9784891-9d58-4cc4-8404-18032105c335	Sindicato dos Metalúrgicos de São Paulo	SINDIMETAL	trabalhadores	Metalúrgicos	12345678000195	\N	\N	\N	\N	\N	\N	\N	\N	\N	\N	João Silva	\N	\N	\N	\N	\N	t	2025-10-06 18:30:53.409575+00	2025-10-06 18:30:53.409575+00
\.


--
-- Data for Name: units; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.units (id, company_id, nome, descricao, codigo, responsavel_id, is_active, created_at, updated_at, cost_center_id) FROM stdin;
8a7ec50b-d92c-479c-b9b4-2e3a7d838438	a9784891-9d58-4cc4-8404-18032105c335	TI	Tecnologia da Informação	\N	\N	t	2025-10-04 23:36:20.513288+00	2025-10-04 23:36:20.513288+00	\N
02f76c8f-ef4e-4a9a-a414-5e7455a6d0b8	a9784891-9d58-4cc4-8404-18032105c335	RH	Recursos Humanos	\N	\N	t	2025-10-04 23:36:20.513288+00	2025-10-04 23:36:20.513288+00	\N
789d87b3-4fa8-49f3-9d3f-805363564c0d	a9784891-9d58-4cc4-8404-18032105c335	Recursos Humanos	GestÃ£o de pessoas e processos administrativos	RH	\N	t	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
89e9df48-ef01-4187-b894-de43297562e7	a9784891-9d58-4cc4-8404-18032105c335	Tecnologia da InformaÃ§Ã£o	Desenvolvimento e manutenÃ§Ã£o de sistemas	TI	\N	t	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
bbcc3bc1-2cfb-44f1-a92e-bd31166a379f	a9784891-9d58-4cc4-8404-18032105c335	Financeiro	GestÃ£o financeira e contÃ¡bil	FIN	\N	t	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
502a5ff1-9b9e-42b0-8428-f29a44eeaba6	a9784891-9d58-4cc4-8404-18032105c335	Comercial	Vendas e relacionamento com clientes	COM	\N	t	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
44ed7f65-7deb-4645-91a9-0cd68f627fac	a9784891-9d58-4cc4-8404-18032105c335	OperaÃ§Ãµes	GestÃ£o operacional e logÃ­stica	OP	\N	t	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
21e2b089-ba95-4124-b3d3-5a68ec0db385	a9784891-9d58-4cc4-8404-18032105c335	Marketing	EstratÃ©gias de marketing e comunicaÃ§Ã£o	MKT	\N	f	2025-10-04 23:56:29.956479+00	2025-10-04 23:56:29.956479+00	\N
2400ee57-5ca3-4b8c-8b61-8a6c30b388f4	a9784891-9d58-4cc4-8404-18032105c335	TI	Tecnologia da Informação	\N	\N	t	2025-10-07 00:47:46.466157+00	2025-10-07 00:47:46.466157+00	\N
\.


--
-- Data for Name: vacation_entitlements; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.vacation_entitlements (id, employee_id, company_id, ano_aquisitivo, data_inicio_periodo, data_fim_periodo, dias_disponiveis, dias_gozados, status, data_vencimento, observacoes, created_at, updated_at) FROM stdin;
91fdfa37-8722-4303-b1e1-eb851952ad2f	f1a121b9-fdf0-4b15-8162-aaaa0f5a1deb	a9784891-9d58-4cc4-8404-18032105c335	2024	2024-01-01	2024-12-31	30	0	ativo	\N	\N	2025-10-10 22:25:53.089923+00	2025-10-10 22:25:53.089923+00
\.


--
-- Data for Name: vacation_periods; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.vacation_periods (id, vacation_id, data_inicio, data_fim, dias_ferias, dias_abono, periodo_numero, observacoes, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: vacations; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.vacations (id, employee_id, company_id, tipo, data_inicio, data_fim, dias_solicitados, status, observacoes, anexos, solicitado_por, aprovado_por, aprovado_em, created_at, updated_at) FROM stdin;
b1656182-c57f-4cb8-8bc3-d67514c15e90	40f8884c-a60b-4237-bc92-afcad528896b	a9784891-9d58-4cc4-8404-18032105c335	ferias	2025-10-25	2025-11-01	7	pendente	SolicitaÃ§Ã£o de fÃ©rias para descanso	\N	\N	\N	\N	2025-10-18 19:30:24.922445+00	2025-10-18 19:30:24.922445+00
\.


--
-- Data for Name: work_schedules; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.work_schedules (id, company_id, nome, descricao, carga_horaria_semanal, dias_trabalho, horario_inicio, horario_fim, intervalo_almoco, tolerancia_entrada, tolerancia_saida, is_active, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: work_shifts; Type: TABLE DATA; Schema: rh; Owner: postgres
--

COPY rh.work_shifts (id, company_id, nome, codigo, descricao, hora_inicio, hora_fim, intervalo_inicio, intervalo_fim, horas_diarias, dias_semana, tipo_turno, tolerancia_entrada, tolerancia_saida, status, created_at, updated_at, tipo_escala, dias_trabalho, dias_folga, ciclo_dias, regras_clt, template_escala) FROM stdin;
\.


--
-- Data for Name: buckets; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.buckets (id, name, owner, created_at, updated_at, public, avif_autodetection, file_size_limit, allowed_mime_types, owner_id, type) FROM stdin;
income-statements	income-statements	\N	2025-10-18 15:06:22.545282+00	2025-10-18 15:06:22.545282+00	f	f	52428800	{application/pdf,image/jpeg,image/png,image/jpg}	\N	STANDARD
reimbursements	reimbursements	\N	2025-10-18 15:06:22.619178+00	2025-10-18 15:06:22.619178+00	f	f	52428800	{application/pdf,image/jpeg,image/png,image/jpg}	\N	STANDARD
holerites	holerites	\N	2025-10-18 15:06:22.677192+00	2025-10-18 15:06:22.677192+00	f	f	52428800	{application/pdf,image/jpeg,image/png,image/jpg}	\N	STANDARD
medical-certificates	medical-certificates	\N	2025-10-18 15:06:22.729201+00	2025-10-18 15:06:22.729201+00	f	f	52428800	{application/pdf,image/jpeg,image/png,image/jpg}	\N	STANDARD
employee-photos	employee-photos	\N	2025-10-18 17:08:41.400834+00	2025-10-18 17:08:41.400834+00	t	f	5242880	{image/jpeg,image/jpg,image/png,image/webp}	\N	STANDARD
\.


--
-- Data for Name: buckets_analytics; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.buckets_analytics (id, type, format, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: migrations; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.migrations (id, name, hash, executed_at) FROM stdin;
0	create-migrations-table	e18db593bcde2aca2a408c4d1100f6abba2195df	2025-10-03 10:30:32.755327
1	initialmigration	6ab16121fbaa08bbd11b712d05f358f9b555d777	2025-10-03 10:30:32.767014
2	storage-schema	5c7968fd083fcea04050c1b7f6253c9771b99011	2025-10-03 10:30:32.778249
3	pathtoken-column	2cb1b0004b817b29d5b0a971af16bafeede4b70d	2025-10-03 10:30:32.797578
4	add-migrations-rls	427c5b63fe1c5937495d9c635c263ee7a5905058	2025-10-03 10:30:32.815772
5	add-size-functions	79e081a1455b63666c1294a440f8ad4b1e6a7f84	2025-10-03 10:30:32.8279
6	change-column-name-in-get-size	f93f62afdf6613ee5e7e815b30d02dc990201044	2025-10-03 10:30:32.840259
7	add-rls-to-buckets	e7e7f86adbc51049f341dfe8d30256c1abca17aa	2025-10-03 10:30:32.852036
8	add-public-to-buckets	fd670db39ed65f9d08b01db09d6202503ca2bab3	2025-10-03 10:30:32.863843
9	fix-search-function	3a0af29f42e35a4d101c259ed955b67e1bee6825	2025-10-03 10:30:32.876299
10	search-files-search-function	68dc14822daad0ffac3746a502234f486182ef6e	2025-10-03 10:30:32.888286
11	add-trigger-to-auto-update-updated_at-column	7425bdb14366d1739fa8a18c83100636d74dcaa2	2025-10-03 10:30:32.900405
12	add-automatic-avif-detection-flag	8e92e1266eb29518b6a4c5313ab8f29dd0d08df9	2025-10-03 10:30:32.912572
13	add-bucket-custom-limits	cce962054138135cd9a8c4bcd531598684b25e7d	2025-10-03 10:30:32.923979
14	use-bytes-for-max-size	941c41b346f9802b411f06f30e972ad4744dad27	2025-10-03 10:30:32.935521
15	add-can-insert-object-function	934146bc38ead475f4ef4b555c524ee5d66799e5	2025-10-03 10:30:32.959797
16	add-version	76debf38d3fd07dcfc747ca49096457d95b1221b	2025-10-03 10:30:32.972225
17	drop-owner-foreign-key	f1cbb288f1b7a4c1eb8c38504b80ae2a0153d101	2025-10-03 10:30:32.9838
18	add_owner_id_column_deprecate_owner	e7a511b379110b08e2f214be852c35414749fe66	2025-10-03 10:30:32.997042
19	alter-default-value-objects-id	02e5e22a78626187e00d173dc45f58fa66a4f043	2025-10-03 10:30:33.010706
20	list-objects-with-delimiter	cd694ae708e51ba82bf012bba00caf4f3b6393b7	2025-10-03 10:30:33.023387
21	s3-multipart-uploads	8c804d4a566c40cd1e4cc5b3725a664a9303657f	2025-10-03 10:30:33.038417
22	s3-multipart-uploads-big-ints	9737dc258d2397953c9953d9b86920b8be0cdb73	2025-10-03 10:30:33.060276
23	optimize-search-function	9d7e604cddc4b56a5422dc68c9313f4a1b6f132c	2025-10-03 10:30:33.07849
24	operation-function	8312e37c2bf9e76bbe841aa5fda889206d2bf8aa	2025-10-03 10:30:33.091587
25	custom-metadata	d974c6057c3db1c1f847afa0e291e6165693b990	2025-10-03 10:30:33.103573
26	objects-prefixes	ef3f7871121cdc47a65308e6702519e853422ae2	2025-10-03 10:30:33.115749
27	search-v2	33b8f2a7ae53105f028e13e9fcda9dc4f356b4a2	2025-10-03 10:30:33.13446
28	object-bucket-name-sorting	ba85ec41b62c6a30a3f136788227ee47f311c436	2025-10-03 10:30:37.242971
29	create-prefixes	a7b1a22c0dc3ab630e3055bfec7ce7d2045c5b7b	2025-10-03 10:30:37.25154
30	update-object-levels	6c6f6cc9430d570f26284a24cf7b210599032db7	2025-10-03 10:30:37.259562
31	objects-level-index	33f1fef7ec7fea08bb892222f4f0f5d79bab5eb8	2025-10-03 10:30:37.270142
32	backward-compatible-index-on-objects	2d51eeb437a96868b36fcdfb1ddefdf13bef1647	2025-10-03 10:30:37.280949
33	backward-compatible-index-on-prefixes	fe473390e1b8c407434c0e470655945b110507bf	2025-10-03 10:30:37.291944
34	optimize-search-function-v1	82b0e469a00e8ebce495e29bfa70a0797f7ebd2c	2025-10-03 10:30:37.295721
35	add-insert-trigger-prefixes	63bb9fd05deb3dc5e9fa66c83e82b152f0caf589	2025-10-03 10:30:37.308678
36	optimise-existing-functions	81cf92eb0c36612865a18016a38496c530443899	2025-10-03 10:30:37.320334
37	add-bucket-name-length-trigger	3944135b4e3e8b22d6d4cbb568fe3b0b51df15c1	2025-10-03 10:30:37.334375
38	iceberg-catalog-flag-on-buckets	19a8bd89d5dfa69af7f222a46c726b7c41e462c5	2025-10-03 10:30:37.346532
39	add-search-v2-sort-support	39cf7d1e6bf515f4b02e41237aba845a7b492853	2025-10-03 10:30:37.361983
40	fix-prefix-race-conditions-optimized	fd02297e1c67df25a9fc110bf8c8a9af7fb06d1f	2025-10-03 10:30:37.374435
41	add-object-level-update-trigger	44c22478bf01744b2129efc480cd2edc9a7d60e9	2025-10-03 10:30:37.388985
42	rollback-prefix-triggers	f2ab4f526ab7f979541082992593938c05ee4b47	2025-10-03 10:30:37.401855
43	fix-object-level	ab837ad8f1c7d00cc0b7310e989a23388ff29fc6	2025-10-03 10:30:37.41485
\.


--
-- Data for Name: objects; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.objects (id, bucket_id, name, owner, created_at, updated_at, last_accessed_at, metadata, version, owner_id, user_metadata, level) FROM stdin;
\.


--
-- Data for Name: prefixes; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.prefixes (bucket_id, name, created_at, updated_at) FROM stdin;
\.


--
-- Data for Name: s3_multipart_uploads; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.s3_multipart_uploads (id, in_progress_size, upload_signature, bucket_id, key, version, owner_id, created_at, user_metadata) FROM stdin;
\.


--
-- Data for Name: s3_multipart_uploads_parts; Type: TABLE DATA; Schema: storage; Owner: supabase_storage_admin
--

COPY storage.s3_multipart_uploads_parts (id, upload_id, size, part_number, bucket_id, key, etag, owner_id, version, created_at) FROM stdin;
\.


--
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: supabase_migrations; Owner: postgres
--

COPY supabase_migrations.schema_migrations (version, statements, name, created_by, idempotency_key) FROM stdin;
\.


--
-- Data for Name: secrets; Type: TABLE DATA; Schema: vault; Owner: supabase_admin
--

COPY vault.secrets (id, name, description, secret, key_id, nonce, created_at, updated_at) FROM stdin;
\.


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE SET; Schema: auth; Owner: supabase_auth_admin
--

SELECT pg_catalog.setval('auth.refresh_tokens_id_seq', 123, true);


--
-- Name: company_number_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.company_number_seq', 1, false);


--
-- Name: subscription_id_seq; Type: SEQUENCE SET; Schema: realtime; Owner: supabase_admin
--

SELECT pg_catalog.setval('realtime.subscription_id_seq', 1, false);


--
-- Name: almoxarifados almoxarifados_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.almoxarifados
    ADD CONSTRAINT almoxarifados_pkey PRIMARY KEY (id);


--
-- Name: checklist_recebimento checklist_recebimento_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.checklist_recebimento
    ADD CONSTRAINT checklist_recebimento_pkey PRIMARY KEY (id);


--
-- Name: entrada_itens entrada_itens_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_pkey PRIMARY KEY (id);


--
-- Name: entradas_materiais entradas_materiais_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_pkey PRIMARY KEY (id);


--
-- Name: estoque_atual estoque_atual_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.estoque_atual
    ADD CONSTRAINT estoque_atual_pkey PRIMARY KEY (id);


--
-- Name: inventario_itens inventario_itens_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT inventario_itens_pkey PRIMARY KEY (id);


--
-- Name: inventarios inventarios_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventarios
    ADD CONSTRAINT inventarios_pkey PRIMARY KEY (id);


--
-- Name: localizacoes_fisicas localizacoes_fisicas_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.localizacoes_fisicas
    ADD CONSTRAINT localizacoes_fisicas_pkey PRIMARY KEY (id);


--
-- Name: materiais_equipamentos materiais_equipamentos_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.materiais_equipamentos
    ADD CONSTRAINT materiais_equipamentos_pkey PRIMARY KEY (id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_pkey PRIMARY KEY (id);


--
-- Name: solicitacoes_compra solicitacoes_compra_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_pkey PRIMARY KEY (id);


--
-- Name: solicitacoes_saida_materiais_itens solicitacoes_saida_materiais_itens_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais_itens
    ADD CONSTRAINT solicitacoes_saida_materiais_itens_pkey PRIMARY KEY (id);


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_pkey PRIMARY KEY (id);


--
-- Name: transferencia_itens transferencia_itens_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_pkey PRIMARY KEY (id);


--
-- Name: transferencias transferencias_pkey; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_pkey PRIMARY KEY (id);


--
-- Name: almoxarifados unique_almoxarifado_codigo_company; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.almoxarifados
    ADD CONSTRAINT unique_almoxarifado_codigo_company UNIQUE (codigo, company_id);


--
-- Name: materiais_equipamentos unique_codigo_interno_company; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.materiais_equipamentos
    ADD CONSTRAINT unique_codigo_interno_company UNIQUE (codigo_interno, company_id);


--
-- Name: estoque_atual unique_estoque_material_almoxarifado; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.estoque_atual
    ADD CONSTRAINT unique_estoque_material_almoxarifado UNIQUE (material_equipamento_id, almoxarifado_id);


--
-- Name: inventario_itens unique_inventario_item; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT unique_inventario_item UNIQUE (inventario_id, material_equipamento_id);


--
-- Name: localizacoes_fisicas unique_localizacao; Type: CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.localizacoes_fisicas
    ADD CONSTRAINT unique_localizacao UNIQUE (almoxarifado_id, rua, nivel, posicao);


--
-- Name: mfa_amr_claims amr_id_pk; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT amr_id_pk PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: flow_state flow_state_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.flow_state
    ADD CONSTRAINT flow_state_pkey PRIMARY KEY (id);


--
-- Name: identities identities_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_pkey PRIMARY KEY (id);


--
-- Name: identities identities_provider_id_provider_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider);


--
-- Name: instances instances_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.instances
    ADD CONSTRAINT instances_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_authentication_method_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method);


--
-- Name: mfa_challenges mfa_challenges_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id);


--
-- Name: mfa_factors mfa_factors_last_challenged_at_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at);


--
-- Name: mfa_factors mfa_factors_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_pkey PRIMARY KEY (id);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_code_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_code_key UNIQUE (authorization_code);


--
-- Name: oauth_authorizations oauth_authorizations_authorization_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_authorization_id_key UNIQUE (authorization_id);


--
-- Name: oauth_authorizations oauth_authorizations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_pkey PRIMARY KEY (id);


--
-- Name: oauth_clients oauth_clients_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_clients
    ADD CONSTRAINT oauth_clients_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_pkey PRIMARY KEY (id);


--
-- Name: oauth_consents oauth_consents_user_client_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_client_unique UNIQUE (user_id, client_id);


--
-- Name: one_time_tokens one_time_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_token_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_token_unique UNIQUE (token);


--
-- Name: saml_providers saml_providers_entity_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id);


--
-- Name: saml_providers saml_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_pkey PRIMARY KEY (id);


--
-- Name: saml_relay_states saml_relay_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sso_domains sso_domains_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_pkey PRIMARY KEY (id);


--
-- Name: sso_providers sso_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_providers
    ADD CONSTRAINT sso_providers_pkey PRIMARY KEY (id);


--
-- Name: users users_phone_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_phone_key UNIQUE (phone);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: aprovacoes_cotacao aprovacoes_cotacao_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_cotacao
    ADD CONSTRAINT aprovacoes_cotacao_pkey PRIMARY KEY (id);


--
-- Name: aprovacoes_requisicao aprovacoes_requisicao_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_requisicao
    ADD CONSTRAINT aprovacoes_requisicao_pkey PRIMARY KEY (id);


--
-- Name: avaliacoes_fornecedor avaliacoes_fornecedor_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.avaliacoes_fornecedor
    ADD CONSTRAINT avaliacoes_fornecedor_pkey PRIMARY KEY (id);


--
-- Name: compras_recorrentes compras_recorrentes_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.compras_recorrentes
    ADD CONSTRAINT compras_recorrentes_pkey PRIMARY KEY (id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_company_id_tipo_documento_valor_lim_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_company_id_tipo_documento_valor_lim_key UNIQUE (company_id, tipo_documento, valor_limite, nivel_aprovacao);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_pkey PRIMARY KEY (id);


--
-- Name: contratos contratos_company_id_numero_contrato_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.contratos
    ADD CONSTRAINT contratos_company_id_numero_contrato_key UNIQUE (company_id, numero_contrato);


--
-- Name: contratos contratos_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.contratos
    ADD CONSTRAINT contratos_pkey PRIMARY KEY (id);


--
-- Name: cotacao_itens cotacao_itens_cotacao_id_requisicao_item_id_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacao_itens
    ADD CONSTRAINT cotacao_itens_cotacao_id_requisicao_item_id_key UNIQUE (cotacao_id, requisicao_item_id);


--
-- Name: cotacao_itens cotacao_itens_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacao_itens
    ADD CONSTRAINT cotacao_itens_pkey PRIMARY KEY (id);


--
-- Name: cotacoes cotacoes_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacoes
    ADD CONSTRAINT cotacoes_pkey PRIMARY KEY (id);


--
-- Name: cotacoes cotacoes_requisicao_id_fornecedor_id_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacoes
    ADD CONSTRAINT cotacoes_requisicao_id_fornecedor_id_key UNIQUE (requisicao_id, fornecedor_id);


--
-- Name: fornecedores_dados fornecedores_dados_partner_id_company_id_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.fornecedores_dados
    ADD CONSTRAINT fornecedores_dados_partner_id_company_id_key UNIQUE (partner_id, company_id);


--
-- Name: fornecedores_dados fornecedores_dados_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.fornecedores_dados
    ADD CONSTRAINT fornecedores_dados_pkey PRIMARY KEY (id);


--
-- Name: historico_compras historico_compras_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_compras
    ADD CONSTRAINT historico_compras_pkey PRIMARY KEY (id);


--
-- Name: historico_precos historico_precos_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_precos
    ADD CONSTRAINT historico_precos_pkey PRIMARY KEY (id);


--
-- Name: pedido_itens pedido_itens_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedido_itens
    ADD CONSTRAINT pedido_itens_pkey PRIMARY KEY (id);


--
-- Name: pedidos_compra pedidos_compra_company_id_numero_pedido_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_company_id_numero_pedido_key UNIQUE (company_id, numero_pedido);


--
-- Name: pedidos_compra pedidos_compra_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_pkey PRIMARY KEY (id);


--
-- Name: requisicao_itens requisicao_itens_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicao_itens
    ADD CONSTRAINT requisicao_itens_pkey PRIMARY KEY (id);


--
-- Name: requisicao_itens requisicao_itens_requisicao_id_material_id_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicao_itens
    ADD CONSTRAINT requisicao_itens_requisicao_id_material_id_key UNIQUE (requisicao_id, material_id);


--
-- Name: requisicoes_compra requisicoes_compra_company_id_numero_requisicao_key; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_company_id_numero_requisicao_key UNIQUE (company_id, numero_requisicao);


--
-- Name: requisicoes_compra requisicoes_compra_pkey; Type: CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_pkey PRIMARY KEY (id);


--
-- Name: aprovacoes aprovacoes_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.aprovacoes
    ADD CONSTRAINT aprovacoes_pkey PRIMARY KEY (id);


--
-- Name: borderos borderos_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.borderos
    ADD CONSTRAINT borderos_pkey PRIMARY KEY (id);


--
-- Name: conciliacoes_bancarias conciliacoes_bancarias_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.conciliacoes_bancarias
    ADD CONSTRAINT conciliacoes_bancarias_pkey PRIMARY KEY (id);


--
-- Name: configuracao_bancaria configuracao_bancaria_company_banco_unique; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_bancaria
    ADD CONSTRAINT configuracao_bancaria_company_banco_unique UNIQUE (company_id, banco_codigo, ambiente);


--
-- Name: configuracao_bancaria configuracao_bancaria_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_bancaria
    ADD CONSTRAINT configuracao_bancaria_pkey PRIMARY KEY (id);


--
-- Name: configuracao_fiscal configuracao_fiscal_company_uf_tipo_unique; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_fiscal
    ADD CONSTRAINT configuracao_fiscal_company_uf_tipo_unique UNIQUE (company_id, uf, tipo_documento, ambiente);


--
-- Name: configuracao_fiscal configuracao_fiscal_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_fiscal
    ADD CONSTRAINT configuracao_fiscal_pkey PRIMARY KEY (id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_pkey PRIMARY KEY (id);


--
-- Name: contas_bancarias contas_bancarias_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_bancarias
    ADD CONSTRAINT contas_bancarias_pkey PRIMARY KEY (id);


--
-- Name: contas_pagar contas_pagar_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_pkey PRIMARY KEY (id);


--
-- Name: contas_receber contas_receber_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_pkey PRIMARY KEY (id);


--
-- Name: fluxo_caixa fluxo_caixa_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_pkey PRIMARY KEY (id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_pkey PRIMARY KEY (id);


--
-- Name: log_validacao_integracao log_validacao_integracao_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.log_validacao_integracao
    ADD CONSTRAINT log_validacao_integracao_pkey PRIMARY KEY (id);


--
-- Name: nfe nfe_chave_acesso_key; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfe
    ADD CONSTRAINT nfe_chave_acesso_key UNIQUE (chave_acesso);


--
-- Name: nfe nfe_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfe
    ADD CONSTRAINT nfe_pkey PRIMARY KEY (id);


--
-- Name: nfse nfse_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfse
    ADD CONSTRAINT nfse_pkey PRIMARY KEY (id);


--
-- Name: plano_contas plano_contas_company_id_codigo_key; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.plano_contas
    ADD CONSTRAINT plano_contas_company_id_codigo_key UNIQUE (company_id, codigo);


--
-- Name: plano_contas plano_contas_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.plano_contas
    ADD CONSTRAINT plano_contas_pkey PRIMARY KEY (id);


--
-- Name: remessas_bancarias remessas_bancarias_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.remessas_bancarias
    ADD CONSTRAINT remessas_bancarias_pkey PRIMARY KEY (id);


--
-- Name: retornos_bancarios retornos_bancarios_pkey; Type: CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.retornos_bancarios
    ADD CONSTRAINT retornos_bancarios_pkey PRIMARY KEY (id);


--
-- Name: aprovacoes_unificada aprovacoes_unificada_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aprovacoes_unificada
    ADD CONSTRAINT aprovacoes_unificada_pkey PRIMARY KEY (id);


--
-- Name: companies companies_cnpj_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies
    ADD CONSTRAINT companies_cnpj_key UNIQUE (cnpj);


--
-- Name: companies companies_numero_empresa_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies
    ADD CONSTRAINT companies_numero_empresa_key UNIQUE (numero_empresa);


--
-- Name: companies companies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies
    ADD CONSTRAINT companies_pkey PRIMARY KEY (id);


--
-- Name: configuracoes_aprovacao_unificada configuracoes_aprovacao_unificada_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configuracoes_aprovacao_unificada
    ADD CONSTRAINT configuracoes_aprovacao_unificada_pkey PRIMARY KEY (id);


--
-- Name: cost_centers cost_centers_company_id_codigo_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cost_centers
    ADD CONSTRAINT cost_centers_company_id_codigo_key UNIQUE (company_id, codigo);


--
-- Name: cost_centers cost_centers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cost_centers
    ADD CONSTRAINT cost_centers_pkey PRIMARY KEY (id);


--
-- Name: entity_permissions entity_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.entity_permissions
    ADD CONSTRAINT entity_permissions_pkey PRIMARY KEY (id);


--
-- Name: entity_permissions entity_permissions_profile_id_entity_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.entity_permissions
    ADD CONSTRAINT entity_permissions_profile_id_entity_name_key UNIQUE (profile_id, entity_name);


--
-- Name: historico_edicoes_solicitacoes historico_edicoes_solicitacoes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.historico_edicoes_solicitacoes
    ADD CONSTRAINT historico_edicoes_solicitacoes_pkey PRIMARY KEY (id);


--
-- Name: module_permissions module_permissions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.module_permissions
    ADD CONSTRAINT module_permissions_pkey PRIMARY KEY (id);


--
-- Name: module_permissions module_permissions_profile_id_module_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.module_permissions
    ADD CONSTRAINT module_permissions_profile_id_module_name_key UNIQUE (profile_id, module_name);


--
-- Name: notifications notifications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_pkey PRIMARY KEY (id);


--
-- Name: partners partners_company_id_cnpj_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partners
    ADD CONSTRAINT partners_company_id_cnpj_key UNIQUE (company_id, cnpj);


--
-- Name: partners partners_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partners
    ADD CONSTRAINT partners_pkey PRIMARY KEY (id);


--
-- Name: profiles profiles_nome_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_nome_key UNIQUE (nome);


--
-- Name: profiles profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profiles
    ADD CONSTRAINT profiles_pkey PRIMARY KEY (id);


--
-- Name: projects projects_company_id_codigo_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_company_id_codigo_key UNIQUE (company_id, codigo);


--
-- Name: projects projects_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_pkey PRIMARY KEY (id);


--
-- Name: user_companies user_companies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_companies
    ADD CONSTRAINT user_companies_pkey PRIMARY KEY (id);


--
-- Name: user_companies user_companies_user_id_company_id_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_companies
    ADD CONSTRAINT user_companies_user_id_company_id_key UNIQUE (user_id, company_id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE ONLY realtime.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: subscription pk_subscription; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.subscription
    ADD CONSTRAINT pk_subscription PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: absence_types absence_types_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.absence_types
    ADD CONSTRAINT absence_types_pkey PRIMARY KEY (id);


--
-- Name: allowance_types allowance_types_codigo_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.allowance_types
    ADD CONSTRAINT allowance_types_codigo_key UNIQUE (codigo);


--
-- Name: allowance_types allowance_types_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.allowance_types
    ADD CONSTRAINT allowance_types_pkey PRIMARY KEY (id);


--
-- Name: approval_level_approvers approval_level_approvers_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.approval_level_approvers
    ADD CONSTRAINT approval_level_approvers_pkey PRIMARY KEY (id);


--
-- Name: approval_levels approval_levels_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.approval_levels
    ADD CONSTRAINT approval_levels_pkey PRIMARY KEY (id);


--
-- Name: attendance_corrections attendance_corrections_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.attendance_corrections
    ADD CONSTRAINT attendance_corrections_pkey PRIMARY KEY (id);


--
-- Name: audit_config audit_config_company_id_entity_type_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_config
    ADD CONSTRAINT audit_config_company_id_entity_type_key UNIQUE (company_id, entity_type);


--
-- Name: audit_config audit_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_config
    ADD CONSTRAINT audit_config_pkey PRIMARY KEY (id);


--
-- Name: audit_logs audit_logs_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_logs
    ADD CONSTRAINT audit_logs_pkey PRIMARY KEY (id);


--
-- Name: bank_hours_balance bank_hours_balance_employee_id_company_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_balance
    ADD CONSTRAINT bank_hours_balance_employee_id_company_id_key UNIQUE (employee_id, company_id);


--
-- Name: bank_hours_balance bank_hours_balance_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_balance
    ADD CONSTRAINT bank_hours_balance_pkey PRIMARY KEY (id);


--
-- Name: bank_hours_calculations bank_hours_calculations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_calculations
    ADD CONSTRAINT bank_hours_calculations_pkey PRIMARY KEY (id);


--
-- Name: bank_hours_config bank_hours_config_employee_id_company_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_config
    ADD CONSTRAINT bank_hours_config_employee_id_company_id_key UNIQUE (employee_id, company_id);


--
-- Name: bank_hours_config bank_hours_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_config
    ADD CONSTRAINT bank_hours_config_pkey PRIMARY KEY (id);


--
-- Name: bank_hours_transactions bank_hours_transactions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_pkey PRIMARY KEY (id);


--
-- Name: benefit_configurations benefit_configurations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.benefit_configurations
    ADD CONSTRAINT benefit_configurations_pkey PRIMARY KEY (id);


--
-- Name: calculation_logs calculation_logs_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.calculation_logs
    ADD CONSTRAINT calculation_logs_pkey PRIMARY KEY (id);


--
-- Name: candidate_documents candidate_documents_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidate_documents
    ADD CONSTRAINT candidate_documents_pkey PRIMARY KEY (id);


--
-- Name: candidates candidates_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidates
    ADD CONSTRAINT candidates_pkey PRIMARY KEY (id);


--
-- Name: cid_codes cid_codes_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.cid_codes
    ADD CONSTRAINT cid_codes_pkey PRIMARY KEY (id);


--
-- Name: collective_agreements collective_agreements_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.collective_agreements
    ADD CONSTRAINT collective_agreements_pkey PRIMARY KEY (id);


--
-- Name: compensation_approvals compensation_approvals_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_approvals
    ADD CONSTRAINT compensation_approvals_pkey PRIMARY KEY (id);


--
-- Name: compensation_requests compensation_requests_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_requests
    ADD CONSTRAINT compensation_requests_pkey PRIMARY KEY (id);


--
-- Name: correction_history correction_history_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_history
    ADD CONSTRAINT correction_history_pkey PRIMARY KEY (id);


--
-- Name: correction_settings correction_settings_company_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_settings
    ADD CONSTRAINT correction_settings_company_id_key UNIQUE (company_id);


--
-- Name: correction_settings correction_settings_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_settings
    ADD CONSTRAINT correction_settings_pkey PRIMARY KEY (id);


--
-- Name: deficiency_types deficiency_types_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.deficiency_types
    ADD CONSTRAINT deficiency_types_pkey PRIMARY KEY (id);


--
-- Name: delay_reasons delay_reasons_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.delay_reasons
    ADD CONSTRAINT delay_reasons_pkey PRIMARY KEY (id);


--
-- Name: dependents dependents_cpf_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_cpf_key UNIQUE (cpf);


--
-- Name: dependents dependents_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_pkey PRIMARY KEY (id);


--
-- Name: disciplinary_actions disciplinary_actions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.disciplinary_actions
    ADD CONSTRAINT disciplinary_actions_pkey PRIMARY KEY (id);


--
-- Name: employee_benefit_assignments employee_benefit_assignments_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_benefit_assignments
    ADD CONSTRAINT employee_benefit_assignments_pkey PRIMARY KEY (id);


--
-- Name: employee_correction_permissions employee_correction_permissions_employee_id_mes_ano_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_correction_permissions
    ADD CONSTRAINT employee_correction_permissions_employee_id_mes_ano_key UNIQUE (employee_id, mes_ano);


--
-- Name: employee_correction_permissions employee_correction_permissions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_correction_permissions
    ADD CONSTRAINT employee_correction_permissions_pkey PRIMARY KEY (id);


--
-- Name: employee_medical_plans employee_medical_plans_employee_id_plan_id_data_inicio_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_medical_plans
    ADD CONSTRAINT employee_medical_plans_employee_id_plan_id_data_inicio_key UNIQUE (employee_id, plan_id, data_inicio);


--
-- Name: employee_medical_plans employee_medical_plans_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_medical_plans
    ADD CONSTRAINT employee_medical_plans_pkey PRIMARY KEY (id);


--
-- Name: employee_plan_dependents employee_plan_dependents_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_plan_dependents
    ADD CONSTRAINT employee_plan_dependents_pkey PRIMARY KEY (id);


--
-- Name: employee_schedules employee_schedules_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_schedules
    ADD CONSTRAINT employee_schedules_pkey PRIMARY KEY (id);


--
-- Name: employee_shifts employee_shifts_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_shifts
    ADD CONSTRAINT employee_shifts_pkey PRIMARY KEY (id);


--
-- Name: employee_union_memberships employee_union_memberships_employee_id_union_id_data_filiac_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_union_memberships
    ADD CONSTRAINT employee_union_memberships_employee_id_union_id_data_filiac_key UNIQUE (employee_id, union_id, data_filiacao);


--
-- Name: employee_union_memberships employee_union_memberships_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_union_memberships
    ADD CONSTRAINT employee_union_memberships_pkey PRIMARY KEY (id);


--
-- Name: employees employees_cpf_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT employees_cpf_key UNIQUE (cpf);


--
-- Name: employees employees_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT employees_pkey PRIMARY KEY (id);


--
-- Name: employment_contracts employment_contracts_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employment_contracts
    ADD CONSTRAINT employment_contracts_pkey PRIMARY KEY (id);


--
-- Name: equipment_rental_approvals equipment_rental_approvals_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.equipment_rental_approvals
    ADD CONSTRAINT equipment_rental_approvals_pkey PRIMARY KEY (id);


--
-- Name: esocial_batches esocial_batches_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_batches
    ADD CONSTRAINT esocial_batches_pkey PRIMARY KEY (id);


--
-- Name: esocial_config esocial_config_company_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_config
    ADD CONSTRAINT esocial_config_company_id_key UNIQUE (company_id);


--
-- Name: esocial_config esocial_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_config
    ADD CONSTRAINT esocial_config_pkey PRIMARY KEY (id);


--
-- Name: esocial_events esocial_events_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_events
    ADD CONSTRAINT esocial_events_pkey PRIMARY KEY (id);


--
-- Name: esocial_integrations esocial_integrations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_integrations
    ADD CONSTRAINT esocial_integrations_pkey PRIMARY KEY (id);


--
-- Name: esocial_logs esocial_logs_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_logs
    ADD CONSTRAINT esocial_logs_pkey PRIMARY KEY (id);


--
-- Name: event_consolidations event_consolidations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.event_consolidations
    ADD CONSTRAINT event_consolidations_pkey PRIMARY KEY (id);


--
-- Name: fgts_config fgts_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.fgts_config
    ADD CONSTRAINT fgts_config_pkey PRIMARY KEY (id);


--
-- Name: gestor_notifications gestor_notifications_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.gestor_notifications
    ADD CONSTRAINT gestor_notifications_pkey PRIMARY KEY (id);


--
-- Name: holidays holidays_company_id_data_nome_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.holidays
    ADD CONSTRAINT holidays_company_id_data_nome_key UNIQUE (company_id, data, nome);


--
-- Name: holidays holidays_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.holidays
    ADD CONSTRAINT holidays_pkey PRIMARY KEY (id);


--
-- Name: income_statements income_statements_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.income_statements
    ADD CONSTRAINT income_statements_pkey PRIMARY KEY (id);


--
-- Name: inss_brackets inss_brackets_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.inss_brackets
    ADD CONSTRAINT inss_brackets_pkey PRIMARY KEY (id);


--
-- Name: irrf_brackets irrf_brackets_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.irrf_brackets
    ADD CONSTRAINT irrf_brackets_pkey PRIMARY KEY (id);


--
-- Name: job_openings job_openings_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_openings
    ADD CONSTRAINT job_openings_pkey PRIMARY KEY (id);


--
-- Name: job_requests job_requests_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_requests
    ADD CONSTRAINT job_requests_pkey PRIMARY KEY (id);


--
-- Name: medical_agreements medical_agreements_company_id_nome_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_agreements
    ADD CONSTRAINT medical_agreements_company_id_nome_key UNIQUE (company_id, nome);


--
-- Name: medical_agreements medical_agreements_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_agreements
    ADD CONSTRAINT medical_agreements_pkey PRIMARY KEY (id);


--
-- Name: medical_certificate_attachments medical_certificate_attachments_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificate_attachments
    ADD CONSTRAINT medical_certificate_attachments_pkey PRIMARY KEY (id);


--
-- Name: medical_certificates medical_certificates_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificates
    ADD CONSTRAINT medical_certificates_pkey PRIMARY KEY (id);


--
-- Name: medical_plan_pricing_history medical_plan_pricing_history_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plan_pricing_history
    ADD CONSTRAINT medical_plan_pricing_history_pkey PRIMARY KEY (id);


--
-- Name: medical_plans medical_plans_agreement_id_nome_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plans
    ADD CONSTRAINT medical_plans_agreement_id_nome_key UNIQUE (agreement_id, nome);


--
-- Name: medical_plans medical_plans_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plans
    ADD CONSTRAINT medical_plans_pkey PRIMARY KEY (id);


--
-- Name: monthly_benefit_processing monthly_benefit_processing_employee_id_benefit_config_id_mo_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_employee_id_benefit_config_id_mo_key UNIQUE (employee_id, benefit_config_id, month_reference, year_reference);


--
-- Name: monthly_benefit_processing monthly_benefit_processing_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_pkey PRIMARY KEY (id);


--
-- Name: payroll_config payroll_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_config
    ADD CONSTRAINT payroll_config_pkey PRIMARY KEY (id);


--
-- Name: payroll_config payroll_config_unique_company_period; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_config
    ADD CONSTRAINT payroll_config_unique_company_period UNIQUE (company_id, ano_vigencia, mes_vigencia);


--
-- Name: payroll payroll_employee_id_mes_referencia_ano_referencia_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll
    ADD CONSTRAINT payroll_employee_id_mes_referencia_ano_referencia_key UNIQUE (employee_id, mes_referencia, ano_referencia);


--
-- Name: payroll_events payroll_events_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_events
    ADD CONSTRAINT payroll_events_pkey PRIMARY KEY (id);


--
-- Name: payroll payroll_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll
    ADD CONSTRAINT payroll_pkey PRIMARY KEY (id);


--
-- Name: periodic_exams periodic_exams_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.periodic_exams
    ADD CONSTRAINT periodic_exams_pkey PRIMARY KEY (id);


--
-- Name: positions positions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.positions
    ADD CONSTRAINT positions_pkey PRIMARY KEY (id);


--
-- Name: reimbursement_requests reimbursement_requests_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reimbursement_requests
    ADD CONSTRAINT reimbursement_requests_pkey PRIMARY KEY (id);


--
-- Name: reports reports_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reports
    ADD CONSTRAINT reports_pkey PRIMARY KEY (id);


--
-- Name: rubricas rubricas_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.rubricas
    ADD CONSTRAINT rubricas_pkey PRIMARY KEY (id);


--
-- Name: schedule_planning schedule_planning_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.schedule_planning
    ADD CONSTRAINT schedule_planning_pkey PRIMARY KEY (id);


--
-- Name: selection_processes selection_processes_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_processes
    ADD CONSTRAINT selection_processes_pkey PRIMARY KEY (id);


--
-- Name: selection_stages selection_stages_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_stages
    ADD CONSTRAINT selection_stages_pkey PRIMARY KEY (id);


--
-- Name: signature_notifications signature_notifications_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.signature_notifications
    ADD CONSTRAINT signature_notifications_pkey PRIMARY KEY (id);


--
-- Name: talent_pool talent_pool_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.talent_pool
    ADD CONSTRAINT talent_pool_pkey PRIMARY KEY (id);


--
-- Name: time_bank time_bank_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_bank
    ADD CONSTRAINT time_bank_pkey PRIMARY KEY (id);


--
-- Name: time_record_signature_config time_record_signature_config_company_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signature_config
    ADD CONSTRAINT time_record_signature_config_company_id_key UNIQUE (company_id);


--
-- Name: time_record_signature_config time_record_signature_config_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signature_config
    ADD CONSTRAINT time_record_signature_config_pkey PRIMARY KEY (id);


--
-- Name: time_record_signatures time_record_signatures_employee_id_month_year_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signatures
    ADD CONSTRAINT time_record_signatures_employee_id_month_year_key UNIQUE (employee_id, month_year);


--
-- Name: time_record_signatures time_record_signatures_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signatures
    ADD CONSTRAINT time_record_signatures_pkey PRIMARY KEY (id);


--
-- Name: time_records time_records_employee_id_data_registro_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_records
    ADD CONSTRAINT time_records_employee_id_data_registro_key UNIQUE (employee_id, data_registro);


--
-- Name: time_records time_records_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_records
    ADD CONSTRAINT time_records_pkey PRIMARY KEY (id);


--
-- Name: training_attendance training_attendance_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_pkey PRIMARY KEY (id);


--
-- Name: training_attendance training_attendance_training_id_employee_id_data_treinament_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_training_id_employee_id_data_treinament_key UNIQUE (training_id, employee_id, data_treinamento);


--
-- Name: training_certificates training_certificates_numero_certificado_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_numero_certificado_key UNIQUE (numero_certificado);


--
-- Name: training_certificates training_certificates_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_pkey PRIMARY KEY (id);


--
-- Name: training_certificates training_certificates_training_id_employee_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_training_id_employee_id_key UNIQUE (training_id, employee_id);


--
-- Name: training_enrollments training_enrollments_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_pkey PRIMARY KEY (id);


--
-- Name: training_enrollments training_enrollments_training_id_employee_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_training_id_employee_id_key UNIQUE (training_id, employee_id);


--
-- Name: training_evaluations training_evaluations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_evaluations
    ADD CONSTRAINT training_evaluations_pkey PRIMARY KEY (id);


--
-- Name: training_evaluations training_evaluations_training_id_employee_id_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_evaluations
    ADD CONSTRAINT training_evaluations_training_id_employee_id_key UNIQUE (training_id, employee_id);


--
-- Name: training_notification_history training_notification_history_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_pkey PRIMARY KEY (id);


--
-- Name: training_notification_queue training_notification_queue_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_pkey PRIMARY KEY (id);


--
-- Name: training_notification_rules training_notification_rules_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_rules
    ADD CONSTRAINT training_notification_rules_pkey PRIMARY KEY (id);


--
-- Name: training_notification_types training_notification_types_company_id_tipo_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_types
    ADD CONSTRAINT training_notification_types_company_id_tipo_key UNIQUE (company_id, tipo);


--
-- Name: training_notification_types training_notification_types_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_types
    ADD CONSTRAINT training_notification_types_pkey PRIMARY KEY (id);


--
-- Name: training_settings training_settings_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_settings
    ADD CONSTRAINT training_settings_pkey PRIMARY KEY (id);


--
-- Name: trainings trainings_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.trainings
    ADD CONSTRAINT trainings_pkey PRIMARY KEY (id);


--
-- Name: union_contributions union_contributions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_contributions
    ADD CONSTRAINT union_contributions_pkey PRIMARY KEY (id);


--
-- Name: union_negotiations union_negotiations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_negotiations
    ADD CONSTRAINT union_negotiations_pkey PRIMARY KEY (id);


--
-- Name: union_representatives union_representatives_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_representatives
    ADD CONSTRAINT union_representatives_pkey PRIMARY KEY (id);


--
-- Name: unions unions_company_id_nome_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.unions
    ADD CONSTRAINT unions_company_id_nome_key UNIQUE (company_id, nome);


--
-- Name: unions unions_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.unions
    ADD CONSTRAINT unions_pkey PRIMARY KEY (id);


--
-- Name: absence_types unique_absence_type_codigo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.absence_types
    ADD CONSTRAINT unique_absence_type_codigo_company UNIQUE (codigo, company_id);


--
-- Name: allowance_types unique_allowance_type_codigo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.allowance_types
    ADD CONSTRAINT unique_allowance_type_codigo_company UNIQUE (codigo, company_id);


--
-- Name: cid_codes unique_cid_code_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.cid_codes
    ADD CONSTRAINT unique_cid_code_company UNIQUE (codigo, company_id);


--
-- Name: deficiency_types unique_deficiency_type_codigo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.deficiency_types
    ADD CONSTRAINT unique_deficiency_type_codigo_company UNIQUE (codigo, company_id);


--
-- Name: delay_reasons unique_delay_reason_codigo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.delay_reasons
    ADD CONSTRAINT unique_delay_reason_codigo_company UNIQUE (codigo, company_id);


--
-- Name: vacation_entitlements unique_employee_year_entitlement; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_entitlements
    ADD CONSTRAINT unique_employee_year_entitlement UNIQUE (employee_id, ano_aquisitivo);


--
-- Name: event_consolidations unique_event_consolidation_periodo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.event_consolidations
    ADD CONSTRAINT unique_event_consolidation_periodo_company UNIQUE (periodo, company_id);


--
-- Name: fgts_config unique_fgts_config_company_ano_mes_codigo; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.fgts_config
    ADD CONSTRAINT unique_fgts_config_company_ano_mes_codigo UNIQUE (codigo, company_id, ano_vigencia, mes_vigencia);


--
-- Name: inss_brackets unique_inss_bracket_company_ano_mes_codigo; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.inss_brackets
    ADD CONSTRAINT unique_inss_bracket_company_ano_mes_codigo UNIQUE (codigo, company_id, ano_vigencia, mes_vigencia);


--
-- Name: irrf_brackets unique_irrf_bracket_company_ano_mes_codigo; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.irrf_brackets
    ADD CONSTRAINT unique_irrf_bracket_company_ano_mes_codigo UNIQUE (codigo, company_id, ano_vigencia, mes_vigencia);


--
-- Name: rubricas unique_rubrica_codigo_company; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.rubricas
    ADD CONSTRAINT unique_rubrica_codigo_company UNIQUE (codigo, company_id);


--
-- Name: units units_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.units
    ADD CONSTRAINT units_pkey PRIMARY KEY (id);


--
-- Name: vacation_entitlements vacation_entitlements_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_entitlements
    ADD CONSTRAINT vacation_entitlements_pkey PRIMARY KEY (id);


--
-- Name: vacation_periods vacation_periods_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_periods
    ADD CONSTRAINT vacation_periods_pkey PRIMARY KEY (id);


--
-- Name: vacations vacations_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacations
    ADD CONSTRAINT vacations_pkey PRIMARY KEY (id);


--
-- Name: work_schedules work_schedules_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.work_schedules
    ADD CONSTRAINT work_schedules_pkey PRIMARY KEY (id);


--
-- Name: work_shifts work_shifts_codigo_key; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.work_shifts
    ADD CONSTRAINT work_shifts_codigo_key UNIQUE (codigo);


--
-- Name: work_shifts work_shifts_pkey; Type: CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.work_shifts
    ADD CONSTRAINT work_shifts_pkey PRIMARY KEY (id);


--
-- Name: buckets_analytics buckets_analytics_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets_analytics
    ADD CONSTRAINT buckets_analytics_pkey PRIMARY KEY (id);


--
-- Name: buckets buckets_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets
    ADD CONSTRAINT buckets_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_name_key; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


--
-- Name: objects objects_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT objects_pkey PRIMARY KEY (id);


--
-- Name: prefixes prefixes_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT prefixes_pkey PRIMARY KEY (bucket_id, level, name);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_idempotency_key_key; Type: CONSTRAINT; Schema: supabase_migrations; Owner: postgres
--

ALTER TABLE ONLY supabase_migrations.schema_migrations
    ADD CONSTRAINT schema_migrations_idempotency_key_key UNIQUE (idempotency_key);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: supabase_migrations; Owner: postgres
--

ALTER TABLE ONLY supabase_migrations.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: idx_almoxarifados_ativo; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_almoxarifados_ativo ON almoxarifado.almoxarifados USING btree (ativo) WHERE (ativo = true);


--
-- Name: idx_almoxarifados_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_almoxarifados_company_id ON almoxarifado.almoxarifados USING btree (company_id);


--
-- Name: idx_checklist_recebimento_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_checklist_recebimento_company_id ON almoxarifado.checklist_recebimento USING btree (company_id);


--
-- Name: idx_entrada_itens_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_entrada_itens_company_id ON almoxarifado.entrada_itens USING btree (company_id);


--
-- Name: idx_entradas_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_entradas_company_id ON almoxarifado.entradas_materiais USING btree (company_id);


--
-- Name: idx_entradas_data; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_entradas_data ON almoxarifado.entradas_materiais USING btree (data_entrada);


--
-- Name: idx_entradas_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_entradas_status ON almoxarifado.entradas_materiais USING btree (status);


--
-- Name: idx_estoque_atual_almoxarifado; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_estoque_atual_almoxarifado ON almoxarifado.estoque_atual USING btree (almoxarifado_id);


--
-- Name: idx_estoque_atual_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_estoque_atual_company_id ON almoxarifado.estoque_atual USING btree (company_id);


--
-- Name: idx_estoque_atual_material; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_estoque_atual_material ON almoxarifado.estoque_atual USING btree (material_equipamento_id);


--
-- Name: idx_inventario_itens_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_inventario_itens_company_id ON almoxarifado.inventario_itens USING btree (company_id);


--
-- Name: idx_inventarios_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_inventarios_company_id ON almoxarifado.inventarios USING btree (company_id);


--
-- Name: idx_inventarios_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_inventarios_status ON almoxarifado.inventarios USING btree (status);


--
-- Name: idx_inventarios_tipo; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_inventarios_tipo ON almoxarifado.inventarios USING btree (tipo);


--
-- Name: idx_localizacoes_fisicas_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_localizacoes_fisicas_company_id ON almoxarifado.localizacoes_fisicas USING btree (company_id);


--
-- Name: idx_materiais_equipamentos_cfop; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_cfop ON almoxarifado.materiais_equipamentos USING btree (cfop);


--
-- Name: idx_materiais_equipamentos_codigo; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_codigo ON almoxarifado.materiais_equipamentos USING btree (codigo_interno);


--
-- Name: idx_materiais_equipamentos_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_company_id ON almoxarifado.materiais_equipamentos USING btree (company_id);


--
-- Name: idx_materiais_equipamentos_cst; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_cst ON almoxarifado.materiais_equipamentos USING btree (cst);


--
-- Name: idx_materiais_equipamentos_ncm; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_ncm ON almoxarifado.materiais_equipamentos USING btree (ncm);


--
-- Name: idx_materiais_equipamentos_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_status ON almoxarifado.materiais_equipamentos USING btree (status);


--
-- Name: idx_materiais_equipamentos_tipo; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_materiais_equipamentos_tipo ON almoxarifado.materiais_equipamentos USING btree (tipo);


--
-- Name: idx_movimentacoes_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_movimentacoes_company_id ON almoxarifado.movimentacoes_estoque USING btree (company_id);


--
-- Name: idx_movimentacoes_data; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_movimentacoes_data ON almoxarifado.movimentacoes_estoque USING btree (data_movimentacao);


--
-- Name: idx_movimentacoes_material; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_movimentacoes_material ON almoxarifado.movimentacoes_estoque USING btree (material_equipamento_id);


--
-- Name: idx_movimentacoes_tipo; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_movimentacoes_tipo ON almoxarifado.movimentacoes_estoque USING btree (tipo_movimentacao);


--
-- Name: idx_solic_saida_almoxarifado; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_almoxarifado ON almoxarifado.solicitacoes_saida_materiais USING btree (almoxarifado_id);


--
-- Name: idx_solic_saida_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_company_id ON almoxarifado.solicitacoes_saida_materiais USING btree (company_id);


--
-- Name: idx_solic_saida_data; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_data ON almoxarifado.solicitacoes_saida_materiais USING btree (data_solicitacao);


--
-- Name: idx_solic_saida_funcionario; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_funcionario ON almoxarifado.solicitacoes_saida_materiais USING btree (funcionario_solicitante_id);


--
-- Name: idx_solic_saida_itens_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_itens_company_id ON almoxarifado.solicitacoes_saida_materiais_itens USING btree (company_id);


--
-- Name: idx_solic_saida_itens_material_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_itens_material_id ON almoxarifado.solicitacoes_saida_materiais_itens USING btree (material_id);


--
-- Name: idx_solic_saida_itens_solicitacao_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_itens_solicitacao_id ON almoxarifado.solicitacoes_saida_materiais_itens USING btree (solicitacao_id);


--
-- Name: idx_solic_saida_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solic_saida_status ON almoxarifado.solicitacoes_saida_materiais USING btree (status);


--
-- Name: idx_solicitacoes_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solicitacoes_company_id ON almoxarifado.solicitacoes_compra USING btree (company_id);


--
-- Name: idx_solicitacoes_prioridade; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solicitacoes_prioridade ON almoxarifado.solicitacoes_compra USING btree (prioridade);


--
-- Name: idx_solicitacoes_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_solicitacoes_status ON almoxarifado.solicitacoes_compra USING btree (status);


--
-- Name: idx_transferencia_itens_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_transferencia_itens_company_id ON almoxarifado.transferencia_itens USING btree (company_id);


--
-- Name: idx_transferencias_company_id; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_transferencias_company_id ON almoxarifado.transferencias USING btree (company_id);


--
-- Name: idx_transferencias_solicitante; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_transferencias_solicitante ON almoxarifado.transferencias USING btree (solicitante_id);


--
-- Name: idx_transferencias_status; Type: INDEX; Schema: almoxarifado; Owner: postgres
--

CREATE INDEX idx_transferencias_status ON almoxarifado.transferencias USING btree (status);


--
-- Name: audit_logs_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);


--
-- Name: confirmation_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_current_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_new_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text);


--
-- Name: factor_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at);


--
-- Name: flow_state_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);


--
-- Name: identities_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops);


--
-- Name: INDEX identities_email_idx; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.identities_email_idx IS 'Auth: Ensures indexed queries on the email column';


--
-- Name: identities_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id);


--
-- Name: idx_auth_code; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code);


--
-- Name: idx_user_id_auth_method; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method);


--
-- Name: mfa_challenge_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);


--
-- Name: mfa_factors_user_friendly_name_unique; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text);


--
-- Name: mfa_factors_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id);


--
-- Name: oauth_auth_pending_exp_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_auth_pending_exp_idx ON auth.oauth_authorizations USING btree (expires_at) WHERE (status = 'pending'::auth.oauth_authorization_status);


--
-- Name: oauth_clients_deleted_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_clients_deleted_at_idx ON auth.oauth_clients USING btree (deleted_at);


--
-- Name: oauth_consents_active_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_client_idx ON auth.oauth_consents USING btree (client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_active_user_client_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_active_user_client_idx ON auth.oauth_consents USING btree (user_id, client_id) WHERE (revoked_at IS NULL);


--
-- Name: oauth_consents_user_order_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX oauth_consents_user_order_idx ON auth.oauth_consents USING btree (user_id, granted_at DESC);


--
-- Name: one_time_tokens_relates_to_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to);


--
-- Name: one_time_tokens_token_hash_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash);


--
-- Name: one_time_tokens_user_id_token_type_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);


--
-- Name: reauthentication_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: recovery_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: refresh_tokens_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);


--
-- Name: refresh_tokens_instance_id_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);


--
-- Name: refresh_tokens_parent_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent);


--
-- Name: refresh_tokens_session_id_revoked_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked);


--
-- Name: refresh_tokens_updated_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);


--
-- Name: saml_providers_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);


--
-- Name: saml_relay_states_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);


--
-- Name: saml_relay_states_for_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email);


--
-- Name: saml_relay_states_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id);


--
-- Name: sessions_not_after_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC);


--
-- Name: sessions_oauth_client_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_oauth_client_id_idx ON auth.sessions USING btree (oauth_client_id);


--
-- Name: sessions_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id);


--
-- Name: sso_domains_domain_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));


--
-- Name: sso_domains_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id);


--
-- Name: sso_providers_resource_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id));


--
-- Name: sso_providers_resource_id_pattern_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_providers_resource_id_pattern_idx ON auth.sso_providers USING btree (resource_id text_pattern_ops);


--
-- Name: unique_phone_factor_per_user; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone);


--
-- Name: user_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at);


--
-- Name: users_email_partial_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false);


--
-- Name: INDEX users_email_partial_key; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.users_email_partial_key IS 'Auth: A partial unique index that applies only when is_sso_user is false';


--
-- Name: users_instance_id_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text));


--
-- Name: users_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);


--
-- Name: users_is_anonymous_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);


--
-- Name: idx_cotacoes_fornecedor; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_cotacoes_fornecedor ON compras.cotacoes USING btree (fornecedor_id);


--
-- Name: idx_cotacoes_requisicao; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_cotacoes_requisicao ON compras.cotacoes USING btree (requisicao_id);


--
-- Name: idx_cotacoes_status; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_cotacoes_status ON compras.cotacoes USING btree (status);


--
-- Name: idx_fornecedores_company; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_fornecedores_company ON compras.fornecedores_dados USING btree (company_id);


--
-- Name: idx_fornecedores_partner; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_fornecedores_partner ON compras.fornecedores_dados USING btree (partner_id);


--
-- Name: idx_fornecedores_uf; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_fornecedores_uf ON compras.fornecedores_dados USING btree (uf);


--
-- Name: idx_historico_compras_fornecedor; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_historico_compras_fornecedor ON compras.historico_compras USING btree (fornecedor_id, data_compra);


--
-- Name: idx_historico_compras_material; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_historico_compras_material ON compras.historico_compras USING btree (material_id, data_compra);


--
-- Name: idx_historico_precos_material; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_historico_precos_material ON compras.historico_precos USING btree (material_id, data_cotacao);


--
-- Name: idx_pedidos_company_status; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_pedidos_company_status ON compras.pedidos_compra USING btree (company_id, status);


--
-- Name: idx_pedidos_data; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_pedidos_data ON compras.pedidos_compra USING btree (data_pedido);


--
-- Name: idx_pedidos_fornecedor; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_pedidos_fornecedor ON compras.pedidos_compra USING btree (fornecedor_id);


--
-- Name: idx_requisicoes_company_status; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_requisicoes_company_status ON compras.requisicoes_compra USING btree (company_id, status);


--
-- Name: idx_requisicoes_data; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_requisicoes_data ON compras.requisicoes_compra USING btree (data_solicitacao);


--
-- Name: idx_requisicoes_solicitante; Type: INDEX; Schema: compras; Owner: postgres
--

CREATE INDEX idx_requisicoes_solicitante ON compras.requisicoes_compra USING btree (solicitante_id);


--
-- Name: idx_aprovacoes_aprovador; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_aprovacoes_aprovador ON financeiro.aprovacoes USING btree (aprovador_id);


--
-- Name: idx_aprovacoes_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_aprovacoes_company_id ON financeiro.aprovacoes USING btree (company_id);


--
-- Name: idx_aprovacoes_entidade; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_aprovacoes_entidade ON financeiro.aprovacoes USING btree (entidade_tipo, entidade_id);


--
-- Name: idx_configuracao_bancaria_ambiente; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_bancaria_ambiente ON financeiro.configuracao_bancaria USING btree (ambiente);


--
-- Name: idx_configuracao_bancaria_banco; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_bancaria_banco ON financeiro.configuracao_bancaria USING btree (banco_codigo);


--
-- Name: idx_configuracao_bancaria_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_bancaria_company_id ON financeiro.configuracao_bancaria USING btree (company_id);


--
-- Name: idx_configuracao_fiscal_ambiente; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_fiscal_ambiente ON financeiro.configuracao_fiscal USING btree (ambiente);


--
-- Name: idx_configuracao_fiscal_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_fiscal_company_id ON financeiro.configuracao_fiscal USING btree (company_id);


--
-- Name: idx_configuracao_fiscal_tipo; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_fiscal_tipo ON financeiro.configuracao_fiscal USING btree (tipo_documento);


--
-- Name: idx_configuracao_fiscal_uf; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_configuracao_fiscal_uf ON financeiro.configuracao_fiscal USING btree (uf);


--
-- Name: idx_contas_bancarias_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_bancarias_company_id ON financeiro.contas_bancarias USING btree (company_id);


--
-- Name: idx_contas_pagar_centro_custo; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_pagar_centro_custo ON financeiro.contas_pagar USING btree (centro_custo_id);


--
-- Name: idx_contas_pagar_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_pagar_company_id ON financeiro.contas_pagar USING btree (company_id);


--
-- Name: idx_contas_pagar_fornecedor; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_pagar_fornecedor ON financeiro.contas_pagar USING btree (fornecedor_id);


--
-- Name: idx_contas_pagar_status; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_pagar_status ON financeiro.contas_pagar USING btree (status);


--
-- Name: idx_contas_pagar_vencimento; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_pagar_vencimento ON financeiro.contas_pagar USING btree (data_vencimento);


--
-- Name: idx_contas_receber_centro_custo; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_receber_centro_custo ON financeiro.contas_receber USING btree (centro_custo_id);


--
-- Name: idx_contas_receber_cliente; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_receber_cliente ON financeiro.contas_receber USING btree (cliente_id);


--
-- Name: idx_contas_receber_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_receber_company_id ON financeiro.contas_receber USING btree (company_id);


--
-- Name: idx_contas_receber_status; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_receber_status ON financeiro.contas_receber USING btree (status);


--
-- Name: idx_contas_receber_vencimento; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_contas_receber_vencimento ON financeiro.contas_receber USING btree (data_vencimento);


--
-- Name: idx_fluxo_caixa_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_fluxo_caixa_company_id ON financeiro.fluxo_caixa USING btree (company_id);


--
-- Name: idx_fluxo_caixa_data; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_fluxo_caixa_data ON financeiro.fluxo_caixa USING btree (data_projecao);


--
-- Name: idx_lancamentos_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_lancamentos_company_id ON financeiro.lancamentos_contabeis USING btree (company_id);


--
-- Name: idx_lancamentos_data; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_lancamentos_data ON financeiro.lancamentos_contabeis USING btree (data_lancamento);


--
-- Name: idx_log_validacao_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_log_validacao_company_id ON financeiro.log_validacao_integracao USING btree (company_id);


--
-- Name: idx_log_validacao_created_at; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_log_validacao_created_at ON financeiro.log_validacao_integracao USING btree (created_at);


--
-- Name: idx_log_validacao_status; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_log_validacao_status ON financeiro.log_validacao_integracao USING btree (status);


--
-- Name: idx_log_validacao_tipo; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_log_validacao_tipo ON financeiro.log_validacao_integracao USING btree (tipo_integracao);


--
-- Name: idx_nfe_chave; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_nfe_chave ON financeiro.nfe USING btree (chave_acesso);


--
-- Name: idx_nfe_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_nfe_company_id ON financeiro.nfe USING btree (company_id);


--
-- Name: idx_nfse_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_nfse_company_id ON financeiro.nfse USING btree (company_id);


--
-- Name: idx_plano_contas_company_id; Type: INDEX; Schema: financeiro; Owner: postgres
--

CREATE INDEX idx_plano_contas_company_id ON financeiro.plano_contas USING btree (company_id);


--
-- Name: idx_aprov_unif_aprovador; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_aprov_unif_aprovador ON public.aprovacoes_unificada USING btree (aprovador_id);


--
-- Name: idx_aprov_unif_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_aprov_unif_company_id ON public.aprovacoes_unificada USING btree (company_id);


--
-- Name: idx_aprov_unif_nivel; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_aprov_unif_nivel ON public.aprovacoes_unificada USING btree (nivel_aprovacao);


--
-- Name: idx_aprov_unif_processo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_aprov_unif_processo ON public.aprovacoes_unificada USING btree (processo_tipo, processo_id);


--
-- Name: idx_aprov_unif_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_aprov_unif_status ON public.aprovacoes_unificada USING btree (status);


--
-- Name: idx_companies_ativo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_companies_ativo ON public.companies USING btree (ativo);


--
-- Name: idx_companies_cnpj; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_companies_cnpj ON public.companies USING btree (cnpj);


--
-- Name: idx_config_aprov_unif_ativo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_config_aprov_unif_ativo ON public.configuracoes_aprovacao_unificada USING btree (ativo);


--
-- Name: idx_config_aprov_unif_centro_custo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_config_aprov_unif_centro_custo ON public.configuracoes_aprovacao_unificada USING btree (centro_custo_id);


--
-- Name: idx_config_aprov_unif_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_config_aprov_unif_company_id ON public.configuracoes_aprovacao_unificada USING btree (company_id);


--
-- Name: idx_config_aprov_unif_processo_tipo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_config_aprov_unif_processo_tipo ON public.configuracoes_aprovacao_unificada USING btree (processo_tipo);


--
-- Name: idx_cost_centers_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_cost_centers_company_id ON public.cost_centers USING btree (company_id);


--
-- Name: idx_entity_permissions_entity_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_entity_permissions_entity_name ON public.entity_permissions USING btree (entity_name);


--
-- Name: idx_entity_permissions_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_entity_permissions_profile_id ON public.entity_permissions USING btree (profile_id);


--
-- Name: idx_hist_edicoes_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_hist_edicoes_company_id ON public.historico_edicoes_solicitacoes USING btree (company_id);


--
-- Name: idx_hist_edicoes_data; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_hist_edicoes_data ON public.historico_edicoes_solicitacoes USING btree (data_edicao);


--
-- Name: idx_hist_edicoes_editor; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_hist_edicoes_editor ON public.historico_edicoes_solicitacoes USING btree (usuario_editor_id);


--
-- Name: idx_hist_edicoes_processo; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_hist_edicoes_processo ON public.historico_edicoes_solicitacoes USING btree (processo_tipo, processo_id);


--
-- Name: idx_module_permissions_module_name; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_module_permissions_module_name ON public.module_permissions USING btree (module_name);


--
-- Name: idx_module_permissions_profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_module_permissions_profile_id ON public.module_permissions USING btree (profile_id);


--
-- Name: idx_notifications_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_company_id ON public.notifications USING btree (company_id);


--
-- Name: idx_notifications_created_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_created_at ON public.notifications USING btree (created_at);


--
-- Name: idx_notifications_is_read; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_is_read ON public.notifications USING btree (is_read);


--
-- Name: idx_notifications_type; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_type ON public.notifications USING btree (type);


--
-- Name: idx_notifications_user_company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_user_company ON public.notifications USING btree (user_id, company_id);


--
-- Name: idx_notifications_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_notifications_user_id ON public.notifications USING btree (user_id);


--
-- Name: idx_partners_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_partners_company_id ON public.partners USING btree (company_id);


--
-- Name: idx_projects_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_projects_company_id ON public.projects USING btree (company_id);


--
-- Name: idx_user_companies_company_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_companies_company_id ON public.user_companies USING btree (company_id);


--
-- Name: idx_user_companies_user_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_companies_user_id ON public.user_companies USING btree (user_id);


--
-- Name: ix_realtime_subscription_entity; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity);


--
-- Name: messages_inserted_at_topic_index; Type: INDEX; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE INDEX messages_inserted_at_topic_index ON ONLY realtime.messages USING btree (inserted_at DESC, topic) WHERE ((extension = 'broadcast'::text) AND (private IS TRUE));


--
-- Name: subscription_subscription_id_entity_filters_key; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_key ON realtime.subscription USING btree (subscription_id, entity, filters);


--
-- Name: idx_absence_types_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_absence_types_ativo ON rh.absence_types USING btree (ativo);


--
-- Name: idx_absence_types_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_absence_types_codigo ON rh.absence_types USING btree (codigo);


--
-- Name: idx_absence_types_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_absence_types_company_id ON rh.absence_types USING btree (company_id);


--
-- Name: idx_absence_types_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_absence_types_tipo ON rh.absence_types USING btree (tipo);


--
-- Name: idx_allowance_types_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_allowance_types_ativo ON rh.allowance_types USING btree (ativo);


--
-- Name: idx_allowance_types_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_allowance_types_codigo ON rh.allowance_types USING btree (codigo);


--
-- Name: idx_allowance_types_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_allowance_types_company_id ON rh.allowance_types USING btree (company_id);


--
-- Name: idx_allowance_types_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_allowance_types_tipo ON rh.allowance_types USING btree (tipo);


--
-- Name: idx_approval_level_approvers_level_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_approval_level_approvers_level_id ON rh.approval_level_approvers USING btree (approval_level_id);


--
-- Name: idx_approval_level_approvers_user_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_approval_level_approvers_user_id ON rh.approval_level_approvers USING btree (user_id);


--
-- Name: idx_approval_levels_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_approval_levels_company_id ON rh.approval_levels USING btree (company_id);


--
-- Name: idx_approval_levels_order; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_approval_levels_order ON rh.approval_levels USING btree (company_id, level_order);


--
-- Name: idx_audit_logs_action; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_action ON rh.audit_logs USING btree (action);


--
-- Name: idx_audit_logs_company_entity; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_company_entity ON rh.audit_logs USING btree (company_id, entity_type);


--
-- Name: idx_audit_logs_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_company_id ON rh.audit_logs USING btree (company_id);


--
-- Name: idx_audit_logs_created_at; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_created_at ON rh.audit_logs USING btree (created_at);


--
-- Name: idx_audit_logs_entity; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_entity ON rh.audit_logs USING btree (entity_type, entity_id);


--
-- Name: idx_audit_logs_user_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_audit_logs_user_id ON rh.audit_logs USING btree (user_id);


--
-- Name: idx_bank_hours_balance_calculation_date; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_balance_calculation_date ON rh.bank_hours_balance USING btree (last_calculation_date);


--
-- Name: idx_bank_hours_balance_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_balance_company ON rh.bank_hours_balance USING btree (company_id);


--
-- Name: idx_bank_hours_balance_employee; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_balance_employee ON rh.bank_hours_balance USING btree (employee_id);


--
-- Name: idx_bank_hours_calculations_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_calculations_company ON rh.bank_hours_calculations USING btree (company_id);


--
-- Name: idx_bank_hours_calculations_date; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_calculations_date ON rh.bank_hours_calculations USING btree (calculation_date);


--
-- Name: idx_bank_hours_calculations_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_calculations_status ON rh.bank_hours_calculations USING btree (status);


--
-- Name: idx_bank_hours_config_active; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_config_active ON rh.bank_hours_config USING btree (is_active) WHERE (is_active = true);


--
-- Name: idx_bank_hours_config_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_config_company ON rh.bank_hours_config USING btree (company_id);


--
-- Name: idx_bank_hours_config_employee; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_config_employee ON rh.bank_hours_config USING btree (employee_id);


--
-- Name: idx_bank_hours_transactions_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_transactions_company ON rh.bank_hours_transactions USING btree (company_id);


--
-- Name: idx_bank_hours_transactions_date; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_transactions_date ON rh.bank_hours_transactions USING btree (transaction_date);


--
-- Name: idx_bank_hours_transactions_employee; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_transactions_employee ON rh.bank_hours_transactions USING btree (employee_id);


--
-- Name: idx_bank_hours_transactions_time_record; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_transactions_time_record ON rh.bank_hours_transactions USING btree (time_record_id);


--
-- Name: idx_bank_hours_transactions_type; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_bank_hours_transactions_type ON rh.bank_hours_transactions USING btree (transaction_type);


--
-- Name: idx_benefit_configurations_entra_no_calculo_folha; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_benefit_configurations_entra_no_calculo_folha ON rh.benefit_configurations USING btree (entra_no_calculo_folha);


--
-- Name: idx_benefit_processing_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_benefit_processing_company_id ON rh.monthly_benefit_processing USING btree (company_id);


--
-- Name: idx_benefit_processing_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_benefit_processing_employee_id ON rh.monthly_benefit_processing USING btree (employee_id);


--
-- Name: idx_benefit_processing_reference; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_benefit_processing_reference ON rh.monthly_benefit_processing USING btree (month_reference, year_reference);


--
-- Name: idx_calculation_logs_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_company_id ON rh.calculation_logs USING btree (company_id);


--
-- Name: idx_calculation_logs_created_at; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_created_at ON rh.calculation_logs USING btree (created_at);


--
-- Name: idx_calculation_logs_periodo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_periodo ON rh.calculation_logs USING btree (ano_referencia, mes_referencia);


--
-- Name: idx_calculation_logs_processo_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_processo_id ON rh.calculation_logs USING btree (processo_id);


--
-- Name: idx_calculation_logs_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_status ON rh.calculation_logs USING btree (status);


--
-- Name: idx_calculation_logs_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_calculation_logs_tipo ON rh.calculation_logs USING btree (tipo_processo);


--
-- Name: idx_cid_codes_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_cid_codes_ativo ON rh.cid_codes USING btree (ativo);


--
-- Name: idx_cid_codes_categoria; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_cid_codes_categoria ON rh.cid_codes USING btree (categoria);


--
-- Name: idx_cid_codes_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_cid_codes_codigo ON rh.cid_codes USING btree (codigo);


--
-- Name: idx_cid_codes_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_cid_codes_company_id ON rh.cid_codes USING btree (company_id);


--
-- Name: idx_cid_codes_descricao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_cid_codes_descricao ON rh.cid_codes USING gin (to_tsvector('portuguese'::regconfig, (descricao)::text));


--
-- Name: idx_collective_agreements_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_collective_agreements_company_id ON rh.collective_agreements USING btree (company_id);


--
-- Name: idx_collective_agreements_data_vigencia_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_collective_agreements_data_vigencia_inicio ON rh.collective_agreements USING btree (data_vigencia_inicio);


--
-- Name: idx_collective_agreements_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_collective_agreements_status ON rh.collective_agreements USING btree (status);


--
-- Name: idx_collective_agreements_tipo_documento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_collective_agreements_tipo_documento ON rh.collective_agreements USING btree (tipo_documento);


--
-- Name: idx_collective_agreements_union_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_collective_agreements_union_id ON rh.collective_agreements USING btree (union_id);


--
-- Name: idx_compensation_approvals_approver_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_approvals_approver_id ON rh.compensation_approvals USING btree (approver_id);


--
-- Name: idx_compensation_approvals_request_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_approvals_request_id ON rh.compensation_approvals USING btree (compensation_request_id);


--
-- Name: idx_compensation_requests_aprovado_por; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_aprovado_por ON rh.compensation_requests USING btree (aprovado_por);


--
-- Name: idx_compensation_requests_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_company_id ON rh.compensation_requests USING btree (company_id);


--
-- Name: idx_compensation_requests_data_compensacao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_data_compensacao ON rh.compensation_requests USING btree (data_inicio);


--
-- Name: idx_compensation_requests_data_fim; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_data_fim ON rh.compensation_requests USING btree (data_fim);


--
-- Name: idx_compensation_requests_data_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_data_inicio ON rh.compensation_requests USING btree (data_inicio);


--
-- Name: idx_compensation_requests_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_employee_id ON rh.compensation_requests USING btree (employee_id);


--
-- Name: idx_compensation_requests_funcionario_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_funcionario_id ON rh.compensation_requests USING btree (employee_id);


--
-- Name: idx_compensation_requests_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_compensation_requests_status ON rh.compensation_requests USING btree (status);


--
-- Name: idx_correction_history_changed_at; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_correction_history_changed_at ON rh.correction_history USING btree (changed_at);


--
-- Name: idx_correction_history_correction_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_correction_history_correction_id ON rh.correction_history USING btree (correction_id);


--
-- Name: idx_correction_settings_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_correction_settings_company_id ON rh.correction_settings USING btree (company_id);


--
-- Name: idx_deficiency_types_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_deficiency_types_ativo ON rh.deficiency_types USING btree (ativo);


--
-- Name: idx_deficiency_types_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_deficiency_types_codigo ON rh.deficiency_types USING btree (codigo);


--
-- Name: idx_deficiency_types_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_deficiency_types_company_id ON rh.deficiency_types USING btree (company_id);


--
-- Name: idx_deficiency_types_grau; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_deficiency_types_grau ON rh.deficiency_types USING btree (grau);


--
-- Name: idx_deficiency_types_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_deficiency_types_tipo ON rh.deficiency_types USING btree (tipo);


--
-- Name: idx_delay_reasons_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_delay_reasons_ativo ON rh.delay_reasons USING btree (ativo);


--
-- Name: idx_delay_reasons_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_delay_reasons_codigo ON rh.delay_reasons USING btree (codigo);


--
-- Name: idx_delay_reasons_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_delay_reasons_company_id ON rh.delay_reasons USING btree (company_id);


--
-- Name: idx_delay_reasons_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_delay_reasons_tipo ON rh.delay_reasons USING btree (tipo);


--
-- Name: idx_dependents_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_company_id ON rh.dependents USING btree (company_id);


--
-- Name: idx_dependents_cpf; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_cpf ON rh.dependents USING btree (cpf);


--
-- Name: idx_dependents_data_nascimento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_data_nascimento ON rh.dependents USING btree (data_nascimento);


--
-- Name: idx_dependents_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_employee_id ON rh.dependents USING btree (employee_id);


--
-- Name: idx_dependents_parentesco; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_parentesco ON rh.dependents USING btree (parentesco);


--
-- Name: idx_dependents_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_dependents_status ON rh.dependents USING btree (status);


--
-- Name: idx_disciplinary_actions_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_company_id ON rh.disciplinary_actions USING btree (company_id);


--
-- Name: idx_disciplinary_actions_data_aplicacao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_data_aplicacao ON rh.disciplinary_actions USING btree (data_aplicacao);


--
-- Name: idx_disciplinary_actions_data_ocorrencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_data_ocorrencia ON rh.disciplinary_actions USING btree (data_ocorrencia);


--
-- Name: idx_disciplinary_actions_duration_days; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_duration_days ON rh.disciplinary_actions USING btree (duration_days);


--
-- Name: idx_disciplinary_actions_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_employee_id ON rh.disciplinary_actions USING btree (employee_id);


--
-- Name: idx_disciplinary_actions_end_date; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_end_date ON rh.disciplinary_actions USING btree (end_date);


--
-- Name: idx_disciplinary_actions_gravidade; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_gravidade ON rh.disciplinary_actions USING btree (gravidade);


--
-- Name: idx_disciplinary_actions_is_active; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_is_active ON rh.disciplinary_actions USING btree (is_active);


--
-- Name: idx_disciplinary_actions_start_date; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_start_date ON rh.disciplinary_actions USING btree (start_date);


--
-- Name: idx_disciplinary_actions_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_status ON rh.disciplinary_actions USING btree (status);


--
-- Name: idx_disciplinary_actions_tipo_acao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_disciplinary_actions_tipo_acao ON rh.disciplinary_actions USING btree (tipo_acao);


--
-- Name: idx_employee_correction_permissions_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_correction_permissions_company_id ON rh.employee_correction_permissions USING btree (company_id);


--
-- Name: idx_employee_correction_permissions_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_correction_permissions_employee_id ON rh.employee_correction_permissions USING btree (employee_id);


--
-- Name: idx_employee_correction_permissions_liberado; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_correction_permissions_liberado ON rh.employee_correction_permissions USING btree (liberado);


--
-- Name: idx_employee_correction_permissions_mes_ano; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_correction_permissions_mes_ano ON rh.employee_correction_permissions USING btree (mes_ano);


--
-- Name: idx_employee_medical_plans_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_company_id ON rh.employee_medical_plans USING btree (company_id);


--
-- Name: idx_employee_medical_plans_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_employee_id ON rh.employee_medical_plans USING btree (employee_id);


--
-- Name: idx_employee_medical_plans_entra_no_calculo_folha; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_entra_no_calculo_folha ON rh.employee_medical_plans USING btree (entra_no_calculo_folha);


--
-- Name: idx_employee_medical_plans_plan_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_plan_id ON rh.employee_medical_plans USING btree (plan_id);


--
-- Name: idx_employee_medical_plans_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_status ON rh.employee_medical_plans USING btree (status);


--
-- Name: idx_employee_medical_plans_status_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_medical_plans_status_ativo ON rh.employee_medical_plans USING btree (status) WHERE ((status)::text = 'ativo'::text);


--
-- Name: idx_employee_plan_dependents_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_plan_dependents_company_id ON rh.employee_plan_dependents USING btree (company_id);


--
-- Name: idx_employee_plan_dependents_employee_plan_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_plan_dependents_employee_plan_id ON rh.employee_plan_dependents USING btree (employee_plan_id);


--
-- Name: idx_employee_plan_dependents_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_plan_dependents_status ON rh.employee_plan_dependents USING btree (status);


--
-- Name: idx_employee_shifts_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_shifts_ativo ON rh.employee_shifts USING btree (ativo);


--
-- Name: idx_employee_shifts_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_shifts_company_id ON rh.employee_shifts USING btree (company_id);


--
-- Name: idx_employee_shifts_data_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_shifts_data_inicio ON rh.employee_shifts USING btree (data_inicio);


--
-- Name: idx_employee_shifts_funcionario_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_shifts_funcionario_id ON rh.employee_shifts USING btree (funcionario_id);


--
-- Name: idx_employee_shifts_turno_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_shifts_turno_id ON rh.employee_shifts USING btree (turno_id);


--
-- Name: idx_employee_union_memberships_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_union_memberships_company_id ON rh.employee_union_memberships USING btree (company_id);


--
-- Name: idx_employee_union_memberships_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_union_memberships_employee_id ON rh.employee_union_memberships USING btree (employee_id);


--
-- Name: idx_employee_union_memberships_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_union_memberships_status ON rh.employee_union_memberships USING btree (status);


--
-- Name: idx_employee_union_memberships_union_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employee_union_memberships_union_id ON rh.employee_union_memberships USING btree (union_id);


--
-- Name: idx_employees_cargo_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_cargo_id ON rh.employees USING btree (cargo_id);


--
-- Name: idx_employees_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_company_id ON rh.employees USING btree (company_id);


--
-- Name: idx_employees_cpf; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_cpf ON rh.employees USING btree (cpf);


--
-- Name: idx_employees_escolaridade; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_escolaridade ON rh.employees USING btree (escolaridade);


--
-- Name: idx_employees_outros_vinculos; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_outros_vinculos ON rh.employees USING btree (outros_vinculos_empregaticios);


--
-- Name: idx_employees_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_status ON rh.employees USING btree (status);


--
-- Name: idx_employees_tipo_cnh; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_tipo_cnh ON rh.employees USING btree (tipo_cnh);


--
-- Name: idx_employees_user_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employees_user_id ON rh.employees USING btree (user_id);


--
-- Name: idx_employment_contracts_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_company_id ON rh.employment_contracts USING btree (company_id);


--
-- Name: idx_employment_contracts_data_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_data_inicio ON rh.employment_contracts USING btree (data_inicio);


--
-- Name: idx_employment_contracts_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_employee_id ON rh.employment_contracts USING btree (employee_id);


--
-- Name: idx_employment_contracts_numero; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_numero ON rh.employment_contracts USING btree (numero_contrato);


--
-- Name: idx_employment_contracts_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_status ON rh.employment_contracts USING btree (status);


--
-- Name: idx_employment_contracts_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_employment_contracts_tipo ON rh.employment_contracts USING btree (tipo_contrato);


--
-- Name: idx_esocial_batches_batch_number; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_batches_batch_number ON rh.esocial_batches USING btree (batch_number);


--
-- Name: idx_esocial_batches_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_batches_company_id ON rh.esocial_batches USING btree (company_id);


--
-- Name: idx_esocial_batches_period; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_batches_period ON rh.esocial_batches USING btree (period);


--
-- Name: idx_esocial_batches_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_batches_status ON rh.esocial_batches USING btree (status);


--
-- Name: idx_esocial_config_ambiente; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_config_ambiente ON rh.esocial_config USING btree (ambiente);


--
-- Name: idx_esocial_config_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_config_ativo ON rh.esocial_config USING btree (ativo);


--
-- Name: idx_esocial_config_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_config_company_id ON rh.esocial_config USING btree (company_id);


--
-- Name: idx_esocial_events_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_company_id ON rh.esocial_events USING btree (company_id);


--
-- Name: idx_esocial_events_data_envio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_data_envio ON rh.esocial_events USING btree (data_envio);


--
-- Name: idx_esocial_events_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_employee_id ON rh.esocial_events USING btree (employee_id);


--
-- Name: idx_esocial_events_numero_recibo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_numero_recibo ON rh.esocial_events USING btree (numero_recibo);


--
-- Name: idx_esocial_events_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_status ON rh.esocial_events USING btree (status);


--
-- Name: idx_esocial_events_tipo_evento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_events_tipo_evento ON rh.esocial_events USING btree (tipo_evento);


--
-- Name: idx_esocial_integrations_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_integrations_company_id ON rh.esocial_integrations USING btree (company_id);


--
-- Name: idx_esocial_integrations_funcionario_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_integrations_funcionario_id ON rh.esocial_integrations USING btree (funcionario_id);


--
-- Name: idx_esocial_integrations_protocolo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_integrations_protocolo ON rh.esocial_integrations USING btree (protocolo);


--
-- Name: idx_esocial_integrations_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_integrations_status ON rh.esocial_integrations USING btree (status);


--
-- Name: idx_esocial_integrations_tipo_evento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_integrations_tipo_evento ON rh.esocial_integrations USING btree (tipo_evento);


--
-- Name: idx_esocial_logs_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_logs_company_id ON rh.esocial_logs USING btree (company_id);


--
-- Name: idx_esocial_logs_created_at; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_logs_created_at ON rh.esocial_logs USING btree (created_at);


--
-- Name: idx_esocial_logs_event_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_logs_event_id ON rh.esocial_logs USING btree (event_id);


--
-- Name: idx_esocial_logs_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_logs_status ON rh.esocial_logs USING btree (status);


--
-- Name: idx_esocial_logs_tipo_operacao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_esocial_logs_tipo_operacao ON rh.esocial_logs USING btree (tipo_operacao);


--
-- Name: idx_event_consolidations_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_event_consolidations_company_id ON rh.event_consolidations USING btree (company_id);


--
-- Name: idx_event_consolidations_periodo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_event_consolidations_periodo ON rh.event_consolidations USING btree (periodo);


--
-- Name: idx_event_consolidations_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_event_consolidations_status ON rh.event_consolidations USING btree (status);


--
-- Name: idx_fgts_config_ano_mes; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_fgts_config_ano_mes ON rh.fgts_config USING btree (ano_vigencia, mes_vigencia);


--
-- Name: idx_fgts_config_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_fgts_config_ativo ON rh.fgts_config USING btree (ativo);


--
-- Name: idx_fgts_config_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_fgts_config_codigo ON rh.fgts_config USING btree (codigo);


--
-- Name: idx_fgts_config_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_fgts_config_company_id ON rh.fgts_config USING btree (company_id);


--
-- Name: idx_fgts_config_vigencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_fgts_config_vigencia ON rh.fgts_config USING btree (ano_vigencia, mes_vigencia, ativo);


--
-- Name: idx_holidays_ano; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_holidays_ano ON rh.holidays USING btree (EXTRACT(year FROM data));


--
-- Name: idx_holidays_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_holidays_ativo ON rh.holidays USING btree (ativo);


--
-- Name: idx_holidays_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_holidays_company_id ON rh.holidays USING btree (company_id);


--
-- Name: idx_holidays_data; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_holidays_data ON rh.holidays USING btree (data);


--
-- Name: idx_holidays_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_holidays_tipo ON rh.holidays USING btree (tipo);


--
-- Name: idx_income_statements_ano_mes; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_income_statements_ano_mes ON rh.income_statements USING btree (ano_referencia, mes_referencia);


--
-- Name: idx_income_statements_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_income_statements_company_id ON rh.income_statements USING btree (company_id);


--
-- Name: idx_income_statements_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_income_statements_employee_id ON rh.income_statements USING btree (employee_id);


--
-- Name: idx_income_statements_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_income_statements_status ON rh.income_statements USING btree (status);


--
-- Name: idx_income_statements_unique; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE UNIQUE INDEX idx_income_statements_unique ON rh.income_statements USING btree (employee_id, ano_referencia, mes_referencia);


--
-- Name: idx_inss_brackets_ano_mes; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_inss_brackets_ano_mes ON rh.inss_brackets USING btree (ano_vigencia, mes_vigencia);


--
-- Name: idx_inss_brackets_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_inss_brackets_ativo ON rh.inss_brackets USING btree (ativo);


--
-- Name: idx_inss_brackets_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_inss_brackets_codigo ON rh.inss_brackets USING btree (codigo);


--
-- Name: idx_inss_brackets_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_inss_brackets_company_id ON rh.inss_brackets USING btree (company_id);


--
-- Name: idx_inss_brackets_vigencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_inss_brackets_vigencia ON rh.inss_brackets USING btree (ano_vigencia, mes_vigencia, ativo);


--
-- Name: idx_irrf_brackets_ano_mes; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_irrf_brackets_ano_mes ON rh.irrf_brackets USING btree (ano_vigencia, mes_vigencia);


--
-- Name: idx_irrf_brackets_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_irrf_brackets_ativo ON rh.irrf_brackets USING btree (ativo);


--
-- Name: idx_irrf_brackets_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_irrf_brackets_codigo ON rh.irrf_brackets USING btree (codigo);


--
-- Name: idx_irrf_brackets_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_irrf_brackets_company_id ON rh.irrf_brackets USING btree (company_id);


--
-- Name: idx_irrf_brackets_vigencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_irrf_brackets_vigencia ON rh.irrf_brackets USING btree (ano_vigencia, mes_vigencia, ativo);


--
-- Name: idx_medical_agreements_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_agreements_ativo ON rh.medical_agreements USING btree (ativo);


--
-- Name: idx_medical_agreements_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_agreements_company_id ON rh.medical_agreements USING btree (company_id);


--
-- Name: idx_medical_agreements_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_agreements_tipo ON rh.medical_agreements USING btree (tipo);


--
-- Name: idx_medical_certificate_attachments_certificate_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificate_attachments_certificate_id ON rh.medical_certificate_attachments USING btree (certificate_id);


--
-- Name: idx_medical_certificates_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificates_company_id ON rh.medical_certificates USING btree (company_id);


--
-- Name: idx_medical_certificates_data_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificates_data_inicio ON rh.medical_certificates USING btree (data_inicio);


--
-- Name: idx_medical_certificates_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificates_employee_id ON rh.medical_certificates USING btree (employee_id);


--
-- Name: idx_medical_certificates_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificates_status ON rh.medical_certificates USING btree (status);


--
-- Name: idx_medical_certificates_tipo_atestado; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_certificates_tipo_atestado ON rh.medical_certificates USING btree (tipo_atestado);


--
-- Name: idx_medical_plan_pricing_history_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plan_pricing_history_company_id ON rh.medical_plan_pricing_history USING btree (company_id);


--
-- Name: idx_medical_plan_pricing_history_data_vigencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plan_pricing_history_data_vigencia ON rh.medical_plan_pricing_history USING btree (data_vigencia);


--
-- Name: idx_medical_plan_pricing_history_plan_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plan_pricing_history_plan_id ON rh.medical_plan_pricing_history USING btree (plan_id);


--
-- Name: idx_medical_plans_agreement_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_agreement_id ON rh.medical_plans USING btree (agreement_id);


--
-- Name: idx_medical_plans_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_ativo ON rh.medical_plans USING btree (ativo);


--
-- Name: idx_medical_plans_categoria; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_categoria ON rh.medical_plans USING btree (categoria);


--
-- Name: idx_medical_plans_categoria_desconto; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_categoria_desconto ON rh.medical_plans USING btree (categoria_desconto);


--
-- Name: idx_medical_plans_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_company_id ON rh.medical_plans USING btree (company_id);


--
-- Name: idx_medical_plans_entra_no_calculo_folha; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_entra_no_calculo_folha ON rh.medical_plans USING btree (entra_no_calculo_folha);


--
-- Name: idx_medical_plans_tipo_folha; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_medical_plans_tipo_folha ON rh.medical_plans USING btree (tipo_folha);


--
-- Name: idx_payroll_beneficios_convenios_medicos; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_beneficios_convenios_medicos ON rh.payroll USING btree (total_beneficios_convenios_medicos);


--
-- Name: idx_payroll_beneficios_tradicionais; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_beneficios_tradicionais ON rh.payroll USING btree (total_beneficios_tradicionais);


--
-- Name: idx_payroll_config_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_config_ativo ON rh.payroll_config USING btree (ativo);


--
-- Name: idx_payroll_config_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_config_company_id ON rh.payroll_config USING btree (company_id);


--
-- Name: idx_payroll_config_periodo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_config_periodo ON rh.payroll_config USING btree (ano_vigencia, mes_vigencia);


--
-- Name: idx_payroll_descontos_convenios_medicos; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_descontos_convenios_medicos ON rh.payroll USING btree (total_descontos_convenios_medicos);


--
-- Name: idx_payroll_events_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_company_id ON rh.payroll_events USING btree (company_id);


--
-- Name: idx_payroll_events_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_employee_id ON rh.payroll_events USING btree (employee_id);


--
-- Name: idx_payroll_events_payroll_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_payroll_id ON rh.payroll_events USING btree (payroll_id);


--
-- Name: idx_payroll_events_periodo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_periodo ON rh.payroll_events USING btree (ano_referencia, mes_referencia);


--
-- Name: idx_payroll_events_rubrica; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_rubrica ON rh.payroll_events USING btree (rubrica_id);


--
-- Name: idx_payroll_events_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_payroll_events_tipo ON rh.payroll_events USING btree (tipo_rubrica);


--
-- Name: idx_periodic_exams_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_company_id ON rh.periodic_exams USING btree (company_id);


--
-- Name: idx_periodic_exams_data_agendamento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_data_agendamento ON rh.periodic_exams USING btree (data_agendamento);


--
-- Name: idx_periodic_exams_data_vencimento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_data_vencimento ON rh.periodic_exams USING btree (data_vencimento);


--
-- Name: idx_periodic_exams_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_employee_id ON rh.periodic_exams USING btree (employee_id);


--
-- Name: idx_periodic_exams_resultado; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_resultado ON rh.periodic_exams USING btree (resultado);


--
-- Name: idx_periodic_exams_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_status ON rh.periodic_exams USING btree (status);


--
-- Name: idx_periodic_exams_tipo_exame; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_periodic_exams_tipo_exame ON rh.periodic_exams USING btree (tipo_exame);


--
-- Name: idx_reports_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_reports_company_id ON rh.reports USING btree (company_id);


--
-- Name: idx_reports_data_geracao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_reports_data_geracao ON rh.reports USING btree (data_geracao);


--
-- Name: idx_reports_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_reports_status ON rh.reports USING btree (status);


--
-- Name: idx_reports_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_reports_tipo ON rh.reports USING btree (tipo);


--
-- Name: idx_rubricas_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_ativo ON rh.rubricas USING btree (ativo);


--
-- Name: idx_rubricas_categoria; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_categoria ON rh.rubricas USING btree (categoria);


--
-- Name: idx_rubricas_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_codigo ON rh.rubricas USING btree (codigo);


--
-- Name: idx_rubricas_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_company_id ON rh.rubricas USING btree (company_id);


--
-- Name: idx_rubricas_ordem; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_ordem ON rh.rubricas USING btree (ordem_exibicao);


--
-- Name: idx_rubricas_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_rubricas_tipo ON rh.rubricas USING btree (tipo);


--
-- Name: idx_schedule_planning_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_schedule_planning_company_id ON rh.schedule_planning USING btree (company_id);


--
-- Name: idx_schedule_planning_periodo_fim; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_schedule_planning_periodo_fim ON rh.schedule_planning USING btree (periodo_fim);


--
-- Name: idx_schedule_planning_periodo_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_schedule_planning_periodo_inicio ON rh.schedule_planning USING btree (periodo_inicio);


--
-- Name: idx_schedule_planning_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_schedule_planning_status ON rh.schedule_planning USING btree (status);


--
-- Name: idx_signature_notifications_employee; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_signature_notifications_employee ON rh.signature_notifications USING btree (employee_id);


--
-- Name: idx_signature_notifications_signature; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_signature_notifications_signature ON rh.signature_notifications USING btree (signature_id);


--
-- Name: idx_time_bank_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_bank_company_id ON rh.time_bank USING btree (company_id);


--
-- Name: idx_time_bank_data_registro; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_bank_data_registro ON rh.time_bank USING btree (data_registro);


--
-- Name: idx_time_bank_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_bank_employee_id ON rh.time_bank USING btree (employee_id);


--
-- Name: idx_time_bank_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_bank_status ON rh.time_bank USING btree (status);


--
-- Name: idx_time_bank_tipo_hora; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_bank_tipo_hora ON rh.time_bank USING btree (tipo_hora);


--
-- Name: idx_time_record_signature_config_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signature_config_company ON rh.time_record_signature_config USING btree (company_id);


--
-- Name: idx_time_record_signatures_company; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signatures_company ON rh.time_record_signatures USING btree (company_id);


--
-- Name: idx_time_record_signatures_employee; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signatures_employee ON rh.time_record_signatures USING btree (employee_id);


--
-- Name: idx_time_record_signatures_expires_at; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signatures_expires_at ON rh.time_record_signatures USING btree (expires_at);


--
-- Name: idx_time_record_signatures_month_year; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signatures_month_year ON rh.time_record_signatures USING btree (month_year);


--
-- Name: idx_time_record_signatures_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_record_signatures_status ON rh.time_record_signatures USING btree (status);


--
-- Name: idx_time_records_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_records_company_id ON rh.time_records USING btree (company_id);


--
-- Name: idx_time_records_data_registro; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_records_data_registro ON rh.time_records USING btree (data_registro);


--
-- Name: idx_time_records_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_records_employee_id ON rh.time_records USING btree (employee_id);


--
-- Name: idx_time_records_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_time_records_status ON rh.time_records USING btree (status);


--
-- Name: idx_training_notification_history_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_notification_history_employee_id ON rh.training_notification_history USING btree (employee_id);


--
-- Name: idx_training_notification_history_training_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_notification_history_training_id ON rh.training_notification_history USING btree (training_id);


--
-- Name: idx_training_notification_queue_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_notification_queue_company_id ON rh.training_notification_queue USING btree (company_id);


--
-- Name: idx_training_notification_queue_data_agendamento; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_notification_queue_data_agendamento ON rh.training_notification_queue USING btree (data_agendamento);


--
-- Name: idx_training_notification_queue_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_notification_queue_status ON rh.training_notification_queue USING btree (status);


--
-- Name: idx_training_settings_active; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_settings_active ON rh.training_settings USING btree (is_active);


--
-- Name: idx_training_settings_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_training_settings_company_id ON rh.training_settings USING btree (company_id);


--
-- Name: idx_training_settings_company_unique; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE UNIQUE INDEX idx_training_settings_company_unique ON rh.training_settings USING btree (company_id) WHERE (is_active = true);


--
-- Name: idx_trainings_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_trainings_company_id ON rh.trainings USING btree (company_id);


--
-- Name: idx_trainings_data_fim; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_trainings_data_fim ON rh.trainings USING btree (data_fim);


--
-- Name: idx_trainings_data_inicio; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_trainings_data_inicio ON rh.trainings USING btree (data_inicio);


--
-- Name: idx_trainings_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_trainings_status ON rh.trainings USING btree (status);


--
-- Name: idx_trainings_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_trainings_tipo ON rh.trainings USING btree (tipo_treinamento);


--
-- Name: idx_union_contributions_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_contributions_company_id ON rh.union_contributions USING btree (company_id);


--
-- Name: idx_union_contributions_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_contributions_employee_id ON rh.union_contributions USING btree (employee_id);


--
-- Name: idx_union_contributions_mes_referencia; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_contributions_mes_referencia ON rh.union_contributions USING btree (mes_referencia);


--
-- Name: idx_union_contributions_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_contributions_status ON rh.union_contributions USING btree (status);


--
-- Name: idx_union_contributions_union_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_contributions_union_id ON rh.union_contributions USING btree (union_id);


--
-- Name: idx_union_negotiations_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_negotiations_company_id ON rh.union_negotiations USING btree (company_id);


--
-- Name: idx_union_negotiations_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_negotiations_status ON rh.union_negotiations USING btree (status);


--
-- Name: idx_union_negotiations_tipo_negociacao; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_negotiations_tipo_negociacao ON rh.union_negotiations USING btree (tipo_negociacao);


--
-- Name: idx_union_negotiations_union_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_negotiations_union_id ON rh.union_negotiations USING btree (union_id);


--
-- Name: idx_union_representatives_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_representatives_company_id ON rh.union_representatives USING btree (company_id);


--
-- Name: idx_union_representatives_employee_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_representatives_employee_id ON rh.union_representatives USING btree (employee_id);


--
-- Name: idx_union_representatives_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_representatives_status ON rh.union_representatives USING btree (status);


--
-- Name: idx_union_representatives_union_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_union_representatives_union_id ON rh.union_representatives USING btree (union_id);


--
-- Name: idx_unions_ativo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_unions_ativo ON rh.unions USING btree (ativo);


--
-- Name: idx_unions_categoria; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_unions_categoria ON rh.unions USING btree (categoria);


--
-- Name: idx_unions_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_unions_company_id ON rh.unions USING btree (company_id);


--
-- Name: idx_unions_tipo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_unions_tipo ON rh.unions USING btree (tipo);


--
-- Name: idx_units_cost_center_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_units_cost_center_id ON rh.units USING btree (cost_center_id);


--
-- Name: idx_work_shifts_codigo; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_work_shifts_codigo ON rh.work_shifts USING btree (codigo);


--
-- Name: idx_work_shifts_company_id; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_work_shifts_company_id ON rh.work_shifts USING btree (company_id);


--
-- Name: idx_work_shifts_status; Type: INDEX; Schema: rh; Owner: postgres
--

CREATE INDEX idx_work_shifts_status ON rh.work_shifts USING btree (status);


--
-- Name: bname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);


--
-- Name: bucketid_objname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name);


--
-- Name: idx_multipart_uploads_list; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);


--
-- Name: idx_name_bucket_level_unique; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX idx_name_bucket_level_unique ON storage.objects USING btree (name COLLATE "C", bucket_id, level);


--
-- Name: idx_objects_bucket_id_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C");


--
-- Name: idx_objects_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_lower_name ON storage.objects USING btree ((path_tokens[level]), lower(name) text_pattern_ops, bucket_id, level);


--
-- Name: idx_prefixes_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_prefixes_lower_name ON storage.prefixes USING btree (bucket_id, level, ((string_to_array(name, '/'::text))[level]), lower(name) text_pattern_ops);


--
-- Name: name_prefix_search; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops);


--
-- Name: objects_bucket_id_level_idx; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX objects_bucket_id_level_idx ON storage.objects USING btree (bucket_id, level, name COLLATE "C");


--
-- Name: almoxarifados audit_almoxarifados_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_almoxarifados_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.almoxarifados FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: entradas_materiais audit_entradas_materiais_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_entradas_materiais_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.entradas_materiais FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: inventarios audit_inventarios_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_inventarios_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.inventarios FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: materiais_equipamentos audit_materiais_equipamentos_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_materiais_equipamentos_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.materiais_equipamentos FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: movimentacoes_estoque audit_movimentacoes_estoque_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_movimentacoes_estoque_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.movimentacoes_estoque FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: transferencias audit_transferencias_trigger; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER audit_transferencias_trigger AFTER INSERT OR DELETE OR UPDATE ON almoxarifado.transferencias FOR EACH ROW EXECUTE FUNCTION almoxarifado.audit_trigger_function();


--
-- Name: solicitacoes_saida_materiais trigger_check_edit_permission_saidas_materiais; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_check_edit_permission_saidas_materiais BEFORE UPDATE ON almoxarifado.solicitacoes_saida_materiais FOR EACH ROW EXECUTE FUNCTION public.check_edit_permission();


--
-- Name: transferencias trigger_check_edit_permission_transferencias; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_check_edit_permission_transferencias BEFORE UPDATE ON almoxarifado.transferencias FOR EACH ROW EXECUTE FUNCTION public.check_edit_permission();


--
-- Name: solicitacoes_saida_materiais trigger_create_approvals_saidas_materiais; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_create_approvals_saidas_materiais AFTER INSERT ON almoxarifado.solicitacoes_saida_materiais FOR EACH ROW EXECUTE FUNCTION public.create_approvals_on_insert();


--
-- Name: transferencias trigger_create_approvals_transferencias; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_create_approvals_transferencias AFTER INSERT ON almoxarifado.transferencias FOR EACH ROW EXECUTE FUNCTION public.create_approvals_on_insert();


--
-- Name: solicitacoes_saida_materiais trigger_reset_approvals_saidas_materiais; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_reset_approvals_saidas_materiais AFTER UPDATE ON almoxarifado.solicitacoes_saida_materiais FOR EACH ROW EXECUTE FUNCTION public.record_edit_and_reset_approvals();


--
-- Name: transferencias trigger_reset_approvals_transferencias; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_reset_approvals_transferencias AFTER UPDATE ON almoxarifado.transferencias FOR EACH ROW EXECUTE FUNCTION public.record_edit_and_reset_approvals();


--
-- Name: estoque_atual trigger_verificar_estoque_minimo; Type: TRIGGER; Schema: almoxarifado; Owner: postgres
--

CREATE TRIGGER trigger_verificar_estoque_minimo AFTER INSERT OR UPDATE ON almoxarifado.estoque_atual FOR EACH ROW EXECUTE FUNCTION compras.verificar_estoque_minimo();


--
-- Name: users on_auth_user_created; Type: TRIGGER; Schema: auth; Owner: supabase_auth_admin
--

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


--
-- Name: requisicao_itens trigger_atualizar_valor_requisicao; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_atualizar_valor_requisicao AFTER INSERT OR DELETE OR UPDATE ON compras.requisicao_itens FOR EACH ROW EXECUTE FUNCTION compras.atualizar_valor_requisicao();


--
-- Name: cotacoes trigger_check_edit_permission_cotacoes; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_check_edit_permission_cotacoes BEFORE UPDATE ON compras.cotacoes FOR EACH ROW EXECUTE FUNCTION public.check_edit_permission();


--
-- Name: requisicoes_compra trigger_check_edit_permission_requisicoes_compra; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_check_edit_permission_requisicoes_compra BEFORE UPDATE ON compras.requisicoes_compra FOR EACH ROW EXECUTE FUNCTION public.check_edit_permission();


--
-- Name: cotacoes trigger_create_approvals_cotacoes; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_create_approvals_cotacoes AFTER INSERT ON compras.cotacoes FOR EACH ROW EXECUTE FUNCTION public.create_approvals_on_insert();


--
-- Name: requisicoes_compra trigger_create_approvals_requisicoes_compra; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_create_approvals_requisicoes_compra AFTER INSERT ON compras.requisicoes_compra FOR EACH ROW EXECUTE FUNCTION public.create_approvals_on_insert();


--
-- Name: cotacoes trigger_reset_approvals_cotacoes; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_reset_approvals_cotacoes AFTER UPDATE ON compras.cotacoes FOR EACH ROW EXECUTE FUNCTION public.record_edit_and_reset_approvals();


--
-- Name: requisicoes_compra trigger_reset_approvals_requisicoes_compra; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER trigger_reset_approvals_requisicoes_compra AFTER UPDATE ON compras.requisicoes_compra FOR EACH ROW EXECUTE FUNCTION public.record_edit_and_reset_approvals();


--
-- Name: cotacoes update_cotacoes_updated_at; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER update_cotacoes_updated_at BEFORE UPDATE ON compras.cotacoes FOR EACH ROW EXECUTE FUNCTION compras.update_updated_at_column();


--
-- Name: fornecedores_dados update_fornecedores_updated_at; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER update_fornecedores_updated_at BEFORE UPDATE ON compras.fornecedores_dados FOR EACH ROW EXECUTE FUNCTION compras.update_updated_at_column();


--
-- Name: pedidos_compra update_pedidos_updated_at; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER update_pedidos_updated_at BEFORE UPDATE ON compras.pedidos_compra FOR EACH ROW EXECUTE FUNCTION compras.update_updated_at_column();


--
-- Name: requisicoes_compra update_requisicoes_updated_at; Type: TRIGGER; Schema: compras; Owner: postgres
--

CREATE TRIGGER update_requisicoes_updated_at BEFORE UPDATE ON compras.requisicoes_compra FOR EACH ROW EXECUTE FUNCTION compras.update_updated_at_column();


--
-- Name: contas_pagar trigger_check_edit_permission_contas_pagar; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER trigger_check_edit_permission_contas_pagar BEFORE UPDATE ON financeiro.contas_pagar FOR EACH ROW EXECUTE FUNCTION public.check_edit_permission();


--
-- Name: contas_pagar trigger_create_approvals_contas_pagar; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER trigger_create_approvals_contas_pagar AFTER INSERT ON financeiro.contas_pagar FOR EACH ROW EXECUTE FUNCTION public.create_approvals_on_insert();


--
-- Name: contas_pagar trigger_create_contas_pagar_approvals; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER trigger_create_contas_pagar_approvals AFTER INSERT ON financeiro.contas_pagar FOR EACH ROW EXECUTE FUNCTION financeiro.create_approvals_trigger();


--
-- Name: contas_pagar trigger_reset_approvals_contas_pagar; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER trigger_reset_approvals_contas_pagar AFTER UPDATE ON financeiro.contas_pagar FOR EACH ROW EXECUTE FUNCTION public.record_edit_and_reset_approvals();


--
-- Name: aprovacoes update_aprovacoes_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_aprovacoes_updated_at BEFORE UPDATE ON financeiro.aprovacoes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: borderos update_borderos_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_borderos_updated_at BEFORE UPDATE ON financeiro.borderos FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: conciliacoes_bancarias update_conciliacoes_bancarias_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_conciliacoes_bancarias_updated_at BEFORE UPDATE ON financeiro.conciliacoes_bancarias FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: configuracao_bancaria update_configuracao_bancaria_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_configuracao_bancaria_updated_at BEFORE UPDATE ON financeiro.configuracao_bancaria FOR EACH ROW EXECUTE FUNCTION financeiro.update_updated_at_column();


--
-- Name: configuracao_fiscal update_configuracao_fiscal_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_configuracao_fiscal_updated_at BEFORE UPDATE ON financeiro.configuracao_fiscal FOR EACH ROW EXECUTE FUNCTION financeiro.update_updated_at_column();


--
-- Name: configuracoes_aprovacao update_configuracoes_aprovacao_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_configuracoes_aprovacao_updated_at BEFORE UPDATE ON financeiro.configuracoes_aprovacao FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: contas_bancarias update_contas_bancarias_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_contas_bancarias_updated_at BEFORE UPDATE ON financeiro.contas_bancarias FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: contas_pagar update_contas_pagar_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_contas_pagar_updated_at BEFORE UPDATE ON financeiro.contas_pagar FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: contas_receber update_contas_receber_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_contas_receber_updated_at BEFORE UPDATE ON financeiro.contas_receber FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: fluxo_caixa update_fluxo_caixa_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_fluxo_caixa_updated_at BEFORE UPDATE ON financeiro.fluxo_caixa FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: lancamentos_contabeis update_lancamentos_contabeis_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_lancamentos_contabeis_updated_at BEFORE UPDATE ON financeiro.lancamentos_contabeis FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: nfe update_nfe_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_nfe_updated_at BEFORE UPDATE ON financeiro.nfe FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: nfse update_nfse_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_nfse_updated_at BEFORE UPDATE ON financeiro.nfse FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: plano_contas update_plano_contas_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_plano_contas_updated_at BEFORE UPDATE ON financeiro.plano_contas FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: remessas_bancarias update_remessas_bancarias_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_remessas_bancarias_updated_at BEFORE UPDATE ON financeiro.remessas_bancarias FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: retornos_bancarios update_retornos_bancarios_updated_at; Type: TRIGGER; Schema: financeiro; Owner: postgres
--

CREATE TRIGGER update_retornos_bancarios_updated_at BEFORE UPDATE ON financeiro.retornos_bancarios FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: companies create_signature_config_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER create_signature_config_trigger AFTER INSERT ON public.companies FOR EACH ROW EXECUTE FUNCTION public.create_signature_config_for_new_company();


--
-- Name: companies generate_company_number_trigger; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER generate_company_number_trigger BEFORE INSERT ON public.companies FOR EACH ROW EXECUTE FUNCTION public.generate_company_number();


--
-- Name: companies trigger_update_companies_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_companies_updated_at BEFORE UPDATE ON public.companies FOR EACH ROW EXECUTE FUNCTION public.update_companies_updated_at();


--
-- Name: notifications trigger_update_notifications_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_update_notifications_updated_at BEFORE UPDATE ON public.notifications FOR EACH ROW EXECUTE FUNCTION public.update_notifications_updated_at();


--
-- Name: companies update_companies_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_companies_updated_at BEFORE UPDATE ON public.companies FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: cost_centers update_cost_centers_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_cost_centers_updated_at BEFORE UPDATE ON public.cost_centers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: entity_permissions update_entity_permissions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_entity_permissions_updated_at BEFORE UPDATE ON public.entity_permissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: module_permissions update_module_permissions_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_module_permissions_updated_at BEFORE UPDATE ON public.module_permissions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: partners update_partners_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_partners_updated_at BEFORE UPDATE ON public.partners FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: profiles update_profiles_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: projects update_projects_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: users update_users_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();


--
-- Name: subscription tr_check_filters; Type: TRIGGER; Schema: realtime; Owner: supabase_admin
--

CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();


--
-- Name: approval_levels trigger_audit_approval_levels; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_audit_approval_levels AFTER INSERT OR DELETE OR UPDATE ON rh.approval_levels FOR EACH ROW EXECUTE FUNCTION public.audit_approval_levels();


--
-- Name: compensation_approvals trigger_audit_compensation_approvals; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_audit_compensation_approvals AFTER INSERT OR UPDATE ON rh.compensation_approvals FOR EACH ROW EXECUTE FUNCTION public.audit_compensation_approvals();


--
-- Name: compensation_requests trigger_audit_compensation_requests; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_audit_compensation_requests AFTER INSERT OR DELETE OR UPDATE ON rh.compensation_requests FOR EACH ROW EXECUTE FUNCTION public.audit_compensation_requests();


--
-- Name: medical_certificates trigger_calculate_medical_certificate_days; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_calculate_medical_certificate_days BEFORE INSERT OR UPDATE ON rh.medical_certificates FOR EACH ROW EXECUTE FUNCTION public.calculate_medical_certificate_days();


--
-- Name: compensation_requests trigger_create_compensation_approvals; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_create_compensation_approvals AFTER INSERT ON rh.compensation_requests FOR EACH ROW EXECUTE FUNCTION public.trigger_create_compensation_approvals();


--
-- Name: trainings trigger_create_training_notification_rules; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_create_training_notification_rules AFTER INSERT ON rh.trainings FOR EACH ROW EXECUTE FUNCTION rh.trigger_create_training_notification_rules();


--
-- Name: absence_types trigger_update_absence_types_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_absence_types_updated_at BEFORE UPDATE ON rh.absence_types FOR EACH ROW EXECUTE FUNCTION public.update_absence_types_updated_at();


--
-- Name: allowance_types trigger_update_allowance_types_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_allowance_types_updated_at BEFORE UPDATE ON rh.allowance_types FOR EACH ROW EXECUTE FUNCTION public.update_allowance_types_updated_at();


--
-- Name: approval_levels trigger_update_approval_levels_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_approval_levels_updated_at BEFORE UPDATE ON rh.approval_levels FOR EACH ROW EXECUTE FUNCTION public.update_approval_levels_updated_at();


--
-- Name: audit_config trigger_update_audit_config_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_audit_config_updated_at BEFORE UPDATE ON rh.audit_config FOR EACH ROW EXECUTE FUNCTION public.update_audit_config_updated_at();


--
-- Name: cid_codes trigger_update_cid_codes_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_cid_codes_updated_at BEFORE UPDATE ON rh.cid_codes FOR EACH ROW EXECUTE FUNCTION public.update_cid_codes_updated_at();


--
-- Name: compensation_approvals trigger_update_compensation_approvals_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_compensation_approvals_updated_at BEFORE UPDATE ON rh.compensation_approvals FOR EACH ROW EXECUTE FUNCTION public.update_compensation_approvals_updated_at();


--
-- Name: compensation_requests trigger_update_compensation_requests_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_compensation_requests_updated_at BEFORE UPDATE ON rh.compensation_requests FOR EACH ROW EXECUTE FUNCTION public.update_compensation_requests_updated_at();


--
-- Name: deficiency_types trigger_update_deficiency_types_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_deficiency_types_updated_at BEFORE UPDATE ON rh.deficiency_types FOR EACH ROW EXECUTE FUNCTION public.update_deficiency_types_updated_at();


--
-- Name: delay_reasons trigger_update_delay_reasons_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_delay_reasons_updated_at BEFORE UPDATE ON rh.delay_reasons FOR EACH ROW EXECUTE FUNCTION public.update_delay_reasons_updated_at();


--
-- Name: disciplinary_actions trigger_update_disciplinary_actions_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_disciplinary_actions_updated_at BEFORE UPDATE ON rh.disciplinary_actions FOR EACH ROW EXECUTE FUNCTION public.update_disciplinary_actions_updated_at();


--
-- Name: employee_shifts trigger_update_employee_shifts_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_employee_shifts_updated_at BEFORE UPDATE ON rh.employee_shifts FOR EACH ROW EXECUTE FUNCTION public.update_employee_shifts_updated_at();


--
-- Name: employment_contracts trigger_update_employment_contracts_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_employment_contracts_updated_at BEFORE UPDATE ON rh.employment_contracts FOR EACH ROW EXECUTE FUNCTION public.update_employment_contracts_updated_at();


--
-- Name: esocial_integrations trigger_update_esocial_integrations_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_esocial_integrations_updated_at BEFORE UPDATE ON rh.esocial_integrations FOR EACH ROW EXECUTE FUNCTION public.update_esocial_integrations_updated_at();


--
-- Name: event_consolidations trigger_update_event_consolidations_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_event_consolidations_updated_at BEFORE UPDATE ON rh.event_consolidations FOR EACH ROW EXECUTE FUNCTION public.update_event_consolidations_updated_at();


--
-- Name: fgts_config trigger_update_fgts_config_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_fgts_config_updated_at BEFORE UPDATE ON rh.fgts_config FOR EACH ROW EXECUTE FUNCTION public.update_fgts_config_updated_at();


--
-- Name: income_statements trigger_update_income_statements_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_income_statements_updated_at BEFORE UPDATE ON rh.income_statements FOR EACH ROW EXECUTE FUNCTION public.update_income_statements_updated_at();


--
-- Name: inss_brackets trigger_update_inss_brackets_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_inss_brackets_updated_at BEFORE UPDATE ON rh.inss_brackets FOR EACH ROW EXECUTE FUNCTION public.update_inss_brackets_updated_at();


--
-- Name: irrf_brackets trigger_update_irrf_brackets_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_irrf_brackets_updated_at BEFORE UPDATE ON rh.irrf_brackets FOR EACH ROW EXECUTE FUNCTION public.update_irrf_brackets_updated_at();


--
-- Name: reports trigger_update_reports_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_reports_updated_at BEFORE UPDATE ON rh.reports FOR EACH ROW EXECUTE FUNCTION public.update_reports_updated_at();


--
-- Name: rubricas trigger_update_rubricas_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_rubricas_updated_at BEFORE UPDATE ON rh.rubricas FOR EACH ROW EXECUTE FUNCTION public.update_rubricas_updated_at();


--
-- Name: schedule_planning trigger_update_schedule_planning_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_schedule_planning_updated_at BEFORE UPDATE ON rh.schedule_planning FOR EACH ROW EXECUTE FUNCTION public.update_schedule_planning_updated_at();


--
-- Name: work_shifts trigger_update_work_shifts_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER trigger_update_work_shifts_updated_at BEFORE UPDATE ON rh.work_shifts FOR EACH ROW EXECUTE FUNCTION public.update_work_shifts_updated_at();


--
-- Name: bank_hours_balance update_bank_hours_balance_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_bank_hours_balance_updated_at BEFORE UPDATE ON rh.bank_hours_balance FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: bank_hours_config update_bank_hours_config_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_bank_hours_config_updated_at BEFORE UPDATE ON rh.bank_hours_config FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: bank_hours_transactions update_bank_hours_transactions_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_bank_hours_transactions_updated_at BEFORE UPDATE ON rh.bank_hours_transactions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: collective_agreements update_collective_agreements_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_collective_agreements_updated_at BEFORE UPDATE ON rh.collective_agreements FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: dependents update_dependents_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_dependents_updated_at BEFORE UPDATE ON rh.dependents FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: employee_medical_plans update_employee_medical_plans_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_employee_medical_plans_updated_at BEFORE UPDATE ON rh.employee_medical_plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: employee_plan_dependents update_employee_plan_dependents_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_employee_plan_dependents_updated_at BEFORE UPDATE ON rh.employee_plan_dependents FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: employee_union_memberships update_employee_union_memberships_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_employee_union_memberships_updated_at BEFORE UPDATE ON rh.employee_union_memberships FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: medical_agreements update_medical_agreements_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_medical_agreements_updated_at BEFORE UPDATE ON rh.medical_agreements FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: medical_plans update_medical_plans_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_medical_plans_updated_at BEFORE UPDATE ON rh.medical_plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: time_record_signature_config update_time_record_signature_config_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_time_record_signature_config_updated_at BEFORE UPDATE ON rh.time_record_signature_config FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: time_record_signatures update_time_record_signatures_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_time_record_signatures_updated_at BEFORE UPDATE ON rh.time_record_signatures FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: training_settings update_training_settings_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_training_settings_updated_at BEFORE UPDATE ON rh.training_settings FOR EACH ROW EXECUTE FUNCTION rh.update_training_settings_updated_at();


--
-- Name: union_contributions update_union_contributions_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_union_contributions_updated_at BEFORE UPDATE ON rh.union_contributions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: union_negotiations update_union_negotiations_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_union_negotiations_updated_at BEFORE UPDATE ON rh.union_negotiations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: union_representatives update_union_representatives_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_union_representatives_updated_at BEFORE UPDATE ON rh.union_representatives FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: unions update_unions_updated_at; Type: TRIGGER; Schema: rh; Owner: postgres
--

CREATE TRIGGER update_unions_updated_at BEFORE UPDATE ON rh.unions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


--
-- Name: buckets enforce_bucket_name_length_trigger; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER enforce_bucket_name_length_trigger BEFORE INSERT OR UPDATE OF name ON storage.buckets FOR EACH ROW EXECUTE FUNCTION storage.enforce_bucket_name_length();


--
-- Name: objects objects_delete_delete_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects objects_insert_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();


--
-- Name: objects objects_update_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();


--
-- Name: prefixes prefixes_create_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();


--
-- Name: prefixes prefixes_delete_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects update_objects_updated_at; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


--
-- Name: almoxarifados almoxarifados_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.almoxarifados
    ADD CONSTRAINT almoxarifados_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: almoxarifados almoxarifados_responsavel_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.almoxarifados
    ADD CONSTRAINT almoxarifados_responsavel_id_fkey FOREIGN KEY (responsavel_id) REFERENCES public.users(id);


--
-- Name: checklist_recebimento checklist_recebimento_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.checklist_recebimento
    ADD CONSTRAINT checklist_recebimento_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: checklist_recebimento checklist_recebimento_entrada_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.checklist_recebimento
    ADD CONSTRAINT checklist_recebimento_entrada_id_fkey FOREIGN KEY (entrada_id) REFERENCES almoxarifado.entradas_materiais(id) ON DELETE CASCADE;


--
-- Name: checklist_recebimento checklist_recebimento_item_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.checklist_recebimento
    ADD CONSTRAINT checklist_recebimento_item_id_fkey FOREIGN KEY (item_id) REFERENCES almoxarifado.entrada_itens(id) ON DELETE CASCADE;


--
-- Name: checklist_recebimento checklist_recebimento_usuario_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.checklist_recebimento
    ADD CONSTRAINT checklist_recebimento_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.users(id);


--
-- Name: entrada_itens entrada_itens_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: entrada_itens entrada_itens_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: entrada_itens entrada_itens_entrada_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_entrada_id_fkey FOREIGN KEY (entrada_id) REFERENCES almoxarifado.entradas_materiais(id) ON DELETE CASCADE;


--
-- Name: entrada_itens entrada_itens_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: entrada_itens entrada_itens_projeto_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entrada_itens
    ADD CONSTRAINT entrada_itens_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: entradas_materiais entradas_materiais_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: entradas_materiais entradas_materiais_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES public.partners(id);


--
-- Name: entradas_materiais entradas_materiais_nfe_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_nfe_id_fkey FOREIGN KEY (nfe_id) REFERENCES financeiro.nfe(id);


--
-- Name: entradas_materiais entradas_materiais_usuario_aprovacao_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_usuario_aprovacao_id_fkey FOREIGN KEY (usuario_aprovacao_id) REFERENCES public.users(id);


--
-- Name: entradas_materiais entradas_materiais_usuario_recebimento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.entradas_materiais
    ADD CONSTRAINT entradas_materiais_usuario_recebimento_id_fkey FOREIGN KEY (usuario_recebimento_id) REFERENCES public.users(id);


--
-- Name: estoque_atual estoque_atual_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.estoque_atual
    ADD CONSTRAINT estoque_atual_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: estoque_atual estoque_atual_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.estoque_atual
    ADD CONSTRAINT estoque_atual_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: estoque_atual estoque_atual_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.estoque_atual
    ADD CONSTRAINT estoque_atual_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: inventario_itens inventario_itens_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT inventario_itens_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: inventario_itens inventario_itens_contador_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT inventario_itens_contador_id_fkey FOREIGN KEY (contador_id) REFERENCES public.users(id);


--
-- Name: inventario_itens inventario_itens_inventario_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT inventario_itens_inventario_id_fkey FOREIGN KEY (inventario_id) REFERENCES almoxarifado.inventarios(id) ON DELETE CASCADE;


--
-- Name: inventario_itens inventario_itens_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventario_itens
    ADD CONSTRAINT inventario_itens_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: inventarios inventarios_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventarios
    ADD CONSTRAINT inventarios_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: inventarios inventarios_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventarios
    ADD CONSTRAINT inventarios_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: inventarios inventarios_responsavel_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.inventarios
    ADD CONSTRAINT inventarios_responsavel_id_fkey FOREIGN KEY (responsavel_id) REFERENCES public.users(id);


--
-- Name: localizacoes_fisicas localizacoes_fisicas_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.localizacoes_fisicas
    ADD CONSTRAINT localizacoes_fisicas_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: localizacoes_fisicas localizacoes_fisicas_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.localizacoes_fisicas
    ADD CONSTRAINT localizacoes_fisicas_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: materiais_equipamentos materiais_equipamentos_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.materiais_equipamentos
    ADD CONSTRAINT materiais_equipamentos_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: materiais_equipamentos materiais_equipamentos_localizacao_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.materiais_equipamentos
    ADD CONSTRAINT materiais_equipamentos_localizacao_id_fkey FOREIGN KEY (localizacao_id) REFERENCES almoxarifado.localizacoes_fisicas(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_almoxarifado_destino_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_almoxarifado_destino_id_fkey FOREIGN KEY (almoxarifado_destino_id) REFERENCES almoxarifado.almoxarifados(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_almoxarifado_origem_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_almoxarifado_origem_id_fkey FOREIGN KEY (almoxarifado_origem_id) REFERENCES almoxarifado.almoxarifados(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: movimentacoes_estoque movimentacoes_estoque_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: movimentacoes_estoque movimentacoes_estoque_nfe_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_nfe_id_fkey FOREIGN KEY (nfe_id) REFERENCES financeiro.nfe(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_projeto_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: movimentacoes_estoque movimentacoes_estoque_usuario_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.movimentacoes_estoque
    ADD CONSTRAINT movimentacoes_estoque_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.users(id);


--
-- Name: solicitacoes_compra solicitacoes_compra_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_compra solicitacoes_compra_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: solicitacoes_compra solicitacoes_compra_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_compra solicitacoes_compra_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_compra solicitacoes_compra_projeto_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_compra
    ADD CONSTRAINT solicitacoes_compra_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id);


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_funcionario_receptor_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_funcionario_receptor_id_fkey FOREIGN KEY (funcionario_receptor_id) REFERENCES public.users(id);


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_funcionario_solicitante_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_funcionario_solicitante_id_fkey FOREIGN KEY (funcionario_solicitante_id) REFERENCES public.users(id);


--
-- Name: solicitacoes_saida_materiais_itens solicitacoes_saida_materiais_itens_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais_itens
    ADD CONSTRAINT solicitacoes_saida_materiais_itens_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_saida_materiais_itens solicitacoes_saida_materiais_itens_material_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais_itens
    ADD CONSTRAINT solicitacoes_saida_materiais_itens_material_id_fkey FOREIGN KEY (material_id) REFERENCES almoxarifado.materiais_equipamentos(id);


--
-- Name: solicitacoes_saida_materiais_itens solicitacoes_saida_materiais_itens_solicitacao_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais_itens
    ADD CONSTRAINT solicitacoes_saida_materiais_itens_solicitacao_id_fkey FOREIGN KEY (solicitacao_id) REFERENCES almoxarifado.solicitacoes_saida_materiais(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_saida_materiais solicitacoes_saida_materiais_projeto_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.solicitacoes_saida_materiais
    ADD CONSTRAINT solicitacoes_saida_materiais_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: transferencia_itens transferencia_itens_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: transferencia_itens transferencia_itens_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: transferencia_itens transferencia_itens_material_equipamento_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_material_equipamento_id_fkey FOREIGN KEY (material_equipamento_id) REFERENCES almoxarifado.materiais_equipamentos(id) ON DELETE CASCADE;


--
-- Name: transferencia_itens transferencia_itens_projeto_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: transferencia_itens transferencia_itens_transferencia_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencia_itens
    ADD CONSTRAINT transferencia_itens_transferencia_id_fkey FOREIGN KEY (transferencia_id) REFERENCES almoxarifado.transferencias(id) ON DELETE CASCADE;


--
-- Name: transferencias transferencias_almoxarifado_destino_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_almoxarifado_destino_id_fkey FOREIGN KEY (almoxarifado_destino_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: transferencias transferencias_almoxarifado_origem_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_almoxarifado_origem_id_fkey FOREIGN KEY (almoxarifado_origem_id) REFERENCES almoxarifado.almoxarifados(id) ON DELETE CASCADE;


--
-- Name: transferencias transferencias_aprovador_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_aprovador_id_fkey FOREIGN KEY (aprovador_id) REFERENCES public.users(id);


--
-- Name: transferencias transferencias_company_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: transferencias transferencias_solicitante_id_fkey; Type: FK CONSTRAINT; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE ONLY almoxarifado.transferencias
    ADD CONSTRAINT transferencias_solicitante_id_fkey FOREIGN KEY (solicitante_id) REFERENCES public.users(id);


--
-- Name: identities identities_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: mfa_challenges mfa_challenges_auth_factor_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE;


--
-- Name: mfa_factors mfa_factors_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_authorizations oauth_authorizations_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_authorizations
    ADD CONSTRAINT oauth_authorizations_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_client_id_fkey FOREIGN KEY (client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: oauth_consents oauth_consents_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.oauth_consents
    ADD CONSTRAINT oauth_consents_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: one_time_tokens one_time_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: refresh_tokens refresh_tokens_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: saml_providers saml_providers_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_flow_state_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_oauth_client_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_oauth_client_id_fkey FOREIGN KEY (oauth_client_id) REFERENCES auth.oauth_clients(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: sso_domains sso_domains_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: aprovacoes_cotacao aprovacoes_cotacao_aprovador_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_cotacao
    ADD CONSTRAINT aprovacoes_cotacao_aprovador_id_fkey FOREIGN KEY (aprovador_id) REFERENCES public.users(id);


--
-- Name: aprovacoes_cotacao aprovacoes_cotacao_cotacao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_cotacao
    ADD CONSTRAINT aprovacoes_cotacao_cotacao_id_fkey FOREIGN KEY (cotacao_id) REFERENCES compras.cotacoes(id) ON DELETE CASCADE;


--
-- Name: aprovacoes_requisicao aprovacoes_requisicao_aprovador_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_requisicao
    ADD CONSTRAINT aprovacoes_requisicao_aprovador_id_fkey FOREIGN KEY (aprovador_id) REFERENCES public.users(id);


--
-- Name: aprovacoes_requisicao aprovacoes_requisicao_requisicao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.aprovacoes_requisicao
    ADD CONSTRAINT aprovacoes_requisicao_requisicao_id_fkey FOREIGN KEY (requisicao_id) REFERENCES compras.requisicoes_compra(id) ON DELETE CASCADE;


--
-- Name: avaliacoes_fornecedor avaliacoes_fornecedor_avaliador_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.avaliacoes_fornecedor
    ADD CONSTRAINT avaliacoes_fornecedor_avaliador_id_fkey FOREIGN KEY (avaliador_id) REFERENCES public.users(id);


--
-- Name: avaliacoes_fornecedor avaliacoes_fornecedor_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.avaliacoes_fornecedor
    ADD CONSTRAINT avaliacoes_fornecedor_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: avaliacoes_fornecedor avaliacoes_fornecedor_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.avaliacoes_fornecedor
    ADD CONSTRAINT avaliacoes_fornecedor_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id) ON DELETE CASCADE;


--
-- Name: avaliacoes_fornecedor avaliacoes_fornecedor_pedido_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.avaliacoes_fornecedor
    ADD CONSTRAINT avaliacoes_fornecedor_pedido_id_fkey FOREIGN KEY (pedido_id) REFERENCES compras.pedidos_compra(id);


--
-- Name: compras_recorrentes compras_recorrentes_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.compras_recorrentes
    ADD CONSTRAINT compras_recorrentes_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: compras_recorrentes compras_recorrentes_contrato_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.compras_recorrentes
    ADD CONSTRAINT compras_recorrentes_contrato_id_fkey FOREIGN KEY (contrato_id) REFERENCES compras.contratos(id) ON DELETE CASCADE;


--
-- Name: compras_recorrentes compras_recorrentes_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.compras_recorrentes
    ADD CONSTRAINT compras_recorrentes_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_departamento_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_departamento_id_fkey FOREIGN KEY (departamento_id) REFERENCES public.cost_centers(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_perfil_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_perfil_id_fkey FOREIGN KEY (perfil_id) REFERENCES public.profiles(id);


--
-- Name: contratos contratos_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.contratos
    ADD CONSTRAINT contratos_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: contratos contratos_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.contratos
    ADD CONSTRAINT contratos_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: contratos contratos_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.contratos
    ADD CONSTRAINT contratos_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id) ON DELETE CASCADE;


--
-- Name: cotacao_itens cotacao_itens_cotacao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacao_itens
    ADD CONSTRAINT cotacao_itens_cotacao_id_fkey FOREIGN KEY (cotacao_id) REFERENCES compras.cotacoes(id) ON DELETE CASCADE;


--
-- Name: cotacao_itens cotacao_itens_requisicao_item_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacao_itens
    ADD CONSTRAINT cotacao_itens_requisicao_item_id_fkey FOREIGN KEY (requisicao_item_id) REFERENCES compras.requisicao_itens(id);


--
-- Name: cotacoes cotacoes_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacoes
    ADD CONSTRAINT cotacoes_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: cotacoes cotacoes_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacoes
    ADD CONSTRAINT cotacoes_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id);


--
-- Name: cotacoes cotacoes_requisicao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.cotacoes
    ADD CONSTRAINT cotacoes_requisicao_id_fkey FOREIGN KEY (requisicao_id) REFERENCES compras.requisicoes_compra(id) ON DELETE CASCADE;


--
-- Name: fornecedores_dados fornecedores_dados_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.fornecedores_dados
    ADD CONSTRAINT fornecedores_dados_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: fornecedores_dados fornecedores_dados_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.fornecedores_dados
    ADD CONSTRAINT fornecedores_dados_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: fornecedores_dados fornecedores_dados_partner_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.fornecedores_dados
    ADD CONSTRAINT fornecedores_dados_partner_id_fkey FOREIGN KEY (partner_id) REFERENCES public.partners(id) ON DELETE CASCADE;


--
-- Name: historico_compras historico_compras_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_compras
    ADD CONSTRAINT historico_compras_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: historico_compras historico_compras_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_compras
    ADD CONSTRAINT historico_compras_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id);


--
-- Name: historico_compras historico_compras_pedido_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_compras
    ADD CONSTRAINT historico_compras_pedido_id_fkey FOREIGN KEY (pedido_id) REFERENCES compras.pedidos_compra(id) ON DELETE CASCADE;


--
-- Name: historico_precos historico_precos_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_precos
    ADD CONSTRAINT historico_precos_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: historico_precos historico_precos_cotacao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_precos
    ADD CONSTRAINT historico_precos_cotacao_id_fkey FOREIGN KEY (cotacao_id) REFERENCES compras.cotacoes(id);


--
-- Name: historico_precos historico_precos_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_precos
    ADD CONSTRAINT historico_precos_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id) ON DELETE SET NULL;


--
-- Name: historico_precos historico_precos_pedido_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.historico_precos
    ADD CONSTRAINT historico_precos_pedido_id_fkey FOREIGN KEY (pedido_id) REFERENCES compras.pedidos_compra(id);


--
-- Name: pedido_itens pedido_itens_cotacao_item_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedido_itens
    ADD CONSTRAINT pedido_itens_cotacao_item_id_fkey FOREIGN KEY (cotacao_item_id) REFERENCES compras.cotacao_itens(id);


--
-- Name: pedido_itens pedido_itens_pedido_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedido_itens
    ADD CONSTRAINT pedido_itens_pedido_id_fkey FOREIGN KEY (pedido_id) REFERENCES compras.pedidos_compra(id) ON DELETE CASCADE;


--
-- Name: pedidos_compra pedidos_compra_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: pedidos_compra pedidos_compra_cotacao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_cotacao_id_fkey FOREIGN KEY (cotacao_id) REFERENCES compras.cotacoes(id);


--
-- Name: pedidos_compra pedidos_compra_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: pedidos_compra pedidos_compra_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.pedidos_compra
    ADD CONSTRAINT pedidos_compra_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES compras.fornecedores_dados(id);


--
-- Name: requisicao_itens requisicao_itens_almoxarifado_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicao_itens
    ADD CONSTRAINT requisicao_itens_almoxarifado_id_fkey FOREIGN KEY (almoxarifado_id) REFERENCES almoxarifado.almoxarifados(id);


--
-- Name: requisicao_itens requisicao_itens_requisicao_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicao_itens
    ADD CONSTRAINT requisicao_itens_requisicao_id_fkey FOREIGN KEY (requisicao_id) REFERENCES compras.requisicoes_compra(id) ON DELETE CASCADE;


--
-- Name: requisicoes_compra requisicoes_compra_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.users(id);


--
-- Name: requisicoes_compra requisicoes_compra_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: requisicoes_compra requisicoes_compra_company_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: requisicoes_compra requisicoes_compra_created_by_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: requisicoes_compra requisicoes_compra_projeto_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: requisicoes_compra requisicoes_compra_solicitante_id_fkey; Type: FK CONSTRAINT; Schema: compras; Owner: postgres
--

ALTER TABLE ONLY compras.requisicoes_compra
    ADD CONSTRAINT requisicoes_compra_solicitante_id_fkey FOREIGN KEY (solicitante_id) REFERENCES public.users(id);


--
-- Name: aprovacoes aprovacoes_aprovador_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.aprovacoes
    ADD CONSTRAINT aprovacoes_aprovador_id_fkey FOREIGN KEY (aprovador_id) REFERENCES public.users(id);


--
-- Name: aprovacoes aprovacoes_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.aprovacoes
    ADD CONSTRAINT aprovacoes_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: borderos borderos_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.borderos
    ADD CONSTRAINT borderos_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: borderos borderos_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.borderos
    ADD CONSTRAINT borderos_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: conciliacoes_bancarias conciliacoes_bancarias_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.conciliacoes_bancarias
    ADD CONSTRAINT conciliacoes_bancarias_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: conciliacoes_bancarias conciliacoes_bancarias_conta_bancaria_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.conciliacoes_bancarias
    ADD CONSTRAINT conciliacoes_bancarias_conta_bancaria_id_fkey FOREIGN KEY (conta_bancaria_id) REFERENCES financeiro.contas_bancarias(id);


--
-- Name: conciliacoes_bancarias conciliacoes_bancarias_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.conciliacoes_bancarias
    ADD CONSTRAINT conciliacoes_bancarias_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracao_bancaria configuracao_bancaria_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_bancaria
    ADD CONSTRAINT configuracao_bancaria_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: configuracao_bancaria configuracao_bancaria_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_bancaria
    ADD CONSTRAINT configuracao_bancaria_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracao_fiscal configuracao_fiscal_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_fiscal
    ADD CONSTRAINT configuracao_fiscal_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: configuracao_fiscal configuracao_fiscal_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracao_fiscal
    ADD CONSTRAINT configuracao_fiscal_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao configuracoes_aprovacao_usuario_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.configuracoes_aprovacao
    ADD CONSTRAINT configuracoes_aprovacao_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.users(id);


--
-- Name: contas_bancarias contas_bancarias_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_bancarias
    ADD CONSTRAINT contas_bancarias_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: contas_bancarias contas_bancarias_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_bancarias
    ADD CONSTRAINT contas_bancarias_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: contas_pagar contas_pagar_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.users(id);


--
-- Name: contas_pagar contas_pagar_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: contas_pagar contas_pagar_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: contas_pagar contas_pagar_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: contas_pagar contas_pagar_fornecedor_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_fornecedor_id_fkey FOREIGN KEY (fornecedor_id) REFERENCES public.partners(id);


--
-- Name: contas_pagar contas_pagar_projeto_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_pagar
    ADD CONSTRAINT contas_pagar_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: contas_receber contas_receber_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: contas_receber contas_receber_cliente_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_cliente_id_fkey FOREIGN KEY (cliente_id) REFERENCES public.partners(id);


--
-- Name: contas_receber contas_receber_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: contas_receber contas_receber_confirmado_por_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_confirmado_por_fkey FOREIGN KEY (confirmado_por) REFERENCES public.users(id);


--
-- Name: contas_receber contas_receber_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: contas_receber contas_receber_projeto_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.contas_receber
    ADD CONSTRAINT contas_receber_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: fluxo_caixa fluxo_caixa_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: fluxo_caixa fluxo_caixa_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: fluxo_caixa fluxo_caixa_conta_bancaria_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_conta_bancaria_id_fkey FOREIGN KEY (conta_bancaria_id) REFERENCES financeiro.contas_bancarias(id);


--
-- Name: fluxo_caixa fluxo_caixa_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: fluxo_caixa fluxo_caixa_projeto_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.fluxo_caixa
    ADD CONSTRAINT fluxo_caixa_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: lancamentos_contabeis lancamentos_contabeis_conta_credito_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_conta_credito_id_fkey FOREIGN KEY (conta_credito_id) REFERENCES financeiro.plano_contas(id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_conta_debito_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_conta_debito_id_fkey FOREIGN KEY (conta_debito_id) REFERENCES financeiro.plano_contas(id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: lancamentos_contabeis lancamentos_contabeis_projeto_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.lancamentos_contabeis
    ADD CONSTRAINT lancamentos_contabeis_projeto_id_fkey FOREIGN KEY (projeto_id) REFERENCES public.projects(id);


--
-- Name: log_validacao_integracao log_validacao_integracao_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.log_validacao_integracao
    ADD CONSTRAINT log_validacao_integracao_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: log_validacao_integracao log_validacao_integracao_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.log_validacao_integracao
    ADD CONSTRAINT log_validacao_integracao_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: nfe nfe_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfe
    ADD CONSTRAINT nfe_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: nfe nfe_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfe
    ADD CONSTRAINT nfe_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: nfse nfse_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfse
    ADD CONSTRAINT nfse_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: nfse nfse_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.nfse
    ADD CONSTRAINT nfse_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: plano_contas plano_contas_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.plano_contas
    ADD CONSTRAINT plano_contas_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: plano_contas plano_contas_conta_pai_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.plano_contas
    ADD CONSTRAINT plano_contas_conta_pai_id_fkey FOREIGN KEY (conta_pai_id) REFERENCES financeiro.plano_contas(id);


--
-- Name: plano_contas plano_contas_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.plano_contas
    ADD CONSTRAINT plano_contas_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: remessas_bancarias remessas_bancarias_borderos_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.remessas_bancarias
    ADD CONSTRAINT remessas_bancarias_borderos_id_fkey FOREIGN KEY (borderos_id) REFERENCES financeiro.borderos(id);


--
-- Name: remessas_bancarias remessas_bancarias_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.remessas_bancarias
    ADD CONSTRAINT remessas_bancarias_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: remessas_bancarias remessas_bancarias_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.remessas_bancarias
    ADD CONSTRAINT remessas_bancarias_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: retornos_bancarios retornos_bancarios_company_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.retornos_bancarios
    ADD CONSTRAINT retornos_bancarios_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: retornos_bancarios retornos_bancarios_created_by_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.retornos_bancarios
    ADD CONSTRAINT retornos_bancarios_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: retornos_bancarios retornos_bancarios_remessa_id_fkey; Type: FK CONSTRAINT; Schema: financeiro; Owner: postgres
--

ALTER TABLE ONLY financeiro.retornos_bancarios
    ADD CONSTRAINT retornos_bancarios_remessa_id_fkey FOREIGN KEY (remessa_id) REFERENCES financeiro.remessas_bancarias(id);


--
-- Name: aprovacoes_unificada aprovacoes_unificada_aprovador_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aprovacoes_unificada
    ADD CONSTRAINT aprovacoes_unificada_aprovador_id_fkey FOREIGN KEY (aprovador_id) REFERENCES public.users(id);


--
-- Name: aprovacoes_unificada aprovacoes_unificada_aprovador_original_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aprovacoes_unificada
    ADD CONSTRAINT aprovacoes_unificada_aprovador_original_id_fkey FOREIGN KEY (aprovador_original_id) REFERENCES public.users(id);


--
-- Name: aprovacoes_unificada aprovacoes_unificada_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aprovacoes_unificada
    ADD CONSTRAINT aprovacoes_unificada_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: aprovacoes_unificada aprovacoes_unificada_transferido_por_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.aprovacoes_unificada
    ADD CONSTRAINT aprovacoes_unificada_transferido_por_fkey FOREIGN KEY (transferido_por) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao_unificada configuracoes_aprovacao_unificada_centro_custo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configuracoes_aprovacao_unificada
    ADD CONSTRAINT configuracoes_aprovacao_unificada_centro_custo_id_fkey FOREIGN KEY (centro_custo_id) REFERENCES public.cost_centers(id);


--
-- Name: configuracoes_aprovacao_unificada configuracoes_aprovacao_unificada_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configuracoes_aprovacao_unificada
    ADD CONSTRAINT configuracoes_aprovacao_unificada_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: configuracoes_aprovacao_unificada configuracoes_aprovacao_unificada_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configuracoes_aprovacao_unificada
    ADD CONSTRAINT configuracoes_aprovacao_unificada_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: configuracoes_aprovacao_unificada configuracoes_aprovacao_unificada_usuario_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.configuracoes_aprovacao_unificada
    ADD CONSTRAINT configuracoes_aprovacao_unificada_usuario_id_fkey FOREIGN KEY (usuario_id) REFERENCES public.users(id);


--
-- Name: cost_centers cost_centers_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cost_centers
    ADD CONSTRAINT cost_centers_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: entity_permissions entity_permissions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.entity_permissions
    ADD CONSTRAINT entity_permissions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: historico_edicoes_solicitacoes historico_edicoes_solicitacoes_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.historico_edicoes_solicitacoes
    ADD CONSTRAINT historico_edicoes_solicitacoes_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: historico_edicoes_solicitacoes historico_edicoes_solicitacoes_usuario_editor_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.historico_edicoes_solicitacoes
    ADD CONSTRAINT historico_edicoes_solicitacoes_usuario_editor_id_fkey FOREIGN KEY (usuario_editor_id) REFERENCES public.users(id);


--
-- Name: module_permissions module_permissions_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.module_permissions
    ADD CONSTRAINT module_permissions_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: notifications notifications_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.notifications
    ADD CONSTRAINT notifications_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: partners partners_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partners
    ADD CONSTRAINT partners_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: partners partners_matriz_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partners
    ADD CONSTRAINT partners_matriz_id_fkey FOREIGN KEY (matriz_id) REFERENCES public.partners(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED;


--
-- Name: CONSTRAINT partners_matriz_id_fkey ON partners; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON CONSTRAINT partners_matriz_id_fkey ON public.partners IS 'Self-reference para permitir hierarquia matriz/filial. DEFERRABLE para resolver circular dependency no dump/restore.';


--
-- Name: projects projects_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: projects projects_cost_center_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.projects
    ADD CONSTRAINT projects_cost_center_id_fkey FOREIGN KEY (cost_center_id) REFERENCES public.cost_centers(id);


--
-- Name: user_companies user_companies_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_companies
    ADD CONSTRAINT user_companies_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: user_companies user_companies_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_companies
    ADD CONSTRAINT user_companies_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id);


--
-- Name: user_companies user_companies_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_companies
    ADD CONSTRAINT user_companies_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: users users_company_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id);


--
-- Name: users users_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.users
    ADD CONSTRAINT users_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: absence_types absence_types_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.absence_types
    ADD CONSTRAINT absence_types_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: allowance_types allowance_types_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.allowance_types
    ADD CONSTRAINT allowance_types_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: approval_level_approvers approval_level_approvers_approval_level_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.approval_level_approvers
    ADD CONSTRAINT approval_level_approvers_approval_level_id_fkey FOREIGN KEY (approval_level_id) REFERENCES rh.approval_levels(id) ON DELETE CASCADE;


--
-- Name: approval_level_approvers approval_level_approvers_user_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.approval_level_approvers
    ADD CONSTRAINT approval_level_approvers_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: approval_levels approval_levels_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.approval_levels
    ADD CONSTRAINT approval_levels_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: attendance_corrections attendance_corrections_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.attendance_corrections
    ADD CONSTRAINT attendance_corrections_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: attendance_corrections attendance_corrections_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.attendance_corrections
    ADD CONSTRAINT attendance_corrections_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: attendance_corrections attendance_corrections_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.attendance_corrections
    ADD CONSTRAINT attendance_corrections_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: attendance_corrections attendance_corrections_solicitado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.attendance_corrections
    ADD CONSTRAINT attendance_corrections_solicitado_por_fkey FOREIGN KEY (solicitado_por) REFERENCES public.profiles(id);


--
-- Name: audit_config audit_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_config
    ADD CONSTRAINT audit_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: audit_logs audit_logs_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_logs
    ADD CONSTRAINT audit_logs_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: audit_logs audit_logs_user_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.audit_logs
    ADD CONSTRAINT audit_logs_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: bank_hours_balance bank_hours_balance_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_balance
    ADD CONSTRAINT bank_hours_balance_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: bank_hours_balance bank_hours_balance_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_balance
    ADD CONSTRAINT bank_hours_balance_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: bank_hours_calculations bank_hours_calculations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_calculations
    ADD CONSTRAINT bank_hours_calculations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: bank_hours_config bank_hours_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_config
    ADD CONSTRAINT bank_hours_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: bank_hours_config bank_hours_config_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_config
    ADD CONSTRAINT bank_hours_config_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: bank_hours_transactions bank_hours_transactions_approved_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.profiles(id);


--
-- Name: bank_hours_transactions bank_hours_transactions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: bank_hours_transactions bank_hours_transactions_created_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.profiles(id);


--
-- Name: bank_hours_transactions bank_hours_transactions_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: bank_hours_transactions bank_hours_transactions_time_record_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.bank_hours_transactions
    ADD CONSTRAINT bank_hours_transactions_time_record_id_fkey FOREIGN KEY (time_record_id) REFERENCES rh.time_records(id);


--
-- Name: benefit_configurations benefit_configurations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.benefit_configurations
    ADD CONSTRAINT benefit_configurations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: calculation_logs calculation_logs_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.calculation_logs
    ADD CONSTRAINT calculation_logs_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: candidate_documents candidate_documents_candidate_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidate_documents
    ADD CONSTRAINT candidate_documents_candidate_id_fkey FOREIGN KEY (candidate_id) REFERENCES rh.candidates(id) ON DELETE CASCADE;


--
-- Name: candidate_documents candidate_documents_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidate_documents
    ADD CONSTRAINT candidate_documents_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: candidate_documents candidate_documents_uploaded_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidate_documents
    ADD CONSTRAINT candidate_documents_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES auth.users(id);


--
-- Name: candidates candidates_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.candidates
    ADD CONSTRAINT candidates_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: cid_codes cid_codes_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.cid_codes
    ADD CONSTRAINT cid_codes_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: collective_agreements collective_agreements_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.collective_agreements
    ADD CONSTRAINT collective_agreements_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: collective_agreements collective_agreements_union_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.collective_agreements
    ADD CONSTRAINT collective_agreements_union_id_fkey FOREIGN KEY (union_id) REFERENCES rh.unions(id) ON DELETE CASCADE;


--
-- Name: compensation_approvals compensation_approvals_approval_level_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_approvals
    ADD CONSTRAINT compensation_approvals_approval_level_id_fkey FOREIGN KEY (approval_level_id) REFERENCES rh.approval_levels(id) ON DELETE CASCADE;


--
-- Name: compensation_approvals compensation_approvals_approver_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_approvals
    ADD CONSTRAINT compensation_approvals_approver_id_fkey FOREIGN KEY (approver_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: compensation_approvals compensation_approvals_compensation_request_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_approvals
    ADD CONSTRAINT compensation_approvals_compensation_request_id_fkey FOREIGN KEY (compensation_request_id) REFERENCES rh.compensation_requests(id) ON DELETE CASCADE;


--
-- Name: compensation_requests compensation_requests_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_requests
    ADD CONSTRAINT compensation_requests_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES auth.users(id);


--
-- Name: compensation_requests compensation_requests_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_requests
    ADD CONSTRAINT compensation_requests_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: compensation_requests compensation_requests_funcionario_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.compensation_requests
    ADD CONSTRAINT compensation_requests_funcionario_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: correction_history correction_history_changed_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_history
    ADD CONSTRAINT correction_history_changed_by_fkey FOREIGN KEY (changed_by) REFERENCES public.profiles(id);


--
-- Name: correction_history correction_history_correction_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_history
    ADD CONSTRAINT correction_history_correction_id_fkey FOREIGN KEY (correction_id) REFERENCES rh.attendance_corrections(id) ON DELETE CASCADE;


--
-- Name: correction_settings correction_settings_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.correction_settings
    ADD CONSTRAINT correction_settings_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: deficiency_types deficiency_types_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.deficiency_types
    ADD CONSTRAINT deficiency_types_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: delay_reasons delay_reasons_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.delay_reasons
    ADD CONSTRAINT delay_reasons_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: dependents dependents_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: dependents dependents_created_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.users(id);


--
-- Name: dependents dependents_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: dependents dependents_updated_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.dependents
    ADD CONSTRAINT dependents_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.users(id);


--
-- Name: disciplinary_actions disciplinary_actions_aplicado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.disciplinary_actions
    ADD CONSTRAINT disciplinary_actions_aplicado_por_fkey FOREIGN KEY (aplicado_por) REFERENCES auth.users(id);


--
-- Name: disciplinary_actions disciplinary_actions_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.disciplinary_actions
    ADD CONSTRAINT disciplinary_actions_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES auth.users(id);


--
-- Name: disciplinary_actions disciplinary_actions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.disciplinary_actions
    ADD CONSTRAINT disciplinary_actions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: disciplinary_actions disciplinary_actions_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.disciplinary_actions
    ADD CONSTRAINT disciplinary_actions_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_benefit_assignments employee_benefit_assignments_benefit_config_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_benefit_assignments
    ADD CONSTRAINT employee_benefit_assignments_benefit_config_id_fkey FOREIGN KEY (benefit_config_id) REFERENCES rh.benefit_configurations(id) ON DELETE CASCADE;


--
-- Name: employee_benefit_assignments employee_benefit_assignments_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_benefit_assignments
    ADD CONSTRAINT employee_benefit_assignments_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_benefit_assignments employee_benefit_assignments_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_benefit_assignments
    ADD CONSTRAINT employee_benefit_assignments_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_correction_permissions employee_correction_permissions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_correction_permissions
    ADD CONSTRAINT employee_correction_permissions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_correction_permissions employee_correction_permissions_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_correction_permissions
    ADD CONSTRAINT employee_correction_permissions_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_correction_permissions employee_correction_permissions_liberado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_correction_permissions
    ADD CONSTRAINT employee_correction_permissions_liberado_por_fkey FOREIGN KEY (liberado_por) REFERENCES public.profiles(id);


--
-- Name: employee_medical_plans employee_medical_plans_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_medical_plans
    ADD CONSTRAINT employee_medical_plans_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_medical_plans employee_medical_plans_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_medical_plans
    ADD CONSTRAINT employee_medical_plans_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_medical_plans employee_medical_plans_plan_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_medical_plans
    ADD CONSTRAINT employee_medical_plans_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES rh.medical_plans(id) ON DELETE CASCADE;


--
-- Name: employee_plan_dependents employee_plan_dependents_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_plan_dependents
    ADD CONSTRAINT employee_plan_dependents_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_plan_dependents employee_plan_dependents_employee_plan_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_plan_dependents
    ADD CONSTRAINT employee_plan_dependents_employee_plan_id_fkey FOREIGN KEY (employee_plan_id) REFERENCES rh.employee_medical_plans(id) ON DELETE CASCADE;


--
-- Name: employee_schedules employee_schedules_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_schedules
    ADD CONSTRAINT employee_schedules_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_schedules employee_schedules_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_schedules
    ADD CONSTRAINT employee_schedules_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_schedules employee_schedules_schedule_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_schedules
    ADD CONSTRAINT employee_schedules_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES rh.work_schedules(id) ON DELETE CASCADE;


--
-- Name: employee_shifts employee_shifts_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_shifts
    ADD CONSTRAINT employee_shifts_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_shifts employee_shifts_funcionario_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_shifts
    ADD CONSTRAINT employee_shifts_funcionario_id_fkey FOREIGN KEY (funcionario_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_shifts employee_shifts_turno_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_shifts
    ADD CONSTRAINT employee_shifts_turno_id_fkey FOREIGN KEY (turno_id) REFERENCES rh.work_shifts(id) ON DELETE CASCADE;


--
-- Name: employee_union_memberships employee_union_memberships_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_union_memberships
    ADD CONSTRAINT employee_union_memberships_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employee_union_memberships employee_union_memberships_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_union_memberships
    ADD CONSTRAINT employee_union_memberships_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: employee_union_memberships employee_union_memberships_union_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employee_union_memberships
    ADD CONSTRAINT employee_union_memberships_union_id_fkey FOREIGN KEY (union_id) REFERENCES rh.unions(id) ON DELETE CASCADE;


--
-- Name: employees employees_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT employees_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employees employees_gestor_imediato_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT employees_gestor_imediato_id_fkey FOREIGN KEY (gestor_imediato_id) REFERENCES rh.employees(id) ON DELETE SET NULL;


--
-- Name: employees employees_user_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT employees_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: employment_contracts employment_contracts_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employment_contracts
    ADD CONSTRAINT employment_contracts_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employment_contracts employment_contracts_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employment_contracts
    ADD CONSTRAINT employment_contracts_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: equipment_rental_approvals equipment_rental_approvals_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.equipment_rental_approvals
    ADD CONSTRAINT equipment_rental_approvals_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: equipment_rental_approvals equipment_rental_approvals_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.equipment_rental_approvals
    ADD CONSTRAINT equipment_rental_approvals_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: equipment_rental_approvals equipment_rental_approvals_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.equipment_rental_approvals
    ADD CONSTRAINT equipment_rental_approvals_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: esocial_batches esocial_batches_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_batches
    ADD CONSTRAINT esocial_batches_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: esocial_batches esocial_batches_created_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_batches
    ADD CONSTRAINT esocial_batches_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: esocial_batches esocial_batches_updated_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_batches
    ADD CONSTRAINT esocial_batches_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id);


--
-- Name: esocial_config esocial_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_config
    ADD CONSTRAINT esocial_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: esocial_events esocial_events_batch_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_events
    ADD CONSTRAINT esocial_events_batch_id_fkey FOREIGN KEY (batch_id) REFERENCES rh.esocial_batches(id) ON DELETE SET NULL;


--
-- Name: esocial_events esocial_events_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_events
    ADD CONSTRAINT esocial_events_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: esocial_events esocial_events_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_events
    ADD CONSTRAINT esocial_events_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE SET NULL;


--
-- Name: esocial_integrations esocial_integrations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_integrations
    ADD CONSTRAINT esocial_integrations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: esocial_integrations esocial_integrations_funcionario_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_integrations
    ADD CONSTRAINT esocial_integrations_funcionario_id_fkey FOREIGN KEY (funcionario_id) REFERENCES rh.employees(id);


--
-- Name: esocial_logs esocial_logs_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_logs
    ADD CONSTRAINT esocial_logs_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: esocial_logs esocial_logs_event_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.esocial_logs
    ADD CONSTRAINT esocial_logs_event_id_fkey FOREIGN KEY (event_id) REFERENCES rh.esocial_events(id) ON DELETE CASCADE;


--
-- Name: event_consolidations event_consolidations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.event_consolidations
    ADD CONSTRAINT event_consolidations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: fgts_config fgts_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.fgts_config
    ADD CONSTRAINT fgts_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: employees fk_employees_cargo_id; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT fk_employees_cargo_id FOREIGN KEY (cargo_id) REFERENCES rh.positions(id);


--
-- Name: employees fk_employees_departamento_id; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employees
    ADD CONSTRAINT fk_employees_departamento_id FOREIGN KEY (departamento_id) REFERENCES rh.units(id);


--
-- Name: employment_contracts fk_employment_contracts_employee_id; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.employment_contracts
    ADD CONSTRAINT fk_employment_contracts_employee_id FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: gestor_notifications gestor_notifications_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.gestor_notifications
    ADD CONSTRAINT gestor_notifications_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: gestor_notifications gestor_notifications_gestor_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.gestor_notifications
    ADD CONSTRAINT gestor_notifications_gestor_id_fkey FOREIGN KEY (gestor_id) REFERENCES public.profiles(id) ON DELETE CASCADE;


--
-- Name: holidays holidays_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.holidays
    ADD CONSTRAINT holidays_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: income_statements income_statements_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.income_statements
    ADD CONSTRAINT income_statements_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: income_statements income_statements_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.income_statements
    ADD CONSTRAINT income_statements_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: inss_brackets inss_brackets_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.inss_brackets
    ADD CONSTRAINT inss_brackets_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: irrf_brackets irrf_brackets_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.irrf_brackets
    ADD CONSTRAINT irrf_brackets_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: job_openings job_openings_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_openings
    ADD CONSTRAINT job_openings_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: job_openings job_openings_created_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_openings
    ADD CONSTRAINT job_openings_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: job_openings job_openings_job_request_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_openings
    ADD CONSTRAINT job_openings_job_request_id_fkey FOREIGN KEY (job_request_id) REFERENCES rh.job_requests(id) ON DELETE SET NULL;


--
-- Name: job_requests job_requests_approved_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_requests
    ADD CONSTRAINT job_requests_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES auth.users(id);


--
-- Name: job_requests job_requests_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_requests
    ADD CONSTRAINT job_requests_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: job_requests job_requests_requested_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.job_requests
    ADD CONSTRAINT job_requests_requested_by_fkey FOREIGN KEY (requested_by) REFERENCES auth.users(id);


--
-- Name: medical_agreements medical_agreements_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_agreements
    ADD CONSTRAINT medical_agreements_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: medical_certificate_attachments medical_certificate_attachments_certificate_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificate_attachments
    ADD CONSTRAINT medical_certificate_attachments_certificate_id_fkey FOREIGN KEY (certificate_id) REFERENCES rh.medical_certificates(id) ON DELETE CASCADE;


--
-- Name: medical_certificate_attachments medical_certificate_attachments_uploaded_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificate_attachments
    ADD CONSTRAINT medical_certificate_attachments_uploaded_by_fkey FOREIGN KEY (uploaded_by) REFERENCES auth.users(id);


--
-- Name: medical_certificates medical_certificates_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificates
    ADD CONSTRAINT medical_certificates_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: medical_certificates medical_certificates_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificates
    ADD CONSTRAINT medical_certificates_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: medical_certificates medical_certificates_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_certificates
    ADD CONSTRAINT medical_certificates_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: medical_plan_pricing_history medical_plan_pricing_history_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plan_pricing_history
    ADD CONSTRAINT medical_plan_pricing_history_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.users(id) ON DELETE SET NULL;


--
-- Name: medical_plan_pricing_history medical_plan_pricing_history_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plan_pricing_history
    ADD CONSTRAINT medical_plan_pricing_history_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: medical_plan_pricing_history medical_plan_pricing_history_plan_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plan_pricing_history
    ADD CONSTRAINT medical_plan_pricing_history_plan_id_fkey FOREIGN KEY (plan_id) REFERENCES rh.medical_plans(id) ON DELETE CASCADE;


--
-- Name: medical_plans medical_plans_agreement_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plans
    ADD CONSTRAINT medical_plans_agreement_id_fkey FOREIGN KEY (agreement_id) REFERENCES rh.medical_agreements(id) ON DELETE CASCADE;


--
-- Name: medical_plans medical_plans_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.medical_plans
    ADD CONSTRAINT medical_plans_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: monthly_benefit_processing monthly_benefit_processing_benefit_config_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_benefit_config_id_fkey FOREIGN KEY (benefit_config_id) REFERENCES rh.benefit_configurations(id) ON DELETE CASCADE;


--
-- Name: monthly_benefit_processing monthly_benefit_processing_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: monthly_benefit_processing monthly_benefit_processing_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: monthly_benefit_processing monthly_benefit_processing_processed_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_processed_by_fkey FOREIGN KEY (processed_by) REFERENCES public.profiles(id);


--
-- Name: monthly_benefit_processing monthly_benefit_processing_validated_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.monthly_benefit_processing
    ADD CONSTRAINT monthly_benefit_processing_validated_by_fkey FOREIGN KEY (validated_by) REFERENCES public.profiles(id);


--
-- Name: payroll payroll_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll
    ADD CONSTRAINT payroll_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: payroll_config payroll_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_config
    ADD CONSTRAINT payroll_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: payroll payroll_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll
    ADD CONSTRAINT payroll_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: payroll_events payroll_events_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_events
    ADD CONSTRAINT payroll_events_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: payroll_events payroll_events_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_events
    ADD CONSTRAINT payroll_events_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: payroll_events payroll_events_payroll_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_events
    ADD CONSTRAINT payroll_events_payroll_id_fkey FOREIGN KEY (payroll_id) REFERENCES rh.payroll(id) ON DELETE CASCADE;


--
-- Name: payroll_events payroll_events_rubrica_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.payroll_events
    ADD CONSTRAINT payroll_events_rubrica_id_fkey FOREIGN KEY (rubrica_id) REFERENCES rh.rubricas(id) ON DELETE RESTRICT;


--
-- Name: periodic_exams periodic_exams_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.periodic_exams
    ADD CONSTRAINT periodic_exams_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: periodic_exams periodic_exams_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.periodic_exams
    ADD CONSTRAINT periodic_exams_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: positions positions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.positions
    ADD CONSTRAINT positions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: reimbursement_requests reimbursement_requests_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reimbursement_requests
    ADD CONSTRAINT reimbursement_requests_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: reimbursement_requests reimbursement_requests_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reimbursement_requests
    ADD CONSTRAINT reimbursement_requests_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: reimbursement_requests reimbursement_requests_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reimbursement_requests
    ADD CONSTRAINT reimbursement_requests_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: reimbursement_requests reimbursement_requests_solicitado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reimbursement_requests
    ADD CONSTRAINT reimbursement_requests_solicitado_por_fkey FOREIGN KEY (solicitado_por) REFERENCES public.profiles(id);


--
-- Name: reports reports_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.reports
    ADD CONSTRAINT reports_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: rubricas rubricas_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.rubricas
    ADD CONSTRAINT rubricas_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: schedule_planning schedule_planning_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.schedule_planning
    ADD CONSTRAINT schedule_planning_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: selection_processes selection_processes_candidate_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_processes
    ADD CONSTRAINT selection_processes_candidate_id_fkey FOREIGN KEY (candidate_id) REFERENCES rh.candidates(id) ON DELETE CASCADE;


--
-- Name: selection_processes selection_processes_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_processes
    ADD CONSTRAINT selection_processes_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: selection_processes selection_processes_created_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_processes
    ADD CONSTRAINT selection_processes_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: selection_processes selection_processes_job_opening_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_processes
    ADD CONSTRAINT selection_processes_job_opening_id_fkey FOREIGN KEY (job_opening_id) REFERENCES rh.job_openings(id) ON DELETE CASCADE;


--
-- Name: selection_stages selection_stages_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_stages
    ADD CONSTRAINT selection_stages_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: selection_stages selection_stages_interviewer_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_stages
    ADD CONSTRAINT selection_stages_interviewer_id_fkey FOREIGN KEY (interviewer_id) REFERENCES auth.users(id);


--
-- Name: selection_stages selection_stages_selection_process_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.selection_stages
    ADD CONSTRAINT selection_stages_selection_process_id_fkey FOREIGN KEY (selection_process_id) REFERENCES rh.selection_processes(id) ON DELETE CASCADE;


--
-- Name: signature_notifications signature_notifications_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.signature_notifications
    ADD CONSTRAINT signature_notifications_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: signature_notifications signature_notifications_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.signature_notifications
    ADD CONSTRAINT signature_notifications_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: signature_notifications signature_notifications_signature_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.signature_notifications
    ADD CONSTRAINT signature_notifications_signature_id_fkey FOREIGN KEY (signature_id) REFERENCES rh.time_record_signatures(id) ON DELETE CASCADE;


--
-- Name: talent_pool talent_pool_candidate_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.talent_pool
    ADD CONSTRAINT talent_pool_candidate_id_fkey FOREIGN KEY (candidate_id) REFERENCES rh.candidates(id) ON DELETE CASCADE;


--
-- Name: talent_pool talent_pool_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.talent_pool
    ADD CONSTRAINT talent_pool_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: time_bank time_bank_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_bank
    ADD CONSTRAINT time_bank_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES auth.users(id);


--
-- Name: time_bank time_bank_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_bank
    ADD CONSTRAINT time_bank_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: time_bank time_bank_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_bank
    ADD CONSTRAINT time_bank_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: time_record_signature_config time_record_signature_config_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signature_config
    ADD CONSTRAINT time_record_signature_config_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: time_record_signatures time_record_signatures_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signatures
    ADD CONSTRAINT time_record_signatures_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: time_record_signatures time_record_signatures_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signatures
    ADD CONSTRAINT time_record_signatures_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: time_record_signatures time_record_signatures_manager_approved_by_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_record_signatures
    ADD CONSTRAINT time_record_signatures_manager_approved_by_fkey FOREIGN KEY (manager_approved_by) REFERENCES public.users(id);


--
-- Name: time_records time_records_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_records
    ADD CONSTRAINT time_records_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: time_records time_records_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_records
    ADD CONSTRAINT time_records_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: time_records time_records_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.time_records
    ADD CONSTRAINT time_records_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_attendance training_attendance_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_attendance training_attendance_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_attendance training_attendance_registrado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_registrado_por_fkey FOREIGN KEY (registrado_por) REFERENCES public.users(id);


--
-- Name: training_attendance training_attendance_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_attendance
    ADD CONSTRAINT training_attendance_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_certificates training_certificates_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_certificates training_certificates_emitido_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_emitido_por_fkey FOREIGN KEY (emitido_por) REFERENCES public.users(id);


--
-- Name: training_certificates training_certificates_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_certificates training_certificates_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_certificates
    ADD CONSTRAINT training_certificates_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_enrollments training_enrollments_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.users(id);


--
-- Name: training_enrollments training_enrollments_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_enrollments training_enrollments_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_enrollments training_enrollments_inscrito_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_inscrito_por_fkey FOREIGN KEY (inscrito_por) REFERENCES public.users(id);


--
-- Name: training_enrollments training_enrollments_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_enrollments
    ADD CONSTRAINT training_enrollments_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_evaluations training_evaluations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_evaluations
    ADD CONSTRAINT training_evaluations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_evaluations training_evaluations_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_evaluations
    ADD CONSTRAINT training_evaluations_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_evaluations training_evaluations_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_evaluations
    ADD CONSTRAINT training_evaluations_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_notification_history training_notification_history_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_notification_history training_notification_history_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_notification_history training_notification_history_notification_type_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_notification_type_id_fkey FOREIGN KEY (notification_type_id) REFERENCES rh.training_notification_types(id) ON DELETE CASCADE;


--
-- Name: training_notification_history training_notification_history_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_notification_history training_notification_history_user_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_history
    ADD CONSTRAINT training_notification_history_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: training_notification_queue training_notification_queue_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_notification_queue training_notification_queue_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: training_notification_queue training_notification_queue_notification_type_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_notification_type_id_fkey FOREIGN KEY (notification_type_id) REFERENCES rh.training_notification_types(id) ON DELETE CASCADE;


--
-- Name: training_notification_queue training_notification_queue_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_notification_queue training_notification_queue_user_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_queue
    ADD CONSTRAINT training_notification_queue_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE;


--
-- Name: training_notification_rules training_notification_rules_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_rules
    ADD CONSTRAINT training_notification_rules_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_notification_rules training_notification_rules_notification_type_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_rules
    ADD CONSTRAINT training_notification_rules_notification_type_id_fkey FOREIGN KEY (notification_type_id) REFERENCES rh.training_notification_types(id) ON DELETE CASCADE;


--
-- Name: training_notification_rules training_notification_rules_training_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_rules
    ADD CONSTRAINT training_notification_rules_training_id_fkey FOREIGN KEY (training_id) REFERENCES rh.trainings(id) ON DELETE CASCADE;


--
-- Name: training_notification_types training_notification_types_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_notification_types
    ADD CONSTRAINT training_notification_types_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: training_settings training_settings_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.training_settings
    ADD CONSTRAINT training_settings_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: trainings trainings_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.trainings
    ADD CONSTRAINT trainings_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.users(id);


--
-- Name: trainings trainings_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.trainings
    ADD CONSTRAINT trainings_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: union_contributions union_contributions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_contributions
    ADD CONSTRAINT union_contributions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: union_contributions union_contributions_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_contributions
    ADD CONSTRAINT union_contributions_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: union_contributions union_contributions_union_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_contributions
    ADD CONSTRAINT union_contributions_union_id_fkey FOREIGN KEY (union_id) REFERENCES rh.unions(id) ON DELETE CASCADE;


--
-- Name: union_negotiations union_negotiations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_negotiations
    ADD CONSTRAINT union_negotiations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: union_negotiations union_negotiations_union_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_negotiations
    ADD CONSTRAINT union_negotiations_union_id_fkey FOREIGN KEY (union_id) REFERENCES rh.unions(id) ON DELETE CASCADE;


--
-- Name: union_representatives union_representatives_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_representatives
    ADD CONSTRAINT union_representatives_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: union_representatives union_representatives_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_representatives
    ADD CONSTRAINT union_representatives_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: union_representatives union_representatives_union_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.union_representatives
    ADD CONSTRAINT union_representatives_union_id_fkey FOREIGN KEY (union_id) REFERENCES rh.unions(id) ON DELETE CASCADE;


--
-- Name: unions unions_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.unions
    ADD CONSTRAINT unions_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: units units_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.units
    ADD CONSTRAINT units_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: units units_cost_center_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.units
    ADD CONSTRAINT units_cost_center_id_fkey FOREIGN KEY (cost_center_id) REFERENCES public.cost_centers(id) ON DELETE SET NULL;


--
-- Name: units units_responsavel_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.units
    ADD CONSTRAINT units_responsavel_id_fkey FOREIGN KEY (responsavel_id) REFERENCES rh.employees(id);


--
-- Name: vacation_entitlements vacation_entitlements_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_entitlements
    ADD CONSTRAINT vacation_entitlements_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: vacation_entitlements vacation_entitlements_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_entitlements
    ADD CONSTRAINT vacation_entitlements_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: vacation_periods vacation_periods_vacation_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacation_periods
    ADD CONSTRAINT vacation_periods_vacation_id_fkey FOREIGN KEY (vacation_id) REFERENCES rh.vacations(id) ON DELETE CASCADE;


--
-- Name: vacations vacations_aprovado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacations
    ADD CONSTRAINT vacations_aprovado_por_fkey FOREIGN KEY (aprovado_por) REFERENCES public.profiles(id);


--
-- Name: vacations vacations_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacations
    ADD CONSTRAINT vacations_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: vacations vacations_employee_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacations
    ADD CONSTRAINT vacations_employee_id_fkey FOREIGN KEY (employee_id) REFERENCES rh.employees(id) ON DELETE CASCADE;


--
-- Name: vacations vacations_solicitado_por_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.vacations
    ADD CONSTRAINT vacations_solicitado_por_fkey FOREIGN KEY (solicitado_por) REFERENCES public.profiles(id);


--
-- Name: work_schedules work_schedules_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.work_schedules
    ADD CONSTRAINT work_schedules_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: work_shifts work_shifts_company_id_fkey; Type: FK CONSTRAINT; Schema: rh; Owner: postgres
--

ALTER TABLE ONLY rh.work_shifts
    ADD CONSTRAINT work_shifts_company_id_fkey FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;


--
-- Name: objects objects_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: prefixes prefixes_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT "prefixes_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_upload_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE;


--
-- Name: solicitacoes_saida_materiais_itens Users can manage material exit request items for their company; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY "Users can manage material exit request items for their company" ON almoxarifado.solicitacoes_saida_materiais_itens USING ((solicitacao_id IN ( SELECT ss.id
   FROM ((almoxarifado.solicitacoes_saida_materiais ss
     JOIN public.companies c ON ((ss.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((solicitacao_id IN ( SELECT ss.id
   FROM ((almoxarifado.solicitacoes_saida_materiais ss
     JOIN public.companies c ON ((ss.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: solicitacoes_saida_materiais Users can manage material exit requests for their company; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY "Users can manage material exit requests for their company" ON almoxarifado.solicitacoes_saida_materiais USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: solicitacoes_saida_materiais_itens Users can view material exit request items for their company; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY "Users can view material exit request items for their company" ON almoxarifado.solicitacoes_saida_materiais_itens FOR SELECT USING ((solicitacao_id IN ( SELECT ss.id
   FROM ((almoxarifado.solicitacoes_saida_materiais ss
     JOIN public.companies c ON ((ss.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: solicitacoes_saida_materiais Users can view material exit requests for their company; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY "Users can view material exit requests for their company" ON almoxarifado.solicitacoes_saida_materiais FOR SELECT USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: almoxarifados; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.almoxarifados ENABLE ROW LEVEL SECURITY;

--
-- Name: almoxarifados almoxarifados_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY almoxarifados_company_isolation ON almoxarifado.almoxarifados USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: almoxarifados almoxarifados_delete_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY almoxarifados_delete_policy ON almoxarifado.almoxarifados FOR DELETE USING (almoxarifado.check_module_permission('delete'::text));


--
-- Name: almoxarifados almoxarifados_insert_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY almoxarifados_insert_policy ON almoxarifado.almoxarifados FOR INSERT WITH CHECK (almoxarifado.check_module_permission('create'::text));


--
-- Name: almoxarifados almoxarifados_select_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY almoxarifados_select_policy ON almoxarifado.almoxarifados FOR SELECT USING (almoxarifado.check_module_permission('read'::text));


--
-- Name: almoxarifados almoxarifados_update_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY almoxarifados_update_policy ON almoxarifado.almoxarifados FOR UPDATE USING (almoxarifado.check_module_permission('edit'::text));


--
-- Name: checklist_recebimento; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.checklist_recebimento ENABLE ROW LEVEL SECURITY;

--
-- Name: checklist_recebimento checklist_recebimento_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY checklist_recebimento_company_isolation ON almoxarifado.checklist_recebimento USING ((entrada_id IN ( SELECT e.id
   FROM ((almoxarifado.entradas_materiais e
     JOIN public.companies c ON ((e.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((entrada_id IN ( SELECT e.id
   FROM ((almoxarifado.entradas_materiais e
     JOIN public.companies c ON ((e.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: entrada_itens; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.entrada_itens ENABLE ROW LEVEL SECURITY;

--
-- Name: entrada_itens entrada_itens_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY entrada_itens_company_isolation ON almoxarifado.entrada_itens USING ((entrada_id IN ( SELECT e.id
   FROM ((almoxarifado.entradas_materiais e
     JOIN public.companies c ON ((e.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((entrada_id IN ( SELECT e.id
   FROM ((almoxarifado.entradas_materiais e
     JOIN public.companies c ON ((e.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: entradas_materiais; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.entradas_materiais ENABLE ROW LEVEL SECURITY;

--
-- Name: entradas_materiais entradas_materiais_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY entradas_materiais_company_isolation ON almoxarifado.entradas_materiais USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: estoque_atual; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.estoque_atual ENABLE ROW LEVEL SECURITY;

--
-- Name: estoque_atual estoque_atual_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY estoque_atual_company_isolation ON almoxarifado.estoque_atual USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: estoque_atual estoque_atual_select_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY estoque_atual_select_policy ON almoxarifado.estoque_atual FOR SELECT USING (almoxarifado.check_module_permission('read'::text));


--
-- Name: estoque_atual estoque_atual_update_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY estoque_atual_update_policy ON almoxarifado.estoque_atual FOR UPDATE USING (almoxarifado.check_module_permission('edit'::text));


--
-- Name: inventario_itens; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.inventario_itens ENABLE ROW LEVEL SECURITY;

--
-- Name: inventario_itens inventario_itens_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY inventario_itens_company_isolation ON almoxarifado.inventario_itens USING ((inventario_id IN ( SELECT i.id
   FROM ((almoxarifado.inventarios i
     JOIN public.companies c ON ((i.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((inventario_id IN ( SELECT i.id
   FROM ((almoxarifado.inventarios i
     JOIN public.companies c ON ((i.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: inventarios; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.inventarios ENABLE ROW LEVEL SECURITY;

--
-- Name: inventarios inventarios_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY inventarios_company_isolation ON almoxarifado.inventarios USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: localizacoes_fisicas; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.localizacoes_fisicas ENABLE ROW LEVEL SECURITY;

--
-- Name: localizacoes_fisicas localizacoes_fisicas_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY localizacoes_fisicas_company_isolation ON almoxarifado.localizacoes_fisicas USING ((almoxarifado_id IN ( SELECT a.id
   FROM ((almoxarifado.almoxarifados a
     JOIN public.companies c ON ((a.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((almoxarifado_id IN ( SELECT a.id
   FROM ((almoxarifado.almoxarifados a
     JOIN public.companies c ON ((a.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: materiais_equipamentos; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.materiais_equipamentos ENABLE ROW LEVEL SECURITY;

--
-- Name: materiais_equipamentos materiais_equipamentos_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY materiais_equipamentos_company_isolation ON almoxarifado.materiais_equipamentos USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: materiais_equipamentos materiais_equipamentos_delete_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY materiais_equipamentos_delete_policy ON almoxarifado.materiais_equipamentos FOR DELETE USING (almoxarifado.check_module_permission('delete'::text));


--
-- Name: materiais_equipamentos materiais_equipamentos_insert_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY materiais_equipamentos_insert_policy ON almoxarifado.materiais_equipamentos FOR INSERT WITH CHECK (almoxarifado.check_module_permission('create'::text));


--
-- Name: materiais_equipamentos materiais_equipamentos_select_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY materiais_equipamentos_select_policy ON almoxarifado.materiais_equipamentos FOR SELECT USING (almoxarifado.check_module_permission('read'::text));


--
-- Name: materiais_equipamentos materiais_equipamentos_update_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY materiais_equipamentos_update_policy ON almoxarifado.materiais_equipamentos FOR UPDATE USING (almoxarifado.check_module_permission('edit'::text));


--
-- Name: movimentacoes_estoque; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.movimentacoes_estoque ENABLE ROW LEVEL SECURITY;

--
-- Name: movimentacoes_estoque movimentacoes_estoque_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY movimentacoes_estoque_company_isolation ON almoxarifado.movimentacoes_estoque USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: movimentacoes_estoque movimentacoes_estoque_insert_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY movimentacoes_estoque_insert_policy ON almoxarifado.movimentacoes_estoque FOR INSERT WITH CHECK (almoxarifado.check_module_permission('create'::text));


--
-- Name: movimentacoes_estoque movimentacoes_estoque_select_policy; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY movimentacoes_estoque_select_policy ON almoxarifado.movimentacoes_estoque FOR SELECT USING (almoxarifado.check_module_permission('read'::text));


--
-- Name: solicitacoes_compra; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.solicitacoes_compra ENABLE ROW LEVEL SECURITY;

--
-- Name: solicitacoes_compra solicitacoes_compra_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY solicitacoes_compra_company_isolation ON almoxarifado.solicitacoes_compra USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: solicitacoes_saida_materiais; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.solicitacoes_saida_materiais ENABLE ROW LEVEL SECURITY;

--
-- Name: solicitacoes_saida_materiais_itens; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.solicitacoes_saida_materiais_itens ENABLE ROW LEVEL SECURITY;

--
-- Name: transferencia_itens; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.transferencia_itens ENABLE ROW LEVEL SECURITY;

--
-- Name: transferencia_itens transferencia_itens_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY transferencia_itens_company_isolation ON almoxarifado.transferencia_itens USING ((transferencia_id IN ( SELECT t.id
   FROM ((almoxarifado.transferencias t
     JOIN public.companies c ON ((t.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((transferencia_id IN ( SELECT t.id
   FROM ((almoxarifado.transferencias t
     JOIN public.companies c ON ((t.company_id = c.id)))
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: transferencias; Type: ROW SECURITY; Schema: almoxarifado; Owner: postgres
--

ALTER TABLE almoxarifado.transferencias ENABLE ROW LEVEL SECURITY;

--
-- Name: transferencias transferencias_company_isolation; Type: POLICY; Schema: almoxarifado; Owner: postgres
--

CREATE POLICY transferencias_company_isolation ON almoxarifado.transferencias USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: audit_log_entries; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.audit_log_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: flow_state; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.flow_state ENABLE ROW LEVEL SECURITY;

--
-- Name: identities; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

--
-- Name: instances; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.instances ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_amr_claims; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_challenges; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_factors; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_factors ENABLE ROW LEVEL SECURITY;

--
-- Name: one_time_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.one_time_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: refresh_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_relay_states; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_relay_states ENABLE ROW LEVEL SECURITY;

--
-- Name: schema_migrations; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.schema_migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: sessions; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_domains; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_domains ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

--
-- Name: contas_pagar Users can create contas_pagar in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can create contas_pagar in their companies" ON financeiro.contas_pagar FOR INSERT WITH CHECK (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'create'::text)));


--
-- Name: contas_receber Users can create contas_receber in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can create contas_receber in their companies" ON financeiro.contas_receber FOR INSERT WITH CHECK (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'create'::text)));


--
-- Name: configuracao_bancaria Users can delete bank configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can delete bank configs from their companies" ON financeiro.configuracao_bancaria FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: contas_pagar Users can delete contas_pagar in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can delete contas_pagar in their companies" ON financeiro.contas_pagar FOR DELETE USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'delete'::text)));


--
-- Name: contas_receber Users can delete contas_receber in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can delete contas_receber in their companies" ON financeiro.contas_receber FOR DELETE USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'delete'::text)));


--
-- Name: configuracao_fiscal Users can delete fiscal configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can delete fiscal configs from their companies" ON financeiro.configuracao_fiscal FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: configuracao_bancaria Users can insert bank configs for their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can insert bank configs for their companies" ON financeiro.configuracao_bancaria FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: configuracao_fiscal Users can insert fiscal configs for their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can insert fiscal configs for their companies" ON financeiro.configuracao_fiscal FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: log_validacao_integracao Users can insert validation logs for their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can insert validation logs for their companies" ON financeiro.log_validacao_integracao FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: aprovacoes Users can manage aprovacoes in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage aprovacoes in their companies" ON financeiro.aprovacoes USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: borderos Users can manage borderos in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage borderos in their companies" ON financeiro.borderos USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: conciliacoes_bancarias Users can manage conciliacoes_bancarias in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage conciliacoes_bancarias in their companies" ON financeiro.conciliacoes_bancarias USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: configuracoes_aprovacao Users can manage configuracoes_aprovacao in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage configuracoes_aprovacao in their companies" ON financeiro.configuracoes_aprovacao USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: contas_bancarias Users can manage contas_bancarias in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage contas_bancarias in their companies" ON financeiro.contas_bancarias USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: fluxo_caixa Users can manage fluxo_caixa in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage fluxo_caixa in their companies" ON financeiro.fluxo_caixa USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: lancamentos_contabeis Users can manage lancamentos_contabeis in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage lancamentos_contabeis in their companies" ON financeiro.lancamentos_contabeis USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: nfe Users can manage nfe in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage nfe in their companies" ON financeiro.nfe USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: nfse Users can manage nfse in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage nfse in their companies" ON financeiro.nfse USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: plano_contas Users can manage plano_contas in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage plano_contas in their companies" ON financeiro.plano_contas USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: remessas_bancarias Users can manage remessas_bancarias in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage remessas_bancarias in their companies" ON financeiro.remessas_bancarias USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: retornos_bancarios Users can manage retornos_bancarios in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can manage retornos_bancarios in their companies" ON financeiro.retornos_bancarios USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: configuracao_bancaria Users can update bank configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can update bank configs from their companies" ON financeiro.configuracao_bancaria FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: contas_pagar Users can update contas_pagar in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can update contas_pagar in their companies" ON financeiro.contas_pagar FOR UPDATE USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: contas_receber Users can update contas_receber in their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can update contas_receber in their companies" ON financeiro.contas_receber FOR UPDATE USING (((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) AND financeiro.check_financial_permission(auth.uid(), 'edit'::text)));


--
-- Name: configuracao_fiscal Users can update fiscal configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can update fiscal configs from their companies" ON financeiro.configuracao_fiscal FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: aprovacoes Users can view aprovacoes of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view aprovacoes of their companies" ON financeiro.aprovacoes FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: configuracao_bancaria Users can view bank configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view bank configs from their companies" ON financeiro.configuracao_bancaria FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: borderos Users can view borderos of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view borderos of their companies" ON financeiro.borderos FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: conciliacoes_bancarias Users can view conciliacoes_bancarias of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view conciliacoes_bancarias of their companies" ON financeiro.conciliacoes_bancarias FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: configuracoes_aprovacao Users can view configuracoes_aprovacao of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view configuracoes_aprovacao of their companies" ON financeiro.configuracoes_aprovacao FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: contas_bancarias Users can view contas_bancarias of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view contas_bancarias of their companies" ON financeiro.contas_bancarias FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: contas_pagar Users can view contas_pagar of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view contas_pagar of their companies" ON financeiro.contas_pagar FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: contas_receber Users can view contas_receber of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view contas_receber of their companies" ON financeiro.contas_receber FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: configuracao_fiscal Users can view fiscal configs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view fiscal configs from their companies" ON financeiro.configuracao_fiscal FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: fluxo_caixa Users can view fluxo_caixa of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view fluxo_caixa of their companies" ON financeiro.fluxo_caixa FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: lancamentos_contabeis Users can view lancamentos_contabeis of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view lancamentos_contabeis of their companies" ON financeiro.lancamentos_contabeis FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: nfe Users can view nfe of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view nfe of their companies" ON financeiro.nfe FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: nfse Users can view nfse of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view nfse of their companies" ON financeiro.nfse FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: plano_contas Users can view plano_contas of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view plano_contas of their companies" ON financeiro.plano_contas FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: remessas_bancarias Users can view remessas_bancarias of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view remessas_bancarias of their companies" ON financeiro.remessas_bancarias FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: retornos_bancarios Users can view retornos_bancarios of their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view retornos_bancarios of their companies" ON financeiro.retornos_bancarios FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: log_validacao_integracao Users can view validation logs from their companies; Type: POLICY; Schema: financeiro; Owner: postgres
--

CREATE POLICY "Users can view validation logs from their companies" ON financeiro.log_validacao_integracao FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: aprovacoes; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.aprovacoes ENABLE ROW LEVEL SECURITY;

--
-- Name: borderos; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.borderos ENABLE ROW LEVEL SECURITY;

--
-- Name: conciliacoes_bancarias; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.conciliacoes_bancarias ENABLE ROW LEVEL SECURITY;

--
-- Name: configuracao_bancaria; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.configuracao_bancaria ENABLE ROW LEVEL SECURITY;

--
-- Name: configuracao_fiscal; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.configuracao_fiscal ENABLE ROW LEVEL SECURITY;

--
-- Name: configuracoes_aprovacao; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.configuracoes_aprovacao ENABLE ROW LEVEL SECURITY;

--
-- Name: contas_bancarias; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.contas_bancarias ENABLE ROW LEVEL SECURITY;

--
-- Name: contas_pagar; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.contas_pagar ENABLE ROW LEVEL SECURITY;

--
-- Name: contas_receber; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.contas_receber ENABLE ROW LEVEL SECURITY;

--
-- Name: fluxo_caixa; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.fluxo_caixa ENABLE ROW LEVEL SECURITY;

--
-- Name: lancamentos_contabeis; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.lancamentos_contabeis ENABLE ROW LEVEL SECURITY;

--
-- Name: log_validacao_integracao; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.log_validacao_integracao ENABLE ROW LEVEL SECURITY;

--
-- Name: nfe; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.nfe ENABLE ROW LEVEL SECURITY;

--
-- Name: nfse; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.nfse ENABLE ROW LEVEL SECURITY;

--
-- Name: plano_contas; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.plano_contas ENABLE ROW LEVEL SECURITY;

--
-- Name: remessas_bancarias; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.remessas_bancarias ENABLE ROW LEVEL SECURITY;

--
-- Name: retornos_bancarios; Type: ROW SECURITY; Schema: financeiro; Owner: postgres
--

ALTER TABLE financeiro.retornos_bancarios ENABLE ROW LEVEL SECURITY;

--
-- Name: companies Admins can insert companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert companies" ON public.companies FOR INSERT WITH CHECK (public.is_admin(auth.uid()));


--
-- Name: users Admins can insert users; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can insert users" ON public.users FOR INSERT WITH CHECK (public.is_admin(auth.uid()));


--
-- Name: companies Admins can manage companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage companies" ON public.companies USING (public.is_admin(auth.uid()));


--
-- Name: cost_centers Admins can manage cost centers; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage cost centers" ON public.cost_centers USING (public.is_admin(auth.uid()));


--
-- Name: module_permissions Admins can manage module permissions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage module permissions" ON public.module_permissions USING (public.is_admin_simple(auth.uid()));


--
-- Name: partners Admins can manage partners; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage partners" ON public.partners USING (public.is_admin(auth.uid()));


--
-- Name: profiles Admins can manage profiles; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage profiles" ON public.profiles USING (public.is_admin_simple(auth.uid()));


--
-- Name: projects Admins can manage projects; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage projects" ON public.projects USING (public.is_admin(auth.uid()));


--
-- Name: user_companies Admins can manage user companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage user companies" ON public.user_companies USING (public.is_admin(auth.uid()));


--
-- Name: user_companies Admins can manage user_companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage user_companies" ON public.user_companies USING (public.is_admin(auth.uid()));


--
-- Name: users Admins can manage users; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can manage users" ON public.users USING (public.is_admin(auth.uid()));


--
-- Name: companies Admins can update companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Admins can update companies" ON public.companies FOR UPDATE USING (public.is_admin(auth.uid()));


--
-- Name: entity_permissions Authenticated users can access entity permissions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Authenticated users can access entity permissions" ON public.entity_permissions USING (((auth.uid() IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM (public.user_companies uc
     JOIN public.profiles p ON ((uc.profile_id = p.id)))
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true) AND (p.is_active = true))))));


--
-- Name: profiles Everyone can view profiles; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Everyone can view profiles" ON public.profiles FOR SELECT TO authenticated USING (true);


--
-- Name: notifications System can create notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "System can create notifications" ON public.notifications FOR INSERT WITH CHECK (true);


--
-- Name: configuracoes_aprovacao_unificada Users can create approval configs for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create approval configs for their company" ON public.configuracoes_aprovacao_unificada FOR INSERT WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: historico_edicoes_solicitacoes Users can create edit history for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can create edit history for their company" ON public.historico_edicoes_solicitacoes FOR INSERT WITH CHECK ((company_id = ( SELECT (current_setting('app.current_company_id'::text))::uuid AS current_setting)));


--
-- Name: configuracoes_aprovacao_unificada Users can delete approval configs for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can delete approval configs for their company" ON public.configuracoes_aprovacao_unificada FOR DELETE USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: aprovacoes_unificada Users can manage approvals for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage approvals for their company" ON public.aprovacoes_unificada USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: cost_centers Users can manage cost centers of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage cost centers of their companies" ON public.cost_centers USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: cost_centers Users can manage cost_centers of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage cost_centers of their companies" ON public.cost_centers USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: partners Users can manage partners of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage partners of their companies" ON public.partners USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: projects Users can manage projects of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can manage projects of their companies" ON public.projects USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: configuracoes_aprovacao_unificada Users can update approval configs for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update approval configs for their company" ON public.configuracoes_aprovacao_unificada FOR UPDATE USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid())))) WITH CHECK ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: users Users can update their own data; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own data" ON public.users FOR UPDATE USING (((id = auth.uid()) OR public.is_admin(auth.uid())));


--
-- Name: notifications Users can update their own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own notifications" ON public.notifications FOR UPDATE USING (((user_id = auth.uid()) AND (company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true))))));


--
-- Name: users Users can update their own profile; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can update their own profile" ON public.users FOR UPDATE USING ((auth.uid() = id));


--
-- Name: users Users can view all users; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view all users" ON public.users FOR SELECT TO authenticated USING (true);


--
-- Name: configuracoes_aprovacao_unificada Users can view approval configs for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view approval configs for their company" ON public.configuracoes_aprovacao_unificada FOR SELECT USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: aprovacoes_unificada Users can view approvals for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view approvals for their company" ON public.aprovacoes_unificada FOR SELECT USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: companies Users can view companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view companies" ON public.companies FOR SELECT USING (true);


--
-- Name: cost_centers Users can view cost centers of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view cost centers of their companies" ON public.cost_centers FOR SELECT USING ((company_id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: cost_centers Users can view cost_centers of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view cost_centers of their companies" ON public.cost_centers FOR SELECT USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: historico_edicoes_solicitacoes Users can view edit history for their company; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view edit history for their company" ON public.historico_edicoes_solicitacoes FOR SELECT USING ((company_id IN ( SELECT c.id
   FROM (public.companies c
     JOIN public.user_companies uc ON ((c.id = uc.company_id)))
  WHERE (uc.user_id = auth.uid()))));


--
-- Name: partners Users can view partners of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view partners of their companies" ON public.partners FOR SELECT USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: profiles Users can view profiles; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view profiles" ON public.profiles FOR SELECT USING (true);


--
-- Name: projects Users can view projects of their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view projects of their companies" ON public.projects FOR SELECT USING (public.user_has_company_access(auth.uid(), company_id));


--
-- Name: companies Users can view their companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their companies" ON public.companies FOR SELECT USING ((public.user_has_company_access(auth.uid(), id) OR public.is_admin(auth.uid())));


--
-- Name: user_companies Users can view their company associations; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their company associations" ON public.user_companies FOR SELECT USING (((user_id = auth.uid()) OR public.is_admin(auth.uid())));


--
-- Name: module_permissions Users can view their module permissions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their module permissions" ON public.module_permissions FOR SELECT USING ((profile_id IN ( SELECT uc.profile_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: companies Users can view their own companies; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own companies" ON public.companies FOR SELECT USING (((id IN ( SELECT uc.company_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))) OR public.is_admin(auth.uid())));


--
-- Name: users Users can view their own data; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own data" ON public.users FOR SELECT USING (((id = auth.uid()) OR public.is_admin(auth.uid())));


--
-- Name: notifications Users can view their own notifications; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own notifications" ON public.notifications FOR SELECT USING (((user_id = auth.uid()) AND (company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true))))));


--
-- Name: module_permissions Users can view their own permissions; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own permissions" ON public.module_permissions FOR SELECT USING ((profile_id IN ( SELECT uc.profile_id
   FROM public.user_companies uc
  WHERE ((uc.user_id = auth.uid()) AND (uc.ativo = true)))));


--
-- Name: user_companies Users can view their own user company relationships; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY "Users can view their own user company relationships" ON public.user_companies FOR SELECT USING (((user_id = auth.uid()) OR public.is_admin(auth.uid())));


--
-- Name: aprovacoes_unificada; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.aprovacoes_unificada ENABLE ROW LEVEL SECURITY;

--
-- Name: companies; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;

--
-- Name: configuracoes_aprovacao_unificada; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.configuracoes_aprovacao_unificada ENABLE ROW LEVEL SECURITY;

--
-- Name: cost_centers; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.cost_centers ENABLE ROW LEVEL SECURITY;

--
-- Name: entity_permissions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.entity_permissions ENABLE ROW LEVEL SECURITY;

--
-- Name: historico_edicoes_solicitacoes; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.historico_edicoes_solicitacoes ENABLE ROW LEVEL SECURITY;

--
-- Name: module_permissions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.module_permissions ENABLE ROW LEVEL SECURITY;

--
-- Name: notifications; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: partners; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.partners ENABLE ROW LEVEL SECURITY;

--
-- Name: profiles; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: projects; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

--
-- Name: user_companies; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.user_companies ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

--
-- Name: messages; Type: ROW SECURITY; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE realtime.messages ENABLE ROW LEVEL SECURITY;

--
-- Name: income_statements Admins can delete income statements; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can delete income statements" ON rh.income_statements FOR DELETE USING (public.is_admin_simple(auth.uid()));


--
-- Name: income_statements Admins can insert income statements; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can insert income statements" ON rh.income_statements FOR INSERT WITH CHECK (public.is_admin_simple(auth.uid()));


--
-- Name: approval_levels Admins can manage approval levels; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can manage approval levels" ON rh.approval_levels USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true) AND (EXISTS ( SELECT 1
           FROM public.profiles
          WHERE ((profiles.id = auth.uid()) AND ((profiles.permissoes ->> 'admin'::text) = 'true'::text))))))));


--
-- Name: approval_level_approvers Admins can manage approvers; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can manage approvers" ON rh.approval_level_approvers USING ((approval_level_id IN ( SELECT approval_levels.id
   FROM rh.approval_levels
  WHERE (approval_levels.company_id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true) AND (EXISTS ( SELECT 1
                   FROM public.profiles
                  WHERE ((profiles.id = auth.uid()) AND ((profiles.permissoes ->> 'admin'::text) = 'true'::text))))))))));


--
-- Name: audit_config Admins can manage audit config; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can manage audit config" ON rh.audit_config USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true) AND (EXISTS ( SELECT 1
           FROM public.profiles
          WHERE ((profiles.id = auth.uid()) AND ((profiles.permissoes ->> 'admin'::text) = 'true'::text))))))));


--
-- Name: income_statements Admins can update income statements; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can update income statements" ON rh.income_statements FOR UPDATE USING (public.is_admin_simple(auth.uid()));


--
-- Name: income_statements Admins can view all income statements; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Admins can view all income statements" ON rh.income_statements FOR SELECT USING (public.is_admin_simple(auth.uid()));


--
-- Name: compensation_approvals Approvers can manage their approvals; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Approvers can manage their approvals" ON rh.compensation_approvals USING (((approver_id = auth.uid()) OR (compensation_request_id IN ( SELECT compensation_requests.id
   FROM rh.compensation_requests
  WHERE (compensation_requests.company_id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true) AND (EXISTS ( SELECT 1
                   FROM public.profiles
                  WHERE ((profiles.id = auth.uid()) AND (((profiles.permissoes ->> 'admin'::text) = 'true'::text) OR ((profiles.permissoes ->> 'manager'::text) = 'true'::text))))))))))));


--
-- Name: periodic_exams Employees can view their own periodic exams; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Employees can view their own periodic exams" ON rh.periodic_exams FOR SELECT USING ((employee_id IN ( SELECT employees.id
   FROM rh.employees
  WHERE (employees.user_id = auth.uid()))));


--
-- Name: POLICY "Employees can view their own periodic exams" ON periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Employees can view their own periodic exams" ON rh.periodic_exams IS 'Permite que colaboradores visualizem apenas seus prÃ³prios exames periÃ³dicos';


--
-- Name: audit_logs System can insert audit logs; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "System can insert audit logs" ON rh.audit_logs FOR INSERT WITH CHECK (true);


--
-- Name: training_notification_queue System can manage notification queue; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "System can manage notification queue" ON rh.training_notification_queue USING (true);


--
-- Name: absence_types Users can delete absence_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete absence_types from their company" ON rh.absence_types FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'absence_types'::text, 'delete'::text)));


--
-- Name: allowance_types Users can delete allowance_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete allowance_types from their company" ON rh.allowance_types FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'allowance_types'::text, 'delete'::text)));


--
-- Name: cid_codes Users can delete cid_codes from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete cid_codes from their company" ON rh.cid_codes FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'cid_codes'::text, 'delete'::text)));


--
-- Name: compensation_requests Users can delete compensation_requests from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete compensation_requests from their company" ON rh.compensation_requests FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'compensation_requests'::text, 'delete'::text)));


--
-- Name: deficiency_types Users can delete deficiency_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete deficiency_types from their company" ON rh.deficiency_types FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'deficiency_types'::text, 'delete'::text)));


--
-- Name: delay_reasons Users can delete delay_reasons from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete delay_reasons from their company" ON rh.delay_reasons FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'delay_reasons'::text, 'delete'::text)));


--
-- Name: dependents Users can delete dependents from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete dependents from their company" ON rh.dependents FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: POLICY "Users can delete dependents from their company" ON dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can delete dependents from their company" ON rh.dependents IS 'Permite excluir dependentes da empresa do usuÃ¡rio';


--
-- Name: disciplinary_actions Users can delete disciplinary actions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete disciplinary actions from their company" ON rh.disciplinary_actions FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'disciplinary_actions'::text, 'delete'::text)));


--
-- Name: POLICY "Users can delete disciplinary actions from their company" ON disciplinary_actions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can delete disciplinary actions from their company" ON rh.disciplinary_actions IS 'Permite excluir ações disciplinares da empresa do usuário';


--
-- Name: employee_shifts Users can delete employee_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete employee_shifts from their company" ON rh.employee_shifts FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employee_shifts'::text, 'delete'::text)));


--
-- Name: employees Users can delete employees from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete employees from their company" ON rh.employees FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: employment_contracts Users can delete employment_contracts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete employment_contracts from their company" ON rh.employment_contracts FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employment_contracts'::text, 'delete'::text)));


--
-- Name: esocial_integrations Users can delete esocial_integrations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete esocial_integrations from their company" ON rh.esocial_integrations FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'esocial_integrations'::text, 'delete'::text)));


--
-- Name: event_consolidations Users can delete event_consolidations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete event_consolidations from their company" ON rh.event_consolidations FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'event_consolidations'::text, 'delete'::text)));


--
-- Name: fgts_config Users can delete fgts_config from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete fgts_config from their company" ON rh.fgts_config FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'fgts_config'::text, 'delete'::text)));


--
-- Name: inss_brackets Users can delete inss_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete inss_brackets from their company" ON rh.inss_brackets FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'inss_brackets'::text, 'delete'::text)));


--
-- Name: irrf_brackets Users can delete irrf_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete irrf_brackets from their company" ON rh.irrf_brackets FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'irrf_brackets'::text, 'delete'::text)));


--
-- Name: medical_certificate_attachments Users can delete medical certificate attachments from their com; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete medical certificate attachments from their com" ON rh.medical_certificate_attachments FOR DELETE USING ((certificate_id IN ( SELECT medical_certificates.id
   FROM rh.medical_certificates
  WHERE (medical_certificates.company_id = ANY (public.get_user_companies())))));


--
-- Name: periodic_exams Users can delete periodic exams from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete periodic exams from their company" ON rh.periodic_exams FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: POLICY "Users can delete periodic exams from their company" ON periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can delete periodic exams from their company" ON rh.periodic_exams IS 'Permite que usuÃ¡rios deletem exames periÃ³dicos da sua empresa';


--
-- Name: positions Users can delete positions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete positions from their company" ON rh.positions FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: reports Users can delete reports from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete reports from their company" ON rh.reports FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'reports'::text, 'delete'::text)));


--
-- Name: rubricas Users can delete rubricas from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete rubricas from their company" ON rh.rubricas FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'rubricas'::text, 'delete'::text)));


--
-- Name: schedule_planning Users can delete schedule_planning from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete schedule_planning from their company" ON rh.schedule_planning FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'schedule_planning'::text, 'delete'::text)));


--
-- Name: training_settings Users can delete training settings for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete training settings for their company" ON rh.training_settings FOR DELETE USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: units Users can delete units from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete units from their company" ON rh.units FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: work_shifts Users can delete work_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can delete work_shifts from their company" ON rh.work_shifts FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'work_shifts'::text, 'delete'::text)));


--
-- Name: absence_types Users can insert absence_types in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert absence_types in their company" ON rh.absence_types FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'absence_types'::text, 'create'::text)));


--
-- Name: allowance_types Users can insert allowance_types in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert allowance_types in their company" ON rh.allowance_types FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'allowance_types'::text, 'create'::text)));


--
-- Name: cid_codes Users can insert cid_codes in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert cid_codes in their company" ON rh.cid_codes FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'cid_codes'::text, 'create'::text)));


--
-- Name: compensation_requests Users can insert compensation_requests in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert compensation_requests in their company" ON rh.compensation_requests FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'compensation_requests'::text, 'create'::text)));


--
-- Name: deficiency_types Users can insert deficiency_types in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert deficiency_types in their company" ON rh.deficiency_types FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'deficiency_types'::text, 'create'::text)));


--
-- Name: delay_reasons Users can insert delay_reasons in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert delay_reasons in their company" ON rh.delay_reasons FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'delay_reasons'::text, 'create'::text)));


--
-- Name: dependents Users can insert dependents in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert dependents in their company" ON rh.dependents FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: POLICY "Users can insert dependents in their company" ON dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can insert dependents in their company" ON rh.dependents IS 'Permite inserir dependentes na empresa do usuÃ¡rio';


--
-- Name: disciplinary_actions Users can insert disciplinary actions in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert disciplinary actions in their company" ON rh.disciplinary_actions FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'disciplinary_actions'::text, 'create'::text)));


--
-- Name: POLICY "Users can insert disciplinary actions in their company" ON disciplinary_actions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can insert disciplinary actions in their company" ON rh.disciplinary_actions IS 'Permite criar ações disciplinares na empresa do usuário';


--
-- Name: employee_shifts Users can insert employee_shifts in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert employee_shifts in their company" ON rh.employee_shifts FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employee_shifts'::text, 'create'::text)));


--
-- Name: employees Users can insert employees in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert employees in their company" ON rh.employees FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: employment_contracts Users can insert employment_contracts in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert employment_contracts in their company" ON rh.employment_contracts FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employment_contracts'::text, 'create'::text)));


--
-- Name: esocial_integrations Users can insert esocial_integrations in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert esocial_integrations in their company" ON rh.esocial_integrations FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'esocial_integrations'::text, 'create'::text)));


--
-- Name: event_consolidations Users can insert event_consolidations in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert event_consolidations in their company" ON rh.event_consolidations FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'event_consolidations'::text, 'create'::text)));


--
-- Name: fgts_config Users can insert fgts_config in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert fgts_config in their company" ON rh.fgts_config FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'fgts_config'::text, 'create'::text)));


--
-- Name: inss_brackets Users can insert inss_brackets in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert inss_brackets in their company" ON rh.inss_brackets FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'inss_brackets'::text, 'create'::text)));


--
-- Name: irrf_brackets Users can insert irrf_brackets in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert irrf_brackets in their company" ON rh.irrf_brackets FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'irrf_brackets'::text, 'create'::text)));


--
-- Name: medical_certificate_attachments Users can insert medical certificate attachments in their compa; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert medical certificate attachments in their compa" ON rh.medical_certificate_attachments FOR INSERT WITH CHECK ((certificate_id IN ( SELECT medical_certificates.id
   FROM rh.medical_certificates
  WHERE (medical_certificates.company_id = ANY (public.get_user_companies())))));


--
-- Name: signature_notifications Users can insert notifications for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert notifications for their company" ON rh.signature_notifications FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: periodic_exams Users can insert periodic exams in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert periodic exams in their company" ON rh.periodic_exams FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: POLICY "Users can insert periodic exams in their company" ON periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can insert periodic exams in their company" ON rh.periodic_exams IS 'Permite que usuÃ¡rios insiram exames periÃ³dicos na sua empresa';


--
-- Name: positions Users can insert positions in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert positions in their company" ON rh.positions FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: reports Users can insert reports in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert reports in their company" ON rh.reports FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'reports'::text, 'create'::text)));


--
-- Name: rubricas Users can insert rubricas in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert rubricas in their company" ON rh.rubricas FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'rubricas'::text, 'create'::text)));


--
-- Name: schedule_planning Users can insert schedule_planning in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert schedule_planning in their company" ON rh.schedule_planning FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'schedule_planning'::text, 'create'::text)));


--
-- Name: time_record_signature_config Users can insert signature config for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert signature config for their company" ON rh.time_record_signature_config FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: time_record_signatures Users can insert signatures for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert signatures for their company" ON rh.time_record_signatures FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: training_settings Users can insert training settings for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert training settings for their company" ON rh.training_settings FOR INSERT WITH CHECK ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: units Users can insert units in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert units in their company" ON rh.units FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: work_shifts Users can insert work_shifts in their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can insert work_shifts in their company" ON rh.work_shifts FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'work_shifts'::text, 'create'::text)));


--
-- Name: bank_hours_balance Users can manage bank hours balance for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage bank hours balance for their companies" ON rh.bank_hours_balance USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_calculations Users can manage bank hours calculations for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage bank hours calculations for their companies" ON rh.bank_hours_calculations USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_config Users can manage bank hours config for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage bank hours config for their companies" ON rh.bank_hours_config USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_transactions Users can manage bank hours transactions for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage bank hours transactions for their companies" ON rh.bank_hours_transactions USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_notification_rules Users can manage notification rules of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage notification rules of their company" ON rh.training_notification_rules USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'training_notification_rules'::text, 'manage'::text)));


--
-- Name: training_notification_types Users can manage notification types of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can manage notification types of their company" ON rh.training_notification_types USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'training_notification_types'::text, 'manage'::text)));


--
-- Name: absence_types Users can update absence_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update absence_types from their company" ON rh.absence_types FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'absence_types'::text, 'edit'::text)));


--
-- Name: allowance_types Users can update allowance_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update allowance_types from their company" ON rh.allowance_types FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'allowance_types'::text, 'edit'::text)));


--
-- Name: cid_codes Users can update cid_codes from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update cid_codes from their company" ON rh.cid_codes FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'cid_codes'::text, 'edit'::text)));


--
-- Name: compensation_requests Users can update compensation_requests from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update compensation_requests from their company" ON rh.compensation_requests FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'compensation_requests'::text, 'edit'::text)));


--
-- Name: deficiency_types Users can update deficiency_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update deficiency_types from their company" ON rh.deficiency_types FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'deficiency_types'::text, 'edit'::text)));


--
-- Name: delay_reasons Users can update delay_reasons from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update delay_reasons from their company" ON rh.delay_reasons FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'delay_reasons'::text, 'edit'::text)));


--
-- Name: dependents Users can update dependents from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update dependents from their company" ON rh.dependents FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: POLICY "Users can update dependents from their company" ON dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can update dependents from their company" ON rh.dependents IS 'Permite atualizar dependentes da empresa do usuÃ¡rio';


--
-- Name: disciplinary_actions Users can update disciplinary actions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update disciplinary actions from their company" ON rh.disciplinary_actions FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'disciplinary_actions'::text, 'edit'::text)));


--
-- Name: POLICY "Users can update disciplinary actions from their company" ON disciplinary_actions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can update disciplinary actions from their company" ON rh.disciplinary_actions IS 'Permite editar ações disciplinares da empresa do usuário';


--
-- Name: employee_shifts Users can update employee_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update employee_shifts from their company" ON rh.employee_shifts FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employee_shifts'::text, 'edit'::text)));


--
-- Name: employees Users can update employees from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update employees from their company" ON rh.employees FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: employment_contracts Users can update employment_contracts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update employment_contracts from their company" ON rh.employment_contracts FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employment_contracts'::text, 'edit'::text)));


--
-- Name: esocial_integrations Users can update esocial_integrations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update esocial_integrations from their company" ON rh.esocial_integrations FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'esocial_integrations'::text, 'edit'::text)));


--
-- Name: event_consolidations Users can update event_consolidations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update event_consolidations from their company" ON rh.event_consolidations FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'event_consolidations'::text, 'edit'::text)));


--
-- Name: fgts_config Users can update fgts_config from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update fgts_config from their company" ON rh.fgts_config FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'fgts_config'::text, 'edit'::text)));


--
-- Name: inss_brackets Users can update inss_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update inss_brackets from their company" ON rh.inss_brackets FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'inss_brackets'::text, 'edit'::text)));


--
-- Name: irrf_brackets Users can update irrf_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update irrf_brackets from their company" ON rh.irrf_brackets FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'irrf_brackets'::text, 'edit'::text)));


--
-- Name: medical_certificate_attachments Users can update medical certificate attachments from their com; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update medical certificate attachments from their com" ON rh.medical_certificate_attachments FOR UPDATE USING ((certificate_id IN ( SELECT medical_certificates.id
   FROM rh.medical_certificates
  WHERE (medical_certificates.company_id = ANY (public.get_user_companies())))));


--
-- Name: periodic_exams Users can update periodic exams from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update periodic exams from their company" ON rh.periodic_exams FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: POLICY "Users can update periodic exams from their company" ON periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can update periodic exams from their company" ON rh.periodic_exams IS 'Permite que usuÃ¡rios atualizem exames periÃ³dicos da sua empresa';


--
-- Name: positions Users can update positions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update positions from their company" ON rh.positions FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: reports Users can update reports from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update reports from their company" ON rh.reports FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'reports'::text, 'edit'::text)));


--
-- Name: rubricas Users can update rubricas from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update rubricas from their company" ON rh.rubricas FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'rubricas'::text, 'edit'::text)));


--
-- Name: schedule_planning Users can update schedule_planning from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update schedule_planning from their company" ON rh.schedule_planning FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'schedule_planning'::text, 'edit'::text)));


--
-- Name: time_record_signature_config Users can update signature config for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update signature config for their company" ON rh.time_record_signature_config FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: time_record_signatures Users can update signatures for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update signatures for their company" ON rh.time_record_signatures FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: training_settings Users can update training settings for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update training settings for their company" ON rh.training_settings FOR UPDATE USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: units Users can update units from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update units from their company" ON rh.units FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: work_shifts Users can update work_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can update work_shifts from their company" ON rh.work_shifts FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'work_shifts'::text, 'edit'::text)));


--
-- Name: absence_types Users can view absence_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view absence_types from their company" ON rh.absence_types FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'absence_types'::text, 'read'::text)));


--
-- Name: allowance_types Users can view allowance_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view allowance_types from their company" ON rh.allowance_types FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'allowance_types'::text, 'read'::text)));


--
-- Name: approval_levels Users can view approval levels of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view approval levels of their company" ON rh.approval_levels FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: compensation_approvals Users can view approvals of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view approvals of their company" ON rh.compensation_approvals FOR SELECT USING ((compensation_request_id IN ( SELECT compensation_requests.id
   FROM rh.compensation_requests
  WHERE (compensation_requests.company_id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))))));


--
-- Name: approval_level_approvers Users can view approvers of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view approvers of their company" ON rh.approval_level_approvers FOR SELECT USING ((approval_level_id IN ( SELECT approval_levels.id
   FROM rh.approval_levels
  WHERE (approval_levels.company_id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))))));


--
-- Name: audit_logs Users can view audit logs of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view audit logs of their company" ON rh.audit_logs FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_balance Users can view bank hours balance for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view bank hours balance for their companies" ON rh.bank_hours_balance FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_calculations Users can view bank hours calculations for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view bank hours calculations for their companies" ON rh.bank_hours_calculations FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_config Users can view bank hours config for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view bank hours config for their companies" ON rh.bank_hours_config FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: bank_hours_transactions Users can view bank hours transactions for their companies; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view bank hours transactions for their companies" ON rh.bank_hours_transactions FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: cid_codes Users can view cid_codes from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view cid_codes from their company" ON rh.cid_codes FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'cid_codes'::text, 'read'::text)));


--
-- Name: compensation_requests Users can view compensation_requests from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view compensation_requests from their company" ON rh.compensation_requests FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'compensation_requests'::text, 'read'::text)));


--
-- Name: deficiency_types Users can view deficiency_types from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view deficiency_types from their company" ON rh.deficiency_types FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'deficiency_types'::text, 'read'::text)));


--
-- Name: delay_reasons Users can view delay_reasons from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view delay_reasons from their company" ON rh.delay_reasons FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'delay_reasons'::text, 'read'::text)));


--
-- Name: dependents Users can view dependents from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view dependents from their company" ON rh.dependents FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: POLICY "Users can view dependents from their company" ON dependents; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can view dependents from their company" ON rh.dependents IS 'Permite visualizar dependentes da empresa do usuÃ¡rio';


--
-- Name: disciplinary_actions Users can view disciplinary actions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view disciplinary actions from their company" ON rh.disciplinary_actions FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'disciplinary_actions'::text, 'read'::text)));


--
-- Name: POLICY "Users can view disciplinary actions from their company" ON disciplinary_actions; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can view disciplinary actions from their company" ON rh.disciplinary_actions IS 'Permite visualizar ações disciplinares da empresa do usuário';


--
-- Name: employee_shifts Users can view employee_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view employee_shifts from their company" ON rh.employee_shifts FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employee_shifts'::text, 'read'::text)));


--
-- Name: employees Users can view employees from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view employees from their company" ON rh.employees FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: employment_contracts Users can view employment_contracts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view employment_contracts from their company" ON rh.employment_contracts FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employment_contracts'::text, 'read'::text)));


--
-- Name: esocial_integrations Users can view esocial_integrations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view esocial_integrations from their company" ON rh.esocial_integrations FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'esocial_integrations'::text, 'read'::text)));


--
-- Name: event_consolidations Users can view event_consolidations from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view event_consolidations from their company" ON rh.event_consolidations FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'event_consolidations'::text, 'read'::text)));


--
-- Name: fgts_config Users can view fgts_config from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view fgts_config from their company" ON rh.fgts_config FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'fgts_config'::text, 'read'::text)));


--
-- Name: inss_brackets Users can view inss_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view inss_brackets from their company" ON rh.inss_brackets FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'inss_brackets'::text, 'read'::text)));


--
-- Name: irrf_brackets Users can view irrf_brackets from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view irrf_brackets from their company" ON rh.irrf_brackets FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'irrf_brackets'::text, 'read'::text)));


--
-- Name: medical_certificate_attachments Users can view medical certificate attachments from their compa; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view medical certificate attachments from their compa" ON rh.medical_certificate_attachments FOR SELECT USING ((certificate_id IN ( SELECT medical_certificates.id
   FROM rh.medical_certificates
  WHERE (medical_certificates.company_id = ANY (public.get_user_companies())))));


--
-- Name: training_notification_history Users can view notification history of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view notification history of their company" ON rh.training_notification_history FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'training_notification_history'::text, 'read'::text)));


--
-- Name: training_notification_queue Users can view notification queue of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view notification queue of their company" ON rh.training_notification_queue FOR SELECT USING ((company_id = ANY (public.get_user_companies())));


--
-- Name: training_notification_rules Users can view notification rules of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view notification rules of their company" ON rh.training_notification_rules FOR SELECT USING ((company_id = ANY (public.get_user_companies())));


--
-- Name: training_notification_types Users can view notification types of their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view notification types of their company" ON rh.training_notification_types FOR SELECT USING ((company_id = ANY (public.get_user_companies())));


--
-- Name: signature_notifications Users can view notifications for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view notifications for their company" ON rh.signature_notifications FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: periodic_exams Users can view periodic exams from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view periodic exams from their company" ON rh.periodic_exams FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: POLICY "Users can view periodic exams from their company" ON periodic_exams; Type: COMMENT; Schema: rh; Owner: postgres
--

COMMENT ON POLICY "Users can view periodic exams from their company" ON rh.periodic_exams IS 'Permite que usuÃ¡rios visualizem exames periÃ³dicos da sua empresa';


--
-- Name: positions Users can view positions from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view positions from their company" ON rh.positions FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: reports Users can view reports from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view reports from their company" ON rh.reports FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'reports'::text, 'read'::text)));


--
-- Name: rubricas Users can view rubricas from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view rubricas from their company" ON rh.rubricas FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'rubricas'::text, 'read'::text)));


--
-- Name: schedule_planning Users can view schedule_planning from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view schedule_planning from their company" ON rh.schedule_planning FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'schedule_planning'::text, 'read'::text)));


--
-- Name: time_record_signature_config Users can view signature config for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view signature config for their company" ON rh.time_record_signature_config FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: time_record_signatures Users can view signatures for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view signatures for their company" ON rh.time_record_signatures FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: income_statements Users can view their own income statements; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view their own income statements" ON rh.income_statements FOR SELECT USING ((employee_id IN ( SELECT employees.id
   FROM rh.employees
  WHERE (employees.user_id = auth.uid()))));


--
-- Name: training_notification_history Users can view their own notification history; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view their own notification history" ON rh.training_notification_history FOR SELECT USING (((user_id = auth.uid()) AND (company_id = ANY (public.get_user_companies()))));


--
-- Name: training_settings Users can view training settings for their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view training settings for their company" ON rh.training_settings FOR SELECT USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: units Users can view units from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view units from their company" ON rh.units FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: work_shifts Users can view work_shifts from their company; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY "Users can view work_shifts from their company" ON rh.work_shifts FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'work_shifts'::text, 'read'::text)));


--
-- Name: absence_types; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.absence_types ENABLE ROW LEVEL SECURITY;

--
-- Name: allowance_types; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.allowance_types ENABLE ROW LEVEL SECURITY;

--
-- Name: approval_level_approvers; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.approval_level_approvers ENABLE ROW LEVEL SECURITY;

--
-- Name: approval_levels; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.approval_levels ENABLE ROW LEVEL SECURITY;

--
-- Name: training_attendance attendance_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY attendance_delete_policy ON rh.training_attendance FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_attendance attendance_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY attendance_insert_policy ON rh.training_attendance FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_attendance attendance_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY attendance_update_policy ON rh.training_attendance FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_attendance attendance_view_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY attendance_view_policy ON rh.training_attendance FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: audit_config; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.audit_config ENABLE ROW LEVEL SECURITY;

--
-- Name: audit_logs; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.audit_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: bank_hours_balance; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.bank_hours_balance ENABLE ROW LEVEL SECURITY;

--
-- Name: bank_hours_calculations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.bank_hours_calculations ENABLE ROW LEVEL SECURITY;

--
-- Name: bank_hours_config; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.bank_hours_config ENABLE ROW LEVEL SECURITY;

--
-- Name: bank_hours_transactions; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.bank_hours_transactions ENABLE ROW LEVEL SECURITY;

--
-- Name: benefit_configurations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.benefit_configurations ENABLE ROW LEVEL SECURITY;

--
-- Name: training_certificates certificate_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY certificate_delete_policy ON rh.training_certificates FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_certificates certificate_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY certificate_insert_policy ON rh.training_certificates FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_certificates certificate_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY certificate_update_policy ON rh.training_certificates FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_certificates certificate_view_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY certificate_view_policy ON rh.training_certificates FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: cid_codes; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.cid_codes ENABLE ROW LEVEL SECURITY;

--
-- Name: compensation_approvals; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.compensation_approvals ENABLE ROW LEVEL SECURITY;

--
-- Name: compensation_requests; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.compensation_requests ENABLE ROW LEVEL SECURITY;

--
-- Name: correction_history; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.correction_history ENABLE ROW LEVEL SECURITY;

--
-- Name: correction_history correction_history_company_access; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY correction_history_company_access ON rh.correction_history USING ((correction_id IN ( SELECT ac.id
   FROM rh.attendance_corrections ac
  WHERE (ac.company_id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: correction_settings; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.correction_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: correction_settings correction_settings_company_access; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY correction_settings_company_access ON rh.correction_settings USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: deficiency_types; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.deficiency_types ENABLE ROW LEVEL SECURITY;

--
-- Name: delay_reasons; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.delay_reasons ENABLE ROW LEVEL SECURITY;

--
-- Name: delay_reasons delay_reasons_company_access; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY delay_reasons_company_access ON rh.delay_reasons USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: dependents; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.dependents ENABLE ROW LEVEL SECURITY;

--
-- Name: disciplinary_actions; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.disciplinary_actions ENABLE ROW LEVEL SECURITY;

--
-- Name: employee_benefit_assignments; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.employee_benefit_assignments ENABLE ROW LEVEL SECURITY;

--
-- Name: employee_correction_permissions; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.employee_correction_permissions ENABLE ROW LEVEL SECURITY;

--
-- Name: employee_correction_permissions employee_correction_permissions_company_access; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY employee_correction_permissions_company_access ON rh.employee_correction_permissions USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE (user_companies.user_id = auth.uid()))));


--
-- Name: employee_schedules; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.employee_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: employee_shifts; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.employee_shifts ENABLE ROW LEVEL SECURITY;

--
-- Name: employment_contracts; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.employment_contracts ENABLE ROW LEVEL SECURITY;

--
-- Name: training_enrollments enrollment_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY enrollment_delete_policy ON rh.training_enrollments FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_enrollments enrollment_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY enrollment_insert_policy ON rh.training_enrollments FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_enrollments enrollment_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY enrollment_update_policy ON rh.training_enrollments FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_enrollments enrollment_view_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY enrollment_view_policy ON rh.training_enrollments FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: esocial_batches; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.esocial_batches ENABLE ROW LEVEL SECURITY;

--
-- Name: esocial_batches esocial_batches_delete; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY esocial_batches_delete ON rh.esocial_batches FOR DELETE USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: esocial_batches esocial_batches_insert; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY esocial_batches_insert ON rh.esocial_batches FOR INSERT WITH CHECK ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: esocial_batches esocial_batches_select; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY esocial_batches_select ON rh.esocial_batches FOR SELECT USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: esocial_batches esocial_batches_update; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY esocial_batches_update ON rh.esocial_batches FOR UPDATE USING ((company_id IN ( SELECT companies.id
   FROM public.companies
  WHERE (companies.id IN ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = auth.uid()))))));


--
-- Name: esocial_integrations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.esocial_integrations ENABLE ROW LEVEL SECURITY;

--
-- Name: training_evaluations evaluation_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY evaluation_delete_policy ON rh.training_evaluations FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_evaluations evaluation_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY evaluation_insert_policy ON rh.training_evaluations FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_evaluations evaluation_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY evaluation_update_policy ON rh.training_evaluations FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_evaluations evaluation_view_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY evaluation_view_policy ON rh.training_evaluations FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: event_consolidations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.event_consolidations ENABLE ROW LEVEL SECURITY;

--
-- Name: fgts_config; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.fgts_config ENABLE ROW LEVEL SECURITY;

--
-- Name: income_statements; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.income_statements ENABLE ROW LEVEL SECURITY;

--
-- Name: inss_brackets; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.inss_brackets ENABLE ROW LEVEL SECURITY;

--
-- Name: irrf_brackets; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.irrf_brackets ENABLE ROW LEVEL SECURITY;

--
-- Name: medical_certificate_attachments; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.medical_certificate_attachments ENABLE ROW LEVEL SECURITY;

--
-- Name: medical_certificates; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.medical_certificates ENABLE ROW LEVEL SECURITY;

--
-- Name: monthly_benefit_processing; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.monthly_benefit_processing ENABLE ROW LEVEL SECURITY;

--
-- Name: payroll; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.payroll ENABLE ROW LEVEL SECURITY;

--
-- Name: periodic_exams; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.periodic_exams ENABLE ROW LEVEL SECURITY;

--
-- Name: reports; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.reports ENABLE ROW LEVEL SECURITY;

--
-- Name: benefit_configurations rh_benefit_configurations_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_benefit_configurations_delete_policy ON rh.benefit_configurations FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'benefit_configurations'::text, 'delete'::text)));


--
-- Name: benefit_configurations rh_benefit_configurations_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_benefit_configurations_insert_policy ON rh.benefit_configurations FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'benefit_configurations'::text, 'create'::text)));


--
-- Name: benefit_configurations rh_benefit_configurations_select_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_benefit_configurations_select_policy ON rh.benefit_configurations FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'benefit_configurations'::text, 'read'::text)));


--
-- Name: benefit_configurations rh_benefit_configurations_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_benefit_configurations_update_policy ON rh.benefit_configurations FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'benefit_configurations'::text, 'edit'::text)));


--
-- Name: employees rh_employees_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_employees_delete_policy ON rh.employees FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employees'::text, 'delete'::text)));


--
-- Name: employees rh_employees_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_employees_insert_policy ON rh.employees FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employees'::text, 'create'::text)));


--
-- Name: employees rh_employees_select_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_employees_select_policy ON rh.employees FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employees'::text, 'read'::text)));


--
-- Name: employees rh_employees_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_employees_update_policy ON rh.employees FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'employees'::text, 'edit'::text)));


--
-- Name: positions rh_positions_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_positions_delete_policy ON rh.positions FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'positions'::text, 'delete'::text)));


--
-- Name: positions rh_positions_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_positions_insert_policy ON rh.positions FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'positions'::text, 'create'::text)));


--
-- Name: positions rh_positions_select_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_positions_select_policy ON rh.positions FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'positions'::text, 'read'::text)));


--
-- Name: positions rh_positions_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_positions_update_policy ON rh.positions FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'positions'::text, 'edit'::text)));


--
-- Name: units rh_units_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_units_delete_policy ON rh.units FOR DELETE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'units'::text, 'delete'::text)));


--
-- Name: units rh_units_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_units_insert_policy ON rh.units FOR INSERT WITH CHECK (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'units'::text, 'create'::text)));


--
-- Name: units rh_units_select_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_units_select_policy ON rh.units FOR SELECT USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'units'::text, 'read'::text)));


--
-- Name: units rh_units_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY rh_units_update_policy ON rh.units FOR UPDATE USING (((company_id = ANY (public.get_user_companies())) AND public.check_access_permission('rh'::text, 'units'::text, 'edit'::text)));


--
-- Name: rubricas; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.rubricas ENABLE ROW LEVEL SECURITY;

--
-- Name: schedule_planning; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.schedule_planning ENABLE ROW LEVEL SECURITY;

--
-- Name: signature_notifications; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.signature_notifications ENABLE ROW LEVEL SECURITY;

--
-- Name: time_record_signature_config; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.time_record_signature_config ENABLE ROW LEVEL SECURITY;

--
-- Name: time_record_signatures; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.time_record_signatures ENABLE ROW LEVEL SECURITY;

--
-- Name: time_records; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.time_records ENABLE ROW LEVEL SECURITY;

--
-- Name: training_attendance; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_attendance ENABLE ROW LEVEL SECURITY;

--
-- Name: training_certificates; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_certificates ENABLE ROW LEVEL SECURITY;

--
-- Name: trainings training_delete_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY training_delete_policy ON rh.trainings FOR DELETE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_enrollments; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_enrollments ENABLE ROW LEVEL SECURITY;

--
-- Name: training_evaluations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_evaluations ENABLE ROW LEVEL SECURITY;

--
-- Name: trainings training_insert_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY training_insert_policy ON rh.trainings FOR INSERT WITH CHECK ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: training_notification_history; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_notification_history ENABLE ROW LEVEL SECURITY;

--
-- Name: training_notification_queue; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_notification_queue ENABLE ROW LEVEL SECURITY;

--
-- Name: training_notification_rules; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_notification_rules ENABLE ROW LEVEL SECURITY;

--
-- Name: training_notification_types; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_notification_types ENABLE ROW LEVEL SECURITY;

--
-- Name: training_settings; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.training_settings ENABLE ROW LEVEL SECURITY;

--
-- Name: trainings training_update_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY training_update_policy ON rh.trainings FOR UPDATE USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: trainings training_view_policy; Type: POLICY; Schema: rh; Owner: postgres
--

CREATE POLICY training_view_policy ON rh.trainings FOR SELECT USING ((company_id IN ( SELECT user_companies.company_id
   FROM public.user_companies
  WHERE ((user_companies.user_id = auth.uid()) AND (user_companies.ativo = true)))));


--
-- Name: trainings; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.trainings ENABLE ROW LEVEL SECURITY;

--
-- Name: vacations; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.vacations ENABLE ROW LEVEL SECURITY;

--
-- Name: work_schedules; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.work_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: work_shifts; Type: ROW SECURITY; Schema: rh; Owner: postgres
--

ALTER TABLE rh.work_shifts ENABLE ROW LEVEL SECURITY;

--
-- Name: objects Admins can view all files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Admins can view all files" ON storage.objects FOR SELECT USING (((bucket_id = ANY (ARRAY['income-statements'::text, 'reimbursements'::text, 'holerites'::text, 'medical-certificates'::text])) AND (EXISTS ( SELECT 1
   FROM (public.user_companies uc
     JOIN public.profiles p ON ((p.id = uc.profile_id)))
  WHERE ((uc.user_id = auth.uid()) AND ((p.permissoes ->> 'admin'::text) = 'true'::text))))));


--
-- Name: objects Authenticated users can delete employee photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can delete employee photos" ON storage.objects FOR DELETE USING (((bucket_id = 'employee-photos'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Authenticated users can update employee photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can update employee photos" ON storage.objects FOR UPDATE USING (((bucket_id = 'employee-photos'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Authenticated users can upload employee photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Authenticated users can upload employee photos" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'employee-photos'::text) AND (auth.role() = 'authenticated'::text)));


--
-- Name: objects Managers can view all company files; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Managers can view all company files" ON storage.objects FOR SELECT USING (((bucket_id = ANY (ARRAY['income-statements'::text, 'reimbursements'::text, 'holerites'::text, 'medical-certificates'::text])) AND (EXISTS ( SELECT 1
   FROM (public.user_companies uc
     JOIN public.profiles p ON ((p.id = uc.profile_id)))
  WHERE ((uc.user_id = auth.uid()) AND (uc.company_id = ( SELECT user_companies.company_id
           FROM public.user_companies
          WHERE (user_companies.user_id = ((storage.foldername(objects.name))[1])::uuid)
         LIMIT 1)) AND (((p.permissoes ->> 'manager'::text) = 'true'::text) OR ((p.permissoes ->> 'admin'::text) = 'true'::text)))))));


--
-- Name: objects Public Access for Employee Photos; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Public Access for Employee Photos" ON storage.objects FOR SELECT USING ((bucket_id = 'employee-photos'::text));


--
-- Name: objects Users can delete own medical certificates; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can delete own medical certificates" ON storage.objects FOR DELETE USING (((bucket_id = 'medical-certificates'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can update own medical certificates; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can update own medical certificates" ON storage.objects FOR UPDATE USING (((bucket_id = 'medical-certificates'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can upload own holerites; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can upload own holerites" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'holerites'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can upload own income statements; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can upload own income statements" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'income-statements'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can upload own medical certificates; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can upload own medical certificates" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'medical-certificates'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can upload own reimbursements; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can upload own reimbursements" ON storage.objects FOR INSERT WITH CHECK (((bucket_id = 'reimbursements'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can view own holerites; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can view own holerites" ON storage.objects FOR SELECT USING (((bucket_id = 'holerites'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can view own income statements; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can view own income statements" ON storage.objects FOR SELECT USING (((bucket_id = 'income-statements'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can view own medical certificates; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can view own medical certificates" ON storage.objects FOR SELECT USING (((bucket_id = 'medical-certificates'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: objects Users can view own reimbursements; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Users can view own reimbursements" ON storage.objects FOR SELECT USING (((bucket_id = 'reimbursements'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


--
-- Name: buckets; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets_analytics; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets_analytics ENABLE ROW LEVEL SECURITY;

--
-- Name: migrations; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: objects; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

--
-- Name: prefixes; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.prefixes ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads_parts; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads_parts ENABLE ROW LEVEL SECURITY;

--
-- Name: supabase_realtime; Type: PUBLICATION; Schema: -; Owner: postgres
--

CREATE PUBLICATION supabase_realtime WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime OWNER TO postgres;

--
-- Name: SCHEMA almoxarifado; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA almoxarifado TO authenticated;


--
-- Name: SCHEMA auth; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA auth TO anon;
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON SCHEMA auth TO supabase_auth_admin;
GRANT ALL ON SCHEMA auth TO dashboard_user;
GRANT USAGE ON SCHEMA auth TO postgres;


--
-- Name: SCHEMA extensions; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA extensions TO anon;
GRANT USAGE ON SCHEMA extensions TO authenticated;
GRANT USAGE ON SCHEMA extensions TO service_role;
GRANT ALL ON SCHEMA extensions TO dashboard_user;


--
-- Name: SCHEMA financeiro; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA financeiro TO anon;
GRANT USAGE ON SCHEMA financeiro TO authenticated;
GRANT USAGE ON SCHEMA financeiro TO service_role;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;


--
-- Name: SCHEMA realtime; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA realtime TO postgres;
GRANT USAGE ON SCHEMA realtime TO anon;
GRANT USAGE ON SCHEMA realtime TO authenticated;
GRANT USAGE ON SCHEMA realtime TO service_role;
GRANT ALL ON SCHEMA realtime TO supabase_realtime_admin;


--
-- Name: SCHEMA rh; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA rh TO anon;
GRANT USAGE ON SCHEMA rh TO authenticated;
GRANT USAGE ON SCHEMA rh TO service_role;


--
-- Name: SCHEMA storage; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA storage TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA storage TO anon;
GRANT USAGE ON SCHEMA storage TO authenticated;
GRANT USAGE ON SCHEMA storage TO service_role;
GRANT ALL ON SCHEMA storage TO supabase_storage_admin;
GRANT ALL ON SCHEMA storage TO dashboard_user;


--
-- Name: SCHEMA vault; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA vault TO postgres WITH GRANT OPTION;
GRANT USAGE ON SCHEMA vault TO service_role;


--
-- Name: FUNCTION email(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.email() TO dashboard_user;


--
-- Name: FUNCTION jwt(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.jwt() TO postgres;
GRANT ALL ON FUNCTION auth.jwt() TO dashboard_user;


--
-- Name: FUNCTION role(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.role() TO dashboard_user;


--
-- Name: FUNCTION uid(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.uid() TO dashboard_user;


--
-- Name: FUNCTION armor(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO dashboard_user;


--
-- Name: FUNCTION armor(bytea, text[], text[]); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.armor(bytea, text[], text[]) FROM postgres;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO dashboard_user;


--
-- Name: FUNCTION crypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.crypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION dearmor(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.dearmor(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO dashboard_user;


--
-- Name: FUNCTION decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION decrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION digest(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.digest(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION encrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION gen_random_bytes(integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_bytes(integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO dashboard_user;


--
-- Name: FUNCTION gen_random_uuid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_random_uuid() FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO dashboard_user;


--
-- Name: FUNCTION gen_salt(text, integer); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.gen_salt(text, integer) FROM postgres;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO dashboard_user;


--
-- Name: FUNCTION grant_pg_cron_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_cron_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO dashboard_user;


--
-- Name: FUNCTION grant_pg_graphql_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.grant_pg_graphql_access() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION grant_pg_net_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION extensions.grant_pg_net_access() FROM supabase_admin;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO supabase_admin WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO dashboard_user;


--
-- Name: FUNCTION hmac(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION hmac(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.hmac(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO dashboard_user;


--
-- Name: FUNCTION pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) FROM postgres;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint, minmax_only boolean) TO dashboard_user;


--
-- Name: FUNCTION pgp_armor_headers(text, OUT key text, OUT value text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO dashboard_user;


--
-- Name: FUNCTION pgp_key_id(bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_key_id(bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO dashboard_user;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO dashboard_user;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) FROM postgres;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO dashboard_user;


--
-- Name: FUNCTION pgrst_ddl_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_ddl_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgrst_drop_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_drop_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION set_graphql_placeholder(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.set_graphql_placeholder() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v1(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v1mc(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v1mc() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v3(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v4(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v4() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO dashboard_user;


--
-- Name: FUNCTION uuid_generate_v5(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO dashboard_user;


--
-- Name: FUNCTION uuid_nil(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_nil() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_dns(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_dns() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_oid(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_oid() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_url(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_url() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO dashboard_user;


--
-- Name: FUNCTION uuid_ns_x500(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.uuid_ns_x500() FROM postgres;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO dashboard_user;


--
-- Name: FUNCTION calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date) TO anon;
GRANT ALL ON FUNCTION financeiro.calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date) TO authenticated;
GRANT ALL ON FUNCTION financeiro.calculate_dpo(p_company_id uuid, p_data_inicio date, p_data_fim date) TO service_role;


--
-- Name: FUNCTION calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date) TO anon;
GRANT ALL ON FUNCTION financeiro.calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date) TO authenticated;
GRANT ALL ON FUNCTION financeiro.calculate_dso(p_company_id uuid, p_data_inicio date, p_data_fim date) TO service_role;


--
-- Name: FUNCTION calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date, p_taxa_juros numeric, p_taxa_multa numeric); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date, p_taxa_juros numeric, p_taxa_multa numeric) TO anon;
GRANT ALL ON FUNCTION financeiro.calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date, p_taxa_juros numeric, p_taxa_multa numeric) TO authenticated;
GRANT ALL ON FUNCTION financeiro.calculate_valor_atual(p_valor_original numeric, p_data_vencimento date, p_data_calculo date, p_taxa_juros numeric, p_taxa_multa numeric) TO service_role;


--
-- Name: FUNCTION check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO anon;
GRANT ALL ON FUNCTION financeiro.check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO authenticated;
GRANT ALL ON FUNCTION financeiro.check_approval_permission(p_user_id uuid, p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO service_role;


--
-- Name: FUNCTION check_financial_permission(p_user_id uuid, p_permission text); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.check_financial_permission(p_user_id uuid, p_permission text) TO anon;
GRANT ALL ON FUNCTION financeiro.check_financial_permission(p_user_id uuid, p_permission text) TO authenticated;
GRANT ALL ON FUNCTION financeiro.check_financial_permission(p_user_id uuid, p_permission text) TO service_role;


--
-- Name: FUNCTION generate_remittance_file(p_company_id uuid, p_borderos_id uuid); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.generate_remittance_file(p_company_id uuid, p_borderos_id uuid) TO anon;
GRANT ALL ON FUNCTION financeiro.generate_remittance_file(p_company_id uuid, p_borderos_id uuid) TO authenticated;
GRANT ALL ON FUNCTION financeiro.generate_remittance_file(p_company_id uuid, p_borderos_id uuid) TO service_role;


--
-- Name: FUNCTION generate_titulo_number(p_company_id uuid, p_tipo character varying); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.generate_titulo_number(p_company_id uuid, p_tipo character varying) TO anon;
GRANT ALL ON FUNCTION financeiro.generate_titulo_number(p_company_id uuid, p_tipo character varying) TO authenticated;
GRANT ALL ON FUNCTION financeiro.generate_titulo_number(p_company_id uuid, p_tipo character varying) TO service_role;


--
-- Name: FUNCTION get_aging_report(p_company_id uuid, p_data_corte date); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.get_aging_report(p_company_id uuid, p_data_corte date) TO anon;
GRANT ALL ON FUNCTION financeiro.get_aging_report(p_company_id uuid, p_data_corte date) TO authenticated;
GRANT ALL ON FUNCTION financeiro.get_aging_report(p_company_id uuid, p_data_corte date) TO service_role;


--
-- Name: FUNCTION get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO anon;
GRANT ALL ON FUNCTION financeiro.get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO authenticated;
GRANT ALL ON FUNCTION financeiro.get_required_approval_level(p_company_id uuid, p_valor numeric, p_centro_custo_id uuid, p_departamento text, p_classe_financeira text) TO service_role;


--
-- Name: FUNCTION process_bank_return(p_company_id uuid, p_arquivo_retorno text); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.process_bank_return(p_company_id uuid, p_arquivo_retorno text) TO anon;
GRANT ALL ON FUNCTION financeiro.process_bank_return(p_company_id uuid, p_arquivo_retorno text) TO authenticated;
GRANT ALL ON FUNCTION financeiro.process_bank_return(p_company_id uuid, p_arquivo_retorno text) TO service_role;


--
-- Name: FUNCTION update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text) TO anon;
GRANT ALL ON FUNCTION financeiro.update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text) TO authenticated;
GRANT ALL ON FUNCTION financeiro.update_approval_status(p_entidade_tipo character varying, p_entidade_id uuid, p_aprovador_id uuid, p_status character varying, p_observacoes text) TO service_role;


--
-- Name: FUNCTION update_updated_at_column(); Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON FUNCTION financeiro.update_updated_at_column() TO anon;
GRANT ALL ON FUNCTION financeiro.update_updated_at_column() TO authenticated;
GRANT ALL ON FUNCTION financeiro.update_updated_at_column() TO service_role;


--
-- Name: FUNCTION graphql("operationName" text, query text, variables jsonb, extensions jsonb); Type: ACL; Schema: graphql_public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO postgres;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO anon;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO authenticated;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO service_role;


--
-- Name: FUNCTION get_auth(p_usename text); Type: ACL; Schema: pgbouncer; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename text) FROM PUBLIC;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO pgbouncer;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO postgres;


--
-- Name: FUNCTION adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) TO anon;
GRANT ALL ON FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) TO authenticated;
GRANT ALL ON FUNCTION public.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text) TO service_role;


--
-- Name: FUNCTION approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_attendance_correction(p_correction_id uuid, p_approved_by uuid, p_observacoes text) TO service_role;


--
-- Name: FUNCTION approve_compensation(compensation_id uuid, approved_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_compensation(compensation_id uuid, approved_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION approve_equipment(equipment_id uuid, approved_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_equipment(equipment_id uuid, approved_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_medical_certificate(certificate_id uuid, approved_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_reimbursement(reimbursement_id uuid, approved_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION approve_vacation(vacation_id uuid, approved_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.approve_vacation(vacation_id uuid, approved_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) TO anon;
GRANT ALL ON FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) TO authenticated;
GRANT ALL ON FUNCTION public.atualizar_dias_gozados(employee_id_param uuid, ano_param integer, dias_usados integer) TO service_role;


--
-- Name: FUNCTION audit_approval_levels(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.audit_approval_levels() TO anon;
GRANT ALL ON FUNCTION public.audit_approval_levels() TO authenticated;
GRANT ALL ON FUNCTION public.audit_approval_levels() TO service_role;


--
-- Name: FUNCTION audit_compensation_approvals(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.audit_compensation_approvals() TO anon;
GRANT ALL ON FUNCTION public.audit_compensation_approvals() TO authenticated;
GRANT ALL ON FUNCTION public.audit_compensation_approvals() TO service_role;


--
-- Name: FUNCTION audit_compensation_requests(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.audit_compensation_requests() TO anon;
GRANT ALL ON FUNCTION public.audit_compensation_requests() TO authenticated;
GRANT ALL ON FUNCTION public.audit_compensation_requests() TO service_role;


--
-- Name: FUNCTION audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying) TO anon;
GRANT ALL ON FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying) TO authenticated;
GRANT ALL ON FUNCTION public.audit_log(p_company_id uuid, p_user_id uuid, p_action character varying, p_entity_type character varying, p_entity_id uuid, p_old_values jsonb, p_new_values jsonb, p_ip_address inet, p_user_agent text, p_session_id character varying) TO service_role;


--
-- Name: FUNCTION buscar_anos_ferias_disponiveis(employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) TO anon;
GRANT ALL ON FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) TO authenticated;
GRANT ALL ON FUNCTION public.calcular_dias_ferias_disponiveis(employee_id_param uuid, ano_param integer) TO service_role;


--
-- Name: FUNCTION calculate_medical_certificate_days(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_medical_certificate_days() TO anon;
GRANT ALL ON FUNCTION public.calculate_medical_certificate_days() TO authenticated;
GRANT ALL ON FUNCTION public.calculate_medical_certificate_days() TO service_role;


--
-- Name: FUNCTION calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_medical_plan_benefits_total(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_medical_plan_discounts_total(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_payroll_benefits_total(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone) TO anon;
GRANT ALL ON FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone) TO authenticated;
GRANT ALL ON FUNCTION public.calculate_work_hours(p_entrada time without time zone, p_saida time without time zone, p_entrada_almoco time without time zone, p_saida_almoco time without time zone) TO service_role;


--
-- Name: FUNCTION can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid) TO anon;
GRANT ALL ON FUNCTION public.can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.can_edit_solicitation(p_processo_tipo character varying, p_processo_id uuid) TO service_role;


--
-- Name: FUNCTION check_access_permission(schema_name text, table_name text, action text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_access_permission(schema_name text, table_name text, action text) TO anon;
GRANT ALL ON FUNCTION public.check_access_permission(schema_name text, table_name text, action text) TO authenticated;
GRANT ALL ON FUNCTION public.check_access_permission(schema_name text, table_name text, action text) TO service_role;


--
-- Name: FUNCTION check_company_access(p_user_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_company_access(p_user_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.check_company_access(p_user_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.check_company_access(p_user_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION check_compensation_approval_status(p_compensation_request_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) TO anon;
GRANT ALL ON FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.check_compensation_approval_status(p_compensation_request_id uuid) TO service_role;


--
-- Name: FUNCTION check_edit_permission(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_edit_permission() TO anon;
GRANT ALL ON FUNCTION public.check_edit_permission() TO authenticated;
GRANT ALL ON FUNCTION public.check_edit_permission() TO service_role;


--
-- Name: FUNCTION check_entity_permission(p_user_id uuid, p_entity_name text, p_action text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_entity_permission(p_user_id uuid, p_entity_name text, p_action text) TO anon;
GRANT ALL ON FUNCTION public.check_entity_permission(p_user_id uuid, p_entity_name text, p_action text) TO authenticated;
GRANT ALL ON FUNCTION public.check_entity_permission(p_user_id uuid, p_entity_name text, p_action text) TO service_role;


--
-- Name: FUNCTION check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text) TO anon;
GRANT ALL ON FUNCTION public.check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text) TO authenticated;
GRANT ALL ON FUNCTION public.check_entity_permission_v2(p_user_id uuid, p_entity_name text, p_action text) TO service_role;


--
-- Name: FUNCTION check_module_permission(p_user_id uuid, p_module_name text, p_action text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_module_permission(p_user_id uuid, p_module_name text, p_action text) TO anon;
GRANT ALL ON FUNCTION public.check_module_permission(p_user_id uuid, p_module_name text, p_action text) TO authenticated;
GRANT ALL ON FUNCTION public.check_module_permission(p_user_id uuid, p_module_name text, p_action text) TO service_role;


--
-- Name: FUNCTION check_user_permission(p_module_name text, p_permission text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.check_user_permission(p_module_name text, p_permission text) TO anon;
GRANT ALL ON FUNCTION public.check_user_permission(p_module_name text, p_permission text) TO authenticated;
GRANT ALL ON FUNCTION public.check_user_permission(p_module_name text, p_permission text) TO service_role;


--
-- Name: FUNCTION cleanup_old_audit_logs(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.cleanup_old_audit_logs() TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_audit_logs() TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_audit_logs() TO service_role;


--
-- Name: FUNCTION create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_approvals_for_process(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION create_approvals_on_insert(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_approvals_on_insert() TO anon;
GRANT ALL ON FUNCTION public.create_approvals_on_insert() TO authenticated;
GRANT ALL ON FUNCTION public.create_approvals_on_insert() TO service_role;


--
-- Name: FUNCTION create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text, usuario_id_param uuid, usuario_nome_param text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text, usuario_id_param uuid, usuario_nome_param text) TO anon;
GRANT ALL ON FUNCTION public.create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text, usuario_id_param uuid, usuario_nome_param text) TO authenticated;
GRANT ALL ON FUNCTION public.create_calculation_log(company_id_param uuid, processo_id_param text, tipo_processo_param text, mes_referencia_param integer, ano_referencia_param integer, descricao_processo_param text, usuario_id_param uuid, usuario_nome_param text) TO service_role;


--
-- Name: FUNCTION create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_compensation_approvals(p_compensation_request_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION create_default_signature_config(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_default_signature_config() TO anon;
GRANT ALL ON FUNCTION public.create_default_signature_config() TO authenticated;
GRANT ALL ON FUNCTION public.create_default_signature_config() TO service_role;


--
-- Name: FUNCTION create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid) TO service_role;


--
-- Name: FUNCTION create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid, matricula_param text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid, matricula_param text) TO anon;
GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid, matricula_param text) TO authenticated;
GRANT ALL ON FUNCTION public.create_employee(company_id_param uuid, nome_param text, cpf_param text, data_admissao_param date, status_param text, user_id_param uuid, matricula_param text) TO service_role;


--
-- Name: FUNCTION create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb) TO anon;
GRANT ALL ON FUNCTION public.create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.create_entity_data(schema_name text, table_name text, company_id_param uuid, data_param jsonb) TO service_role;


--
-- Name: FUNCTION create_monthly_signature_records(p_company_id uuid, p_month_year character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_monthly_signature_records(p_company_id uuid, p_month_year character varying) TO anon;
GRANT ALL ON FUNCTION public.create_monthly_signature_records(p_company_id uuid, p_month_year character varying) TO authenticated;
GRANT ALL ON FUNCTION public.create_monthly_signature_records(p_company_id uuid, p_month_year character varying) TO service_role;


--
-- Name: FUNCTION create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO anon;
GRANT ALL ON FUNCTION public.create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO authenticated;
GRANT ALL ON FUNCTION public.create_periodic_exam(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO service_role;


--
-- Name: FUNCTION create_profile(p_nome text, p_descricao text, p_is_active boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_profile(p_nome text, p_descricao text, p_is_active boolean) TO anon;
GRANT ALL ON FUNCTION public.create_profile(p_nome text, p_descricao text, p_is_active boolean) TO authenticated;
GRANT ALL ON FUNCTION public.create_profile(p_nome text, p_descricao text, p_is_active boolean) TO service_role;


--
-- Name: FUNCTION create_signature_config_for_new_company(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.create_signature_config_for_new_company() TO anon;
GRANT ALL ON FUNCTION public.create_signature_config_for_new_company() TO authenticated;
GRANT ALL ON FUNCTION public.create_signature_config_for_new_company() TO service_role;


--
-- Name: FUNCTION criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) TO anon;
GRANT ALL ON FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) TO authenticated;
GRANT ALL ON FUNCTION public.criar_periodo_aquisitivo(employee_id_param uuid, company_id_param uuid, data_admissao_param date, ano_param integer) TO service_role;


--
-- Name: FUNCTION delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.delete_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid) TO service_role;


--
-- Name: FUNCTION delete_periodic_exam(p_exam_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.delete_periodic_exam(p_exam_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.delete_periodic_exam(p_exam_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.delete_periodic_exam(p_exam_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION expire_signatures(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.expire_signatures() TO anon;
GRANT ALL ON FUNCTION public.expire_signatures() TO authenticated;
GRANT ALL ON FUNCTION public.expire_signatures() TO service_role;


--
-- Name: FUNCTION generate_company_number(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_company_number() TO anon;
GRANT ALL ON FUNCTION public.generate_company_number() TO authenticated;
GRANT ALL ON FUNCTION public.generate_company_number() TO service_role;


--
-- Name: FUNCTION generate_employee_matricula(company_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_employee_matricula(company_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.generate_employee_matricula(company_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.generate_employee_matricula(company_id_param uuid) TO service_role;


--
-- Name: FUNCTION generate_monthly_signatures(p_company_id uuid, p_month_year character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.generate_monthly_signatures(p_company_id uuid, p_month_year character varying) TO anon;
GRANT ALL ON FUNCTION public.generate_monthly_signatures(p_company_id uuid, p_month_year character varying) TO authenticated;
GRANT ALL ON FUNCTION public.generate_monthly_signatures(p_company_id uuid, p_month_year character varying) TO service_role;


--
-- Name: FUNCTION get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer) TO anon;
GRANT ALL ON FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_audit_logs(p_company_id uuid, p_entity_type character varying, p_entity_id uuid, p_action character varying, p_user_id uuid, p_start_date timestamp with time zone, p_end_date timestamp with time zone, p_limit integer, p_offset integer) TO service_role;


--
-- Name: FUNCTION get_bank_hours_balance(p_employee_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_calculation_logs(company_id_param uuid, filters jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_calculation_logs(company_id_param uuid, filters jsonb) TO anon;
GRANT ALL ON FUNCTION public.get_calculation_logs(company_id_param uuid, filters jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.get_calculation_logs(company_id_param uuid, filters jsonb) TO service_role;


--
-- Name: FUNCTION get_correction_status(p_employee_id uuid, p_year integer, p_month integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) TO anon;
GRANT ALL ON FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_correction_status(p_employee_id uuid, p_year integer, p_month integer) TO service_role;


--
-- Name: FUNCTION get_employee_all_benefits(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_employee_all_benefits(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_employee_all_medical_plans(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_employee_medical_plan_discounts_only(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_employee_payroll_benefits(company_id_param uuid, employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO anon;
GRANT ALL ON FUNCTION public.get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO authenticated;
GRANT ALL ON FUNCTION public.get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO service_role;


--
-- Name: FUNCTION get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO anon;
GRANT ALL ON FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO authenticated;
GRANT ALL ON FUNCTION public.get_entity_data_simple(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO service_role;


--
-- Name: FUNCTION get_entity_data_with_joins(schema_name text, table_name text, company_id_param text, joins jsonb, filters jsonb, limit_param integer, offset_param integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_entity_data_with_joins(schema_name text, table_name text, company_id_param text, joins jsonb, filters jsonb, limit_param integer, offset_param integer) TO anon;
GRANT ALL ON FUNCTION public.get_entity_data_with_joins(schema_name text, table_name text, company_id_param text, joins jsonb, filters jsonb, limit_param integer, offset_param integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_entity_data_with_joins(schema_name text, table_name text, company_id_param text, joins jsonb, filters jsonb, limit_param integer, offset_param integer) TO service_role;


--
-- Name: FUNCTION get_entity_permissions_by_profile(p_profile_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_entity_permissions_by_profile(p_profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_entity_permissions_by_profile(p_profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_entity_permissions_by_profile(p_profile_id uuid) TO service_role;


--
-- Name: FUNCTION get_gestor_dashboard_stats(company_uuid uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) TO anon;
GRANT ALL ON FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_gestor_dashboard_stats(company_uuid uuid) TO service_role;


--
-- Name: FUNCTION get_gestor_recent_activities(company_uuid uuid, limit_count integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_gestor_recent_activities(company_uuid uuid, limit_count integer) TO anon;
GRANT ALL ON FUNCTION public.get_gestor_recent_activities(company_uuid uuid, limit_count integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_gestor_recent_activities(company_uuid uuid, limit_count integer) TO service_role;


--
-- Name: FUNCTION get_module_permissions_by_profile(p_profile_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_module_permissions_by_profile(p_profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_module_permissions_by_profile(p_profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_module_permissions_by_profile(p_profile_id uuid) TO service_role;


--
-- Name: FUNCTION get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_pending_approvals_for_user(p_user_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO anon;
GRANT ALL ON FUNCTION public.get_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO service_role;


--
-- Name: FUNCTION get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric) TO anon;
GRANT ALL ON FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric) TO authenticated;
GRANT ALL ON FUNCTION public.get_required_approval_level(p_company_id uuid, p_hours numeric, p_amount numeric) TO service_role;


--
-- Name: FUNCTION get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_required_approvers(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_signature_stats(p_company_id uuid, p_month_year character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_signature_stats(p_company_id uuid, p_month_year character varying) TO anon;
GRANT ALL ON FUNCTION public.get_signature_stats(p_company_id uuid, p_month_year character varying) TO authenticated;
GRANT ALL ON FUNCTION public.get_signature_stats(p_company_id uuid, p_month_year character varying) TO service_role;


--
-- Name: FUNCTION get_time_records_simple(company_id_param uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_time_records_simple(company_id_param uuid) TO anon;
GRANT ALL ON FUNCTION public.get_time_records_simple(company_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_time_records_simple(company_id_param uuid) TO service_role;


--
-- Name: FUNCTION get_user_companies(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_companies() TO anon;
GRANT ALL ON FUNCTION public.get_user_companies() TO authenticated;
GRANT ALL ON FUNCTION public.get_user_companies() TO service_role;


--
-- Name: FUNCTION get_user_permissions(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_permissions(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_permissions(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_permissions(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_permissions_simple(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_permissions_simple(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_permissions_simple(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_permissions_simple(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_profile(user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.get_user_profile(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_profile(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_profile(user_id uuid) TO service_role;


--
-- Name: FUNCTION handle_new_user(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.handle_new_user() TO anon;
GRANT ALL ON FUNCTION public.handle_new_user() TO authenticated;
GRANT ALL ON FUNCTION public.handle_new_user() TO service_role;


--
-- Name: FUNCTION is_admin(user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_admin(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_admin(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_admin(user_id uuid) TO service_role;


--
-- Name: FUNCTION is_admin_all_production(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_admin_all_production(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_admin_all_production(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_admin_all_production(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION is_admin_simple(p_user_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_admin_simple(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_admin_simple(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_admin_simple(p_user_id uuid) TO service_role;


--
-- Name: FUNCTION is_month_open_for_signature(p_company_id uuid, p_month_year character varying); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.is_month_open_for_signature(p_company_id uuid, p_month_year character varying) TO anon;
GRANT ALL ON FUNCTION public.is_month_open_for_signature(p_company_id uuid, p_month_year character varying) TO authenticated;
GRANT ALL ON FUNCTION public.is_month_open_for_signature(p_company_id uuid, p_month_year character varying) TO service_role;


--
-- Name: FUNCTION list_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.list_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO anon;
GRANT ALL ON FUNCTION public.list_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO authenticated;
GRANT ALL ON FUNCTION public.list_periodic_exams(p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_status character varying, p_resultado character varying, p_data_inicio date, p_data_fim date, p_limit integer, p_offset integer) TO service_role;


--
-- Name: FUNCTION process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid) TO anon;
GRANT ALL ON FUNCTION public.process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.process_approval(p_aprovacao_id uuid, p_status character varying, p_observacoes text, p_aprovador_id uuid) TO service_role;


--
-- Name: FUNCTION process_expired_signatures(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.process_expired_signatures() TO anon;
GRANT ALL ON FUNCTION public.process_expired_signatures() TO authenticated;
GRANT ALL ON FUNCTION public.process_expired_signatures() TO service_role;


--
-- Name: FUNCTION record_edit_and_reset_approvals(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.record_edit_and_reset_approvals() TO anon;
GRANT ALL ON FUNCTION public.record_edit_and_reset_approvals() TO authenticated;
GRANT ALL ON FUNCTION public.record_edit_and_reset_approvals() TO service_role;


--
-- Name: FUNCTION reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_attendance_correction(p_correction_id uuid, p_rejected_by uuid, p_observacoes text) TO service_role;


--
-- Name: FUNCTION reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_compensation(compensation_id uuid, rejected_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_equipment(equipment_id uuid, rejected_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_medical_certificate(certificate_id uuid, rejected_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_reimbursement(reimbursement_id uuid, rejected_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) TO anon;
GRANT ALL ON FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) TO authenticated;
GRANT ALL ON FUNCTION public.reject_vacation(vacation_id uuid, rejected_by uuid, observacoes text) TO service_role;


--
-- Name: FUNCTION reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.reset_approvals_after_edit(p_processo_tipo character varying, p_processo_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION run_bank_hours_calculation(p_company_id uuid, p_calculation_date date); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO anon;
GRANT ALL ON FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO authenticated;
GRANT ALL ON FUNCTION public.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO service_role;


--
-- Name: FUNCTION set_company_context(company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.set_company_context(company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.set_company_context(company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.set_company_context(company_id uuid) TO service_role;


--
-- Name: FUNCTION test_auth_context(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_auth_context() TO anon;
GRANT ALL ON FUNCTION public.test_auth_context() TO authenticated;
GRANT ALL ON FUNCTION public.test_auth_context() TO service_role;


--
-- Name: FUNCTION test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO anon;
GRANT ALL ON FUNCTION public.test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO authenticated;
GRANT ALL ON FUNCTION public.test_authenticated_access(test_user_id uuid, schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO service_role;


--
-- Name: FUNCTION test_get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO anon;
GRANT ALL ON FUNCTION public.test_get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO authenticated;
GRANT ALL ON FUNCTION public.test_get_entity_data(schema_name text, table_name text, company_id_param text, filters jsonb, limit_param integer, offset_param integer, order_by text, order_direction text) TO service_role;


--
-- Name: FUNCTION test_time_bank_access(company_id_param text); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.test_time_bank_access(company_id_param text) TO anon;
GRANT ALL ON FUNCTION public.test_time_bank_access(company_id_param text) TO authenticated;
GRANT ALL ON FUNCTION public.test_time_bank_access(company_id_param text) TO service_role;


--
-- Name: FUNCTION transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid) TO anon;
GRANT ALL ON FUNCTION public.transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid) TO authenticated;
GRANT ALL ON FUNCTION public.transfer_approval(p_aprovacao_id uuid, p_novo_aprovador_id uuid, p_motivo text, p_transferido_por uuid) TO service_role;


--
-- Name: FUNCTION trigger_create_compensation_approvals(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.trigger_create_compensation_approvals() TO anon;
GRANT ALL ON FUNCTION public.trigger_create_compensation_approvals() TO authenticated;
GRANT ALL ON FUNCTION public.trigger_create_compensation_approvals() TO service_role;


--
-- Name: FUNCTION update_absence_types_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_absence_types_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_absence_types_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_absence_types_updated_at() TO service_role;


--
-- Name: FUNCTION update_allowance_types_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_allowance_types_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_allowance_types_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_allowance_types_updated_at() TO service_role;


--
-- Name: FUNCTION update_approval_levels_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_approval_levels_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_approval_levels_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_approval_levels_updated_at() TO service_role;


--
-- Name: FUNCTION update_audit_config_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_audit_config_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_audit_config_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_audit_config_updated_at() TO service_role;


--
-- Name: FUNCTION update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb) TO anon;
GRANT ALL ON FUNCTION public.update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.update_calculation_log(log_id_param uuid, company_id_param uuid, updates jsonb) TO service_role;


--
-- Name: FUNCTION update_cid_codes_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_cid_codes_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_cid_codes_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_cid_codes_updated_at() TO service_role;


--
-- Name: FUNCTION update_companies_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_companies_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_companies_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_companies_updated_at() TO service_role;


--
-- Name: FUNCTION update_compensation_approvals_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_compensation_approvals_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_compensation_approvals_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_compensation_approvals_updated_at() TO service_role;


--
-- Name: FUNCTION update_compensation_requests_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_compensation_requests_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_compensation_requests_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_compensation_requests_updated_at() TO service_role;


--
-- Name: FUNCTION update_deficiency_types_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_deficiency_types_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_deficiency_types_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_deficiency_types_updated_at() TO service_role;


--
-- Name: FUNCTION update_delay_reasons_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_delay_reasons_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_delay_reasons_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_delay_reasons_updated_at() TO service_role;


--
-- Name: FUNCTION update_disciplinary_actions_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_disciplinary_actions_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_disciplinary_actions_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_disciplinary_actions_updated_at() TO service_role;


--
-- Name: FUNCTION update_employee_shifts_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_employee_shifts_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_employee_shifts_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_employee_shifts_updated_at() TO service_role;


--
-- Name: FUNCTION update_employment_contracts_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_employment_contracts_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_employment_contracts_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_employment_contracts_updated_at() TO service_role;


--
-- Name: FUNCTION update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb) TO anon;
GRANT ALL ON FUNCTION public.update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.update_entity_data(schema_name text, table_name text, company_id_param uuid, id_param uuid, data_param jsonb) TO service_role;


--
-- Name: FUNCTION update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_entity_permission(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_entity_permission_no_auth(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_entity_permission_production(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_entity_permission_with_check(p_profile_id uuid, p_entity_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_esocial_integrations_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_esocial_integrations_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_esocial_integrations_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_esocial_integrations_updated_at() TO service_role;


--
-- Name: FUNCTION update_event_consolidations_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_event_consolidations_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_event_consolidations_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_event_consolidations_updated_at() TO service_role;


--
-- Name: FUNCTION update_fgts_config_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_fgts_config_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_fgts_config_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_fgts_config_updated_at() TO service_role;


--
-- Name: FUNCTION update_income_statements_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_income_statements_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_income_statements_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_income_statements_updated_at() TO service_role;


--
-- Name: FUNCTION update_inss_brackets_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_inss_brackets_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_inss_brackets_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_inss_brackets_updated_at() TO service_role;


--
-- Name: FUNCTION update_irrf_brackets_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_irrf_brackets_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_irrf_brackets_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_irrf_brackets_updated_at() TO service_role;


--
-- Name: FUNCTION update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_module_permission(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_module_permission_no_auth(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_module_permission_production(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO anon;
GRANT ALL ON FUNCTION public.update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_module_permission_with_check(p_profile_id uuid, p_module_name text, p_action text, p_value boolean) TO service_role;


--
-- Name: FUNCTION update_notifications_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_notifications_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_notifications_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_notifications_updated_at() TO service_role;


--
-- Name: FUNCTION update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_realizacao date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_realizacao date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO anon;
GRANT ALL ON FUNCTION public.update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_realizacao date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO authenticated;
GRANT ALL ON FUNCTION public.update_periodic_exam(p_exam_id uuid, p_company_id uuid, p_employee_id uuid, p_tipo_exame character varying, p_data_agendamento date, p_data_realizacao date, p_data_vencimento date, p_status character varying, p_medico_responsavel character varying, p_clinica_local character varying, p_observacoes text, p_resultado character varying, p_restricoes text, p_anexos text[], p_custo numeric, p_pago boolean, p_data_pagamento date) TO service_role;


--
-- Name: FUNCTION update_profile(p_id uuid, p_nome text, p_descricao text, p_is_active boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_profile(p_id uuid, p_nome text, p_descricao text, p_is_active boolean) TO anon;
GRANT ALL ON FUNCTION public.update_profile(p_id uuid, p_nome text, p_descricao text, p_is_active boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_profile(p_id uuid, p_nome text, p_descricao text, p_is_active boolean) TO service_role;


--
-- Name: FUNCTION update_reports_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_reports_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_reports_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_reports_updated_at() TO service_role;


--
-- Name: FUNCTION update_rubricas_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_rubricas_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_rubricas_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_rubricas_updated_at() TO service_role;


--
-- Name: FUNCTION update_schedule_planning_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_schedule_planning_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_schedule_planning_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_schedule_planning_updated_at() TO service_role;


--
-- Name: TABLE time_record_signature_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.time_record_signature_config TO anon;
GRANT ALL ON TABLE rh.time_record_signature_config TO authenticated;
GRANT ALL ON TABLE rh.time_record_signature_config TO service_role;


--
-- Name: FUNCTION update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean) TO anon;
GRANT ALL ON FUNCTION public.update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean) TO authenticated;
GRANT ALL ON FUNCTION public.update_time_record_signature_config(p_id uuid, p_company_id uuid, p_is_enabled boolean, p_signature_period_days integer, p_reminder_days integer, p_require_manager_approval boolean, p_auto_close_month boolean) TO service_role;


--
-- Name: FUNCTION update_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_updated_at() TO service_role;


--
-- Name: FUNCTION update_updated_at_column(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_updated_at_column() TO anon;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO authenticated;
GRANT ALL ON FUNCTION public.update_updated_at_column() TO service_role;


--
-- Name: FUNCTION update_work_shifts_updated_at(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.update_work_shifts_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_work_shifts_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_work_shifts_updated_at() TO service_role;


--
-- Name: FUNCTION user_has_company_access(user_id uuid, company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.user_has_company_access(user_id uuid, company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.user_has_company_access(user_id uuid, company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.user_has_company_access(user_id uuid, company_id uuid) TO service_role;


--
-- Name: FUNCTION user_has_company_access_new(p_user_id uuid, p_company_id uuid); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.user_has_company_access_new(p_user_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION public.user_has_company_access_new(p_user_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.user_has_company_access_new(p_user_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) TO anon;
GRANT ALL ON FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) TO authenticated;
GRANT ALL ON FUNCTION public.validar_solicitacao_ferias(employee_id_param uuid, ano_param integer, dias_solicitados integer) TO service_role;


--
-- Name: FUNCTION apply_rls(wal jsonb, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO postgres;
GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO dashboard_user;


--
-- Name: FUNCTION build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO postgres;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO anon;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO service_role;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION "cast"(val text, type_ regtype); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO postgres;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO dashboard_user;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO anon;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO authenticated;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO service_role;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO supabase_realtime_admin;


--
-- Name: FUNCTION check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO postgres;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO anon;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO authenticated;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO service_role;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO supabase_realtime_admin;


--
-- Name: FUNCTION is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO postgres;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO anon;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO service_role;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION quote_wal2json(entity regclass); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO postgres;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO anon;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO authenticated;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO service_role;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO supabase_realtime_admin;


--
-- Name: FUNCTION send(payload jsonb, event text, topic text, private boolean); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO postgres;
GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO dashboard_user;


--
-- Name: FUNCTION subscription_check_filters(); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO postgres;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO dashboard_user;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO anon;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO authenticated;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO service_role;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO supabase_realtime_admin;


--
-- Name: FUNCTION to_regrole(role_name text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO postgres;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO anon;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO authenticated;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO service_role;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO supabase_realtime_admin;


--
-- Name: FUNCTION topic(); Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON FUNCTION realtime.topic() TO postgres;
GRANT ALL ON FUNCTION realtime.topic() TO dashboard_user;


--
-- Name: FUNCTION adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid) TO anon;
GRANT ALL ON FUNCTION rh.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.adjust_bank_hours_balance(p_employee_id uuid, p_company_id uuid, p_hours_amount numeric, p_description text, p_created_by uuid) TO service_role;


--
-- Name: FUNCTION buscar_anos_ferias_disponiveis(employee_id_param uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO anon;
GRANT ALL ON FUNCTION rh.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.buscar_anos_ferias_disponiveis(employee_id_param uuid) TO service_role;


--
-- Name: FUNCTION buscar_ferias_pendentes(p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.buscar_ferias_pendentes(p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.buscar_ferias_pendentes(p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.buscar_ferias_pendentes(p_company_id uuid) TO service_role;


--
-- Name: FUNCTION calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer) TO anon;
GRANT ALL ON FUNCTION rh.calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer) TO authenticated;
GRANT ALL ON FUNCTION rh.calcular_dias_ferias_disponiveis(p_employee_id uuid, p_ano integer) TO service_role;


--
-- Name: FUNCTION calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date) TO anon;
GRANT ALL ON FUNCTION rh.calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date) TO authenticated;
GRANT ALL ON FUNCTION rh.calculate_and_accumulate_bank_hours(p_employee_id uuid, p_company_id uuid, p_period_start date, p_period_end date) TO service_role;


--
-- Name: FUNCTION create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) TO anon;
GRANT ALL ON FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) TO authenticated;
GRANT ALL ON FUNCTION rh.create_exam_notification(p_user_id uuid, p_company_id uuid, p_exam_id uuid, p_notification_type character varying, p_title character varying, p_message text) TO service_role;


--
-- Name: FUNCTION create_training_notification_rules(p_training_id uuid, p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.create_training_notification_rules(p_training_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.create_training_notification_rules(p_training_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.create_training_notification_rules(p_training_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_bank_hours_balance(p_employee_id uuid, p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.get_bank_hours_balance(p_employee_id uuid, p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_exams_needing_notification(p_company_id uuid, p_days_ahead integer); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer) TO anon;
GRANT ALL ON FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer) TO authenticated;
GRANT ALL ON FUNCTION rh.get_exams_needing_notification(p_company_id uuid, p_days_ahead integer) TO service_role;


--
-- Name: FUNCTION get_expired_exams(p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.get_expired_exams(p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.get_expired_exams(p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.get_expired_exams(p_company_id uuid) TO service_role;


--
-- Name: FUNCTION get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer, p_offset integer); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer, p_offset integer) TO anon;
GRANT ALL ON FUNCTION rh.get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer, p_offset integer) TO authenticated;
GRANT ALL ON FUNCTION rh.get_training_notifications(p_user_id uuid, p_company_id uuid, p_limit integer, p_offset integer) TO service_role;


--
-- Name: FUNCTION get_training_settings(p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.get_training_settings(p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.get_training_settings(p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.get_training_settings(p_company_id uuid) TO service_role;


--
-- Name: FUNCTION initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean, p_accumulation_period_months integer, p_max_accumulation_hours numeric, p_compensation_rate numeric); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean, p_accumulation_period_months integer, p_max_accumulation_hours numeric, p_compensation_rate numeric) TO anon;
GRANT ALL ON FUNCTION rh.initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean, p_accumulation_period_months integer, p_max_accumulation_hours numeric, p_compensation_rate numeric) TO authenticated;
GRANT ALL ON FUNCTION rh.initialize_bank_hours_config(p_employee_id uuid, p_company_id uuid, p_has_bank_hours boolean, p_accumulation_period_months integer, p_max_accumulation_hours numeric, p_compensation_rate numeric) TO service_role;


--
-- Name: FUNCTION process_bank_hours_expiration(p_company_id uuid, p_expiration_date date); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.process_bank_hours_expiration(p_company_id uuid, p_expiration_date date) TO anon;
GRANT ALL ON FUNCTION rh.process_bank_hours_expiration(p_company_id uuid, p_expiration_date date) TO authenticated;
GRANT ALL ON FUNCTION rh.process_bank_hours_expiration(p_company_id uuid, p_expiration_date date) TO service_role;


--
-- Name: FUNCTION process_notification_queue(); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.process_notification_queue() TO anon;
GRANT ALL ON FUNCTION rh.process_notification_queue() TO authenticated;
GRANT ALL ON FUNCTION rh.process_notification_queue() TO service_role;


--
-- Name: FUNCTION run_bank_hours_calculation(p_company_id uuid, p_calculation_date date); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO anon;
GRANT ALL ON FUNCTION rh.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO authenticated;
GRANT ALL ON FUNCTION rh.run_bank_hours_calculation(p_company_id uuid, p_calculation_date date) TO service_role;


--
-- Name: FUNCTION schedule_exam_notifications(p_company_id uuid); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.schedule_exam_notifications(p_company_id uuid) TO anon;
GRANT ALL ON FUNCTION rh.schedule_exam_notifications(p_company_id uuid) TO authenticated;
GRANT ALL ON FUNCTION rh.schedule_exam_notifications(p_company_id uuid) TO service_role;


--
-- Name: FUNCTION schedule_training_notifications(); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.schedule_training_notifications() TO anon;
GRANT ALL ON FUNCTION rh.schedule_training_notifications() TO authenticated;
GRANT ALL ON FUNCTION rh.schedule_training_notifications() TO service_role;


--
-- Name: FUNCTION trigger_create_training_notification_rules(); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.trigger_create_training_notification_rules() TO anon;
GRANT ALL ON FUNCTION rh.trigger_create_training_notification_rules() TO authenticated;
GRANT ALL ON FUNCTION rh.trigger_create_training_notification_rules() TO service_role;


--
-- Name: FUNCTION update_training_settings_updated_at(); Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON FUNCTION rh.update_training_settings_updated_at() TO anon;
GRANT ALL ON FUNCTION rh.update_training_settings_updated_at() TO authenticated;
GRANT ALL ON FUNCTION rh.update_training_settings_updated_at() TO service_role;


--
-- Name: FUNCTION _crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO service_role;


--
-- Name: FUNCTION create_secret(new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: FUNCTION update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO service_role;


--
-- Name: TABLE almoxarifados; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.almoxarifados TO authenticated;


--
-- Name: TABLE checklist_recebimento; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.checklist_recebimento TO authenticated;


--
-- Name: TABLE entrada_itens; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.entrada_itens TO authenticated;


--
-- Name: TABLE entradas_materiais; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.entradas_materiais TO authenticated;


--
-- Name: TABLE estoque_atual; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.estoque_atual TO authenticated;


--
-- Name: TABLE inventario_itens; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.inventario_itens TO authenticated;


--
-- Name: TABLE inventarios; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.inventarios TO authenticated;


--
-- Name: TABLE localizacoes_fisicas; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.localizacoes_fisicas TO authenticated;


--
-- Name: TABLE materiais_equipamentos; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.materiais_equipamentos TO authenticated;


--
-- Name: TABLE movimentacoes_estoque; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.movimentacoes_estoque TO authenticated;


--
-- Name: TABLE solicitacoes_compra; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.solicitacoes_compra TO authenticated;


--
-- Name: TABLE solicitacoes_saida_materiais; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT ALL ON TABLE almoxarifado.solicitacoes_saida_materiais TO anon;
GRANT ALL ON TABLE almoxarifado.solicitacoes_saida_materiais TO authenticated;
GRANT ALL ON TABLE almoxarifado.solicitacoes_saida_materiais TO service_role;


--
-- Name: TABLE transferencia_itens; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.transferencia_itens TO authenticated;


--
-- Name: TABLE transferencias; Type: ACL; Schema: almoxarifado; Owner: postgres
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE almoxarifado.transferencias TO authenticated;


--
-- Name: TABLE audit_log_entries; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.audit_log_entries TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.audit_log_entries TO postgres;
GRANT SELECT ON TABLE auth.audit_log_entries TO postgres WITH GRANT OPTION;


--
-- Name: TABLE flow_state; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.flow_state TO postgres;
GRANT SELECT ON TABLE auth.flow_state TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.flow_state TO dashboard_user;


--
-- Name: TABLE identities; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.identities TO postgres;
GRANT SELECT ON TABLE auth.identities TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.identities TO dashboard_user;


--
-- Name: TABLE instances; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.instances TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.instances TO postgres;
GRANT SELECT ON TABLE auth.instances TO postgres WITH GRANT OPTION;


--
-- Name: TABLE mfa_amr_claims; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_amr_claims TO postgres;
GRANT SELECT ON TABLE auth.mfa_amr_claims TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_amr_claims TO dashboard_user;


--
-- Name: TABLE mfa_challenges; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_challenges TO postgres;
GRANT SELECT ON TABLE auth.mfa_challenges TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_challenges TO dashboard_user;


--
-- Name: TABLE mfa_factors; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.mfa_factors TO postgres;
GRANT SELECT ON TABLE auth.mfa_factors TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_factors TO dashboard_user;


--
-- Name: TABLE oauth_authorizations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_authorizations TO postgres;
GRANT ALL ON TABLE auth.oauth_authorizations TO dashboard_user;


--
-- Name: TABLE oauth_clients; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_clients TO postgres;
GRANT ALL ON TABLE auth.oauth_clients TO dashboard_user;


--
-- Name: TABLE oauth_consents; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.oauth_consents TO postgres;
GRANT ALL ON TABLE auth.oauth_consents TO dashboard_user;


--
-- Name: TABLE one_time_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.one_time_tokens TO postgres;
GRANT SELECT ON TABLE auth.one_time_tokens TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.one_time_tokens TO dashboard_user;


--
-- Name: TABLE refresh_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.refresh_tokens TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.refresh_tokens TO postgres;
GRANT SELECT ON TABLE auth.refresh_tokens TO postgres WITH GRANT OPTION;


--
-- Name: SEQUENCE refresh_tokens_id_seq; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO dashboard_user;
GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO postgres;


--
-- Name: TABLE saml_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_providers TO postgres;
GRANT SELECT ON TABLE auth.saml_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_providers TO dashboard_user;


--
-- Name: TABLE saml_relay_states; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.saml_relay_states TO postgres;
GRANT SELECT ON TABLE auth.saml_relay_states TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_relay_states TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT SELECT ON TABLE auth.schema_migrations TO postgres WITH GRANT OPTION;


--
-- Name: TABLE sessions; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sessions TO postgres;
GRANT SELECT ON TABLE auth.sessions TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sessions TO dashboard_user;


--
-- Name: TABLE sso_domains; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_domains TO postgres;
GRANT SELECT ON TABLE auth.sso_domains TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_domains TO dashboard_user;


--
-- Name: TABLE sso_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.sso_providers TO postgres;
GRANT SELECT ON TABLE auth.sso_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_providers TO dashboard_user;


--
-- Name: TABLE users; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.users TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,MAINTAIN,UPDATE ON TABLE auth.users TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres WITH GRANT OPTION;


--
-- Name: TABLE partners; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.partners TO anon;
GRANT ALL ON TABLE public.partners TO authenticated;
GRANT ALL ON TABLE public.partners TO service_role;


--
-- Name: TABLE pg_stat_statements; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements TO dashboard_user;


--
-- Name: TABLE pg_stat_statements_info; Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON TABLE extensions.pg_stat_statements_info FROM postgres;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE extensions.pg_stat_statements_info TO dashboard_user;


--
-- Name: TABLE aprovacoes; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.aprovacoes TO anon;
GRANT ALL ON TABLE financeiro.aprovacoes TO authenticated;
GRANT ALL ON TABLE financeiro.aprovacoes TO service_role;


--
-- Name: TABLE borderos; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.borderos TO anon;
GRANT ALL ON TABLE financeiro.borderos TO authenticated;
GRANT ALL ON TABLE financeiro.borderos TO service_role;


--
-- Name: TABLE conciliacoes_bancarias; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.conciliacoes_bancarias TO anon;
GRANT ALL ON TABLE financeiro.conciliacoes_bancarias TO authenticated;
GRANT ALL ON TABLE financeiro.conciliacoes_bancarias TO service_role;


--
-- Name: TABLE configuracoes_aprovacao; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.configuracoes_aprovacao TO anon;
GRANT ALL ON TABLE financeiro.configuracoes_aprovacao TO authenticated;
GRANT ALL ON TABLE financeiro.configuracoes_aprovacao TO service_role;


--
-- Name: TABLE contas_bancarias; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.contas_bancarias TO anon;
GRANT ALL ON TABLE financeiro.contas_bancarias TO authenticated;
GRANT ALL ON TABLE financeiro.contas_bancarias TO service_role;


--
-- Name: TABLE contas_pagar; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.contas_pagar TO anon;
GRANT ALL ON TABLE financeiro.contas_pagar TO authenticated;
GRANT ALL ON TABLE financeiro.contas_pagar TO service_role;


--
-- Name: TABLE contas_receber; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.contas_receber TO anon;
GRANT ALL ON TABLE financeiro.contas_receber TO authenticated;
GRANT ALL ON TABLE financeiro.contas_receber TO service_role;


--
-- Name: TABLE fluxo_caixa; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.fluxo_caixa TO anon;
GRANT ALL ON TABLE financeiro.fluxo_caixa TO authenticated;
GRANT ALL ON TABLE financeiro.fluxo_caixa TO service_role;


--
-- Name: TABLE lancamentos_contabeis; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.lancamentos_contabeis TO anon;
GRANT ALL ON TABLE financeiro.lancamentos_contabeis TO authenticated;
GRANT ALL ON TABLE financeiro.lancamentos_contabeis TO service_role;


--
-- Name: TABLE nfe; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.nfe TO anon;
GRANT ALL ON TABLE financeiro.nfe TO authenticated;
GRANT ALL ON TABLE financeiro.nfe TO service_role;


--
-- Name: TABLE nfse; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.nfse TO anon;
GRANT ALL ON TABLE financeiro.nfse TO authenticated;
GRANT ALL ON TABLE financeiro.nfse TO service_role;


--
-- Name: TABLE plano_contas; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.plano_contas TO anon;
GRANT ALL ON TABLE financeiro.plano_contas TO authenticated;
GRANT ALL ON TABLE financeiro.plano_contas TO service_role;


--
-- Name: TABLE remessas_bancarias; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.remessas_bancarias TO anon;
GRANT ALL ON TABLE financeiro.remessas_bancarias TO authenticated;
GRANT ALL ON TABLE financeiro.remessas_bancarias TO service_role;


--
-- Name: TABLE retornos_bancarios; Type: ACL; Schema: financeiro; Owner: postgres
--

GRANT ALL ON TABLE financeiro.retornos_bancarios TO anon;
GRANT ALL ON TABLE financeiro.retornos_bancarios TO authenticated;
GRANT ALL ON TABLE financeiro.retornos_bancarios TO service_role;


--
-- Name: TABLE aprovacoes_unificada; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.aprovacoes_unificada TO anon;
GRANT ALL ON TABLE public.aprovacoes_unificada TO authenticated;
GRANT ALL ON TABLE public.aprovacoes_unificada TO service_role;


--
-- Name: TABLE companies; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.companies TO anon;
GRANT ALL ON TABLE public.companies TO authenticated;
GRANT ALL ON TABLE public.companies TO service_role;


--
-- Name: SEQUENCE company_number_seq; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON SEQUENCE public.company_number_seq TO anon;
GRANT ALL ON SEQUENCE public.company_number_seq TO authenticated;
GRANT ALL ON SEQUENCE public.company_number_seq TO service_role;


--
-- Name: TABLE configuracoes_aprovacao_unificada; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.configuracoes_aprovacao_unificada TO anon;
GRANT ALL ON TABLE public.configuracoes_aprovacao_unificada TO authenticated;
GRANT ALL ON TABLE public.configuracoes_aprovacao_unificada TO service_role;


--
-- Name: TABLE cost_centers; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.cost_centers TO anon;
GRANT ALL ON TABLE public.cost_centers TO authenticated;
GRANT ALL ON TABLE public.cost_centers TO service_role;


--
-- Name: TABLE entity_permissions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.entity_permissions TO anon;
GRANT ALL ON TABLE public.entity_permissions TO authenticated;
GRANT ALL ON TABLE public.entity_permissions TO service_role;


--
-- Name: TABLE historico_edicoes_solicitacoes; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.historico_edicoes_solicitacoes TO anon;
GRANT ALL ON TABLE public.historico_edicoes_solicitacoes TO authenticated;
GRANT ALL ON TABLE public.historico_edicoes_solicitacoes TO service_role;


--
-- Name: TABLE module_permissions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.module_permissions TO anon;
GRANT ALL ON TABLE public.module_permissions TO authenticated;
GRANT ALL ON TABLE public.module_permissions TO service_role;


--
-- Name: TABLE notifications; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.notifications TO anon;
GRANT ALL ON TABLE public.notifications TO authenticated;
GRANT ALL ON TABLE public.notifications TO service_role;


--
-- Name: TABLE profiles; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.profiles TO anon;
GRANT ALL ON TABLE public.profiles TO authenticated;
GRANT ALL ON TABLE public.profiles TO service_role;


--
-- Name: TABLE projects; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.projects TO anon;
GRANT ALL ON TABLE public.projects TO authenticated;
GRANT ALL ON TABLE public.projects TO service_role;


--
-- Name: TABLE user_companies; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_companies TO anon;
GRANT ALL ON TABLE public.user_companies TO authenticated;
GRANT ALL ON TABLE public.user_companies TO service_role;


--
-- Name: TABLE users; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.users TO anon;
GRANT ALL ON TABLE public.users TO authenticated;
GRANT ALL ON TABLE public.users TO service_role;


--
-- Name: TABLE messages; Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON TABLE realtime.messages TO postgres;
GRANT ALL ON TABLE realtime.messages TO dashboard_user;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO anon;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO authenticated;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO service_role;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.schema_migrations TO postgres;
GRANT ALL ON TABLE realtime.schema_migrations TO dashboard_user;
GRANT SELECT ON TABLE realtime.schema_migrations TO anon;
GRANT SELECT ON TABLE realtime.schema_migrations TO authenticated;
GRANT SELECT ON TABLE realtime.schema_migrations TO service_role;
GRANT ALL ON TABLE realtime.schema_migrations TO supabase_realtime_admin;


--
-- Name: TABLE subscription; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.subscription TO postgres;
GRANT ALL ON TABLE realtime.subscription TO dashboard_user;
GRANT SELECT ON TABLE realtime.subscription TO anon;
GRANT SELECT ON TABLE realtime.subscription TO authenticated;
GRANT SELECT ON TABLE realtime.subscription TO service_role;
GRANT ALL ON TABLE realtime.subscription TO supabase_realtime_admin;


--
-- Name: SEQUENCE subscription_id_seq; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO postgres;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO dashboard_user;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO anon;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO authenticated;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO service_role;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO supabase_realtime_admin;


--
-- Name: TABLE absence_types; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.absence_types TO anon;
GRANT ALL ON TABLE rh.absence_types TO authenticated;
GRANT ALL ON TABLE rh.absence_types TO service_role;


--
-- Name: TABLE allowance_types; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.allowance_types TO anon;
GRANT ALL ON TABLE rh.allowance_types TO authenticated;
GRANT ALL ON TABLE rh.allowance_types TO service_role;


--
-- Name: TABLE approval_level_approvers; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.approval_level_approvers TO anon;
GRANT ALL ON TABLE rh.approval_level_approvers TO authenticated;
GRANT ALL ON TABLE rh.approval_level_approvers TO service_role;


--
-- Name: TABLE approval_levels; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.approval_levels TO anon;
GRANT ALL ON TABLE rh.approval_levels TO authenticated;
GRANT ALL ON TABLE rh.approval_levels TO service_role;


--
-- Name: TABLE attendance_corrections; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.attendance_corrections TO anon;
GRANT ALL ON TABLE rh.attendance_corrections TO authenticated;
GRANT ALL ON TABLE rh.attendance_corrections TO service_role;


--
-- Name: TABLE audit_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.audit_config TO anon;
GRANT ALL ON TABLE rh.audit_config TO authenticated;
GRANT ALL ON TABLE rh.audit_config TO service_role;


--
-- Name: TABLE audit_logs; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.audit_logs TO anon;
GRANT ALL ON TABLE rh.audit_logs TO authenticated;
GRANT ALL ON TABLE rh.audit_logs TO service_role;


--
-- Name: TABLE bank_hours_balance; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.bank_hours_balance TO anon;
GRANT ALL ON TABLE rh.bank_hours_balance TO authenticated;
GRANT ALL ON TABLE rh.bank_hours_balance TO service_role;


--
-- Name: TABLE bank_hours_calculations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.bank_hours_calculations TO anon;
GRANT ALL ON TABLE rh.bank_hours_calculations TO authenticated;
GRANT ALL ON TABLE rh.bank_hours_calculations TO service_role;


--
-- Name: TABLE bank_hours_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.bank_hours_config TO anon;
GRANT ALL ON TABLE rh.bank_hours_config TO authenticated;
GRANT ALL ON TABLE rh.bank_hours_config TO service_role;


--
-- Name: TABLE bank_hours_transactions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.bank_hours_transactions TO anon;
GRANT ALL ON TABLE rh.bank_hours_transactions TO authenticated;
GRANT ALL ON TABLE rh.bank_hours_transactions TO service_role;


--
-- Name: TABLE benefit_configurations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.benefit_configurations TO anon;
GRANT ALL ON TABLE rh.benefit_configurations TO authenticated;
GRANT ALL ON TABLE rh.benefit_configurations TO service_role;


--
-- Name: TABLE calculation_logs; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.calculation_logs TO anon;
GRANT ALL ON TABLE rh.calculation_logs TO authenticated;
GRANT ALL ON TABLE rh.calculation_logs TO service_role;


--
-- Name: TABLE candidate_documents; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.candidate_documents TO anon;
GRANT ALL ON TABLE rh.candidate_documents TO authenticated;
GRANT ALL ON TABLE rh.candidate_documents TO service_role;


--
-- Name: TABLE candidates; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.candidates TO anon;
GRANT ALL ON TABLE rh.candidates TO authenticated;
GRANT ALL ON TABLE rh.candidates TO service_role;


--
-- Name: TABLE cid_codes; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.cid_codes TO anon;
GRANT ALL ON TABLE rh.cid_codes TO authenticated;
GRANT ALL ON TABLE rh.cid_codes TO service_role;


--
-- Name: TABLE collective_agreements; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.collective_agreements TO anon;
GRANT ALL ON TABLE rh.collective_agreements TO authenticated;
GRANT ALL ON TABLE rh.collective_agreements TO service_role;


--
-- Name: TABLE compensation_approvals; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.compensation_approvals TO anon;
GRANT ALL ON TABLE rh.compensation_approvals TO authenticated;
GRANT ALL ON TABLE rh.compensation_approvals TO service_role;


--
-- Name: TABLE compensation_requests; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.compensation_requests TO anon;
GRANT ALL ON TABLE rh.compensation_requests TO authenticated;
GRANT ALL ON TABLE rh.compensation_requests TO service_role;


--
-- Name: TABLE correction_history; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.correction_history TO anon;
GRANT ALL ON TABLE rh.correction_history TO authenticated;
GRANT ALL ON TABLE rh.correction_history TO service_role;


--
-- Name: TABLE correction_settings; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.correction_settings TO anon;
GRANT ALL ON TABLE rh.correction_settings TO authenticated;
GRANT ALL ON TABLE rh.correction_settings TO service_role;


--
-- Name: TABLE deficiency_types; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.deficiency_types TO anon;
GRANT ALL ON TABLE rh.deficiency_types TO authenticated;
GRANT ALL ON TABLE rh.deficiency_types TO service_role;


--
-- Name: TABLE delay_reasons; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.delay_reasons TO anon;
GRANT ALL ON TABLE rh.delay_reasons TO authenticated;
GRANT ALL ON TABLE rh.delay_reasons TO service_role;


--
-- Name: TABLE dependents; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.dependents TO anon;
GRANT ALL ON TABLE rh.dependents TO authenticated;
GRANT ALL ON TABLE rh.dependents TO service_role;


--
-- Name: TABLE employees; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employees TO anon;
GRANT ALL ON TABLE rh.employees TO authenticated;
GRANT ALL ON TABLE rh.employees TO service_role;


--
-- Name: TABLE dependents_with_employee; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.dependents_with_employee TO anon;
GRANT ALL ON TABLE rh.dependents_with_employee TO authenticated;
GRANT ALL ON TABLE rh.dependents_with_employee TO service_role;


--
-- Name: TABLE disciplinary_actions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.disciplinary_actions TO anon;
GRANT ALL ON TABLE rh.disciplinary_actions TO authenticated;
GRANT ALL ON TABLE rh.disciplinary_actions TO service_role;


--
-- Name: TABLE employee_benefit_assignments; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_benefit_assignments TO anon;
GRANT ALL ON TABLE rh.employee_benefit_assignments TO authenticated;
GRANT ALL ON TABLE rh.employee_benefit_assignments TO service_role;


--
-- Name: TABLE employee_correction_permissions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_correction_permissions TO anon;
GRANT ALL ON TABLE rh.employee_correction_permissions TO authenticated;
GRANT ALL ON TABLE rh.employee_correction_permissions TO service_role;


--
-- Name: TABLE employee_medical_plans; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_medical_plans TO anon;
GRANT ALL ON TABLE rh.employee_medical_plans TO authenticated;
GRANT ALL ON TABLE rh.employee_medical_plans TO service_role;


--
-- Name: TABLE employee_plan_dependents; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_plan_dependents TO anon;
GRANT ALL ON TABLE rh.employee_plan_dependents TO authenticated;
GRANT ALL ON TABLE rh.employee_plan_dependents TO service_role;


--
-- Name: TABLE employee_schedules; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_schedules TO anon;
GRANT ALL ON TABLE rh.employee_schedules TO authenticated;
GRANT ALL ON TABLE rh.employee_schedules TO service_role;


--
-- Name: TABLE employee_shifts; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_shifts TO anon;
GRANT ALL ON TABLE rh.employee_shifts TO authenticated;
GRANT ALL ON TABLE rh.employee_shifts TO service_role;


--
-- Name: TABLE employee_union_memberships; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employee_union_memberships TO anon;
GRANT ALL ON TABLE rh.employee_union_memberships TO authenticated;
GRANT ALL ON TABLE rh.employee_union_memberships TO service_role;


--
-- Name: TABLE employment_contracts; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.employment_contracts TO anon;
GRANT ALL ON TABLE rh.employment_contracts TO authenticated;
GRANT ALL ON TABLE rh.employment_contracts TO service_role;


--
-- Name: TABLE equipment_rental_approvals; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.equipment_rental_approvals TO anon;
GRANT ALL ON TABLE rh.equipment_rental_approvals TO authenticated;
GRANT ALL ON TABLE rh.equipment_rental_approvals TO service_role;


--
-- Name: TABLE esocial_batches; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.esocial_batches TO anon;
GRANT ALL ON TABLE rh.esocial_batches TO authenticated;
GRANT ALL ON TABLE rh.esocial_batches TO service_role;


--
-- Name: TABLE esocial_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.esocial_config TO anon;
GRANT ALL ON TABLE rh.esocial_config TO authenticated;
GRANT ALL ON TABLE rh.esocial_config TO service_role;


--
-- Name: TABLE esocial_events; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.esocial_events TO anon;
GRANT ALL ON TABLE rh.esocial_events TO authenticated;
GRANT ALL ON TABLE rh.esocial_events TO service_role;


--
-- Name: TABLE esocial_integrations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.esocial_integrations TO anon;
GRANT ALL ON TABLE rh.esocial_integrations TO authenticated;
GRANT ALL ON TABLE rh.esocial_integrations TO service_role;


--
-- Name: TABLE esocial_logs; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.esocial_logs TO anon;
GRANT ALL ON TABLE rh.esocial_logs TO authenticated;
GRANT ALL ON TABLE rh.esocial_logs TO service_role;


--
-- Name: TABLE event_consolidations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.event_consolidations TO anon;
GRANT ALL ON TABLE rh.event_consolidations TO authenticated;
GRANT ALL ON TABLE rh.event_consolidations TO service_role;


--
-- Name: TABLE fgts_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.fgts_config TO anon;
GRANT ALL ON TABLE rh.fgts_config TO authenticated;
GRANT ALL ON TABLE rh.fgts_config TO service_role;


--
-- Name: TABLE gestor_notifications; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.gestor_notifications TO anon;
GRANT ALL ON TABLE rh.gestor_notifications TO authenticated;
GRANT ALL ON TABLE rh.gestor_notifications TO service_role;


--
-- Name: TABLE holidays; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.holidays TO anon;
GRANT ALL ON TABLE rh.holidays TO authenticated;
GRANT ALL ON TABLE rh.holidays TO service_role;


--
-- Name: TABLE income_statements; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.income_statements TO anon;
GRANT ALL ON TABLE rh.income_statements TO authenticated;
GRANT ALL ON TABLE rh.income_statements TO service_role;


--
-- Name: TABLE inss_brackets; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.inss_brackets TO anon;
GRANT ALL ON TABLE rh.inss_brackets TO authenticated;
GRANT ALL ON TABLE rh.inss_brackets TO service_role;


--
-- Name: TABLE irrf_brackets; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.irrf_brackets TO anon;
GRANT ALL ON TABLE rh.irrf_brackets TO authenticated;
GRANT ALL ON TABLE rh.irrf_brackets TO service_role;


--
-- Name: TABLE job_openings; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.job_openings TO anon;
GRANT ALL ON TABLE rh.job_openings TO authenticated;
GRANT ALL ON TABLE rh.job_openings TO service_role;


--
-- Name: TABLE job_requests; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.job_requests TO anon;
GRANT ALL ON TABLE rh.job_requests TO authenticated;
GRANT ALL ON TABLE rh.job_requests TO service_role;


--
-- Name: TABLE medical_agreements; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.medical_agreements TO anon;
GRANT ALL ON TABLE rh.medical_agreements TO authenticated;
GRANT ALL ON TABLE rh.medical_agreements TO service_role;


--
-- Name: TABLE medical_certificate_attachments; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.medical_certificate_attachments TO anon;
GRANT ALL ON TABLE rh.medical_certificate_attachments TO authenticated;
GRANT ALL ON TABLE rh.medical_certificate_attachments TO service_role;


--
-- Name: TABLE medical_certificates; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.medical_certificates TO anon;
GRANT ALL ON TABLE rh.medical_certificates TO authenticated;
GRANT ALL ON TABLE rh.medical_certificates TO service_role;


--
-- Name: TABLE medical_plan_pricing_history; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.medical_plan_pricing_history TO anon;
GRANT ALL ON TABLE rh.medical_plan_pricing_history TO authenticated;
GRANT ALL ON TABLE rh.medical_plan_pricing_history TO service_role;


--
-- Name: TABLE medical_plans; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.medical_plans TO anon;
GRANT ALL ON TABLE rh.medical_plans TO authenticated;
GRANT ALL ON TABLE rh.medical_plans TO service_role;


--
-- Name: TABLE monthly_benefit_processing; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.monthly_benefit_processing TO anon;
GRANT ALL ON TABLE rh.monthly_benefit_processing TO authenticated;
GRANT ALL ON TABLE rh.monthly_benefit_processing TO service_role;


--
-- Name: TABLE payroll; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.payroll TO anon;
GRANT ALL ON TABLE rh.payroll TO authenticated;
GRANT ALL ON TABLE rh.payroll TO service_role;


--
-- Name: TABLE payroll_config; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.payroll_config TO anon;
GRANT ALL ON TABLE rh.payroll_config TO authenticated;
GRANT ALL ON TABLE rh.payroll_config TO service_role;


--
-- Name: TABLE payroll_events; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.payroll_events TO anon;
GRANT ALL ON TABLE rh.payroll_events TO authenticated;
GRANT ALL ON TABLE rh.payroll_events TO service_role;


--
-- Name: TABLE periodic_exams; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.periodic_exams TO anon;
GRANT ALL ON TABLE rh.periodic_exams TO authenticated;
GRANT ALL ON TABLE rh.periodic_exams TO service_role;


--
-- Name: TABLE positions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.positions TO anon;
GRANT ALL ON TABLE rh.positions TO authenticated;
GRANT ALL ON TABLE rh.positions TO service_role;


--
-- Name: TABLE reimbursement_requests; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.reimbursement_requests TO anon;
GRANT ALL ON TABLE rh.reimbursement_requests TO authenticated;
GRANT ALL ON TABLE rh.reimbursement_requests TO service_role;


--
-- Name: TABLE reports; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.reports TO anon;
GRANT ALL ON TABLE rh.reports TO authenticated;
GRANT ALL ON TABLE rh.reports TO service_role;


--
-- Name: TABLE rubricas; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.rubricas TO anon;
GRANT ALL ON TABLE rh.rubricas TO authenticated;
GRANT ALL ON TABLE rh.rubricas TO service_role;


--
-- Name: TABLE schedule_planning; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.schedule_planning TO anon;
GRANT ALL ON TABLE rh.schedule_planning TO authenticated;
GRANT ALL ON TABLE rh.schedule_planning TO service_role;


--
-- Name: TABLE selection_processes; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.selection_processes TO anon;
GRANT ALL ON TABLE rh.selection_processes TO authenticated;
GRANT ALL ON TABLE rh.selection_processes TO service_role;


--
-- Name: TABLE selection_stages; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.selection_stages TO anon;
GRANT ALL ON TABLE rh.selection_stages TO authenticated;
GRANT ALL ON TABLE rh.selection_stages TO service_role;


--
-- Name: TABLE signature_notifications; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.signature_notifications TO anon;
GRANT ALL ON TABLE rh.signature_notifications TO authenticated;
GRANT ALL ON TABLE rh.signature_notifications TO service_role;


--
-- Name: TABLE talent_pool; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.talent_pool TO anon;
GRANT ALL ON TABLE rh.talent_pool TO authenticated;
GRANT ALL ON TABLE rh.talent_pool TO service_role;


--
-- Name: TABLE time_bank; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.time_bank TO anon;
GRANT ALL ON TABLE rh.time_bank TO authenticated;
GRANT ALL ON TABLE rh.time_bank TO service_role;


--
-- Name: TABLE time_record_signatures; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.time_record_signatures TO anon;
GRANT ALL ON TABLE rh.time_record_signatures TO authenticated;
GRANT ALL ON TABLE rh.time_record_signatures TO service_role;


--
-- Name: TABLE time_records; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.time_records TO anon;
GRANT ALL ON TABLE rh.time_records TO authenticated;
GRANT ALL ON TABLE rh.time_records TO service_role;


--
-- Name: TABLE training_attendance; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_attendance TO anon;
GRANT ALL ON TABLE rh.training_attendance TO authenticated;
GRANT ALL ON TABLE rh.training_attendance TO service_role;


--
-- Name: TABLE training_certificates; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_certificates TO anon;
GRANT ALL ON TABLE rh.training_certificates TO authenticated;
GRANT ALL ON TABLE rh.training_certificates TO service_role;


--
-- Name: TABLE training_enrollments; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_enrollments TO anon;
GRANT ALL ON TABLE rh.training_enrollments TO authenticated;
GRANT ALL ON TABLE rh.training_enrollments TO service_role;


--
-- Name: TABLE training_evaluations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_evaluations TO anon;
GRANT ALL ON TABLE rh.training_evaluations TO authenticated;
GRANT ALL ON TABLE rh.training_evaluations TO service_role;


--
-- Name: TABLE training_notification_history; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_notification_history TO anon;
GRANT ALL ON TABLE rh.training_notification_history TO authenticated;
GRANT ALL ON TABLE rh.training_notification_history TO service_role;


--
-- Name: TABLE training_notification_queue; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_notification_queue TO anon;
GRANT ALL ON TABLE rh.training_notification_queue TO authenticated;
GRANT ALL ON TABLE rh.training_notification_queue TO service_role;


--
-- Name: TABLE training_notification_rules; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_notification_rules TO anon;
GRANT ALL ON TABLE rh.training_notification_rules TO authenticated;
GRANT ALL ON TABLE rh.training_notification_rules TO service_role;


--
-- Name: TABLE training_notification_types; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_notification_types TO anon;
GRANT ALL ON TABLE rh.training_notification_types TO authenticated;
GRANT ALL ON TABLE rh.training_notification_types TO service_role;


--
-- Name: TABLE training_settings; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.training_settings TO authenticated;
GRANT ALL ON TABLE rh.training_settings TO anon;
GRANT ALL ON TABLE rh.training_settings TO service_role;


--
-- Name: TABLE trainings; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.trainings TO anon;
GRANT ALL ON TABLE rh.trainings TO authenticated;
GRANT ALL ON TABLE rh.trainings TO service_role;


--
-- Name: TABLE union_contributions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.union_contributions TO anon;
GRANT ALL ON TABLE rh.union_contributions TO authenticated;
GRANT ALL ON TABLE rh.union_contributions TO service_role;


--
-- Name: TABLE union_negotiations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.union_negotiations TO anon;
GRANT ALL ON TABLE rh.union_negotiations TO authenticated;
GRANT ALL ON TABLE rh.union_negotiations TO service_role;


--
-- Name: TABLE union_representatives; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.union_representatives TO anon;
GRANT ALL ON TABLE rh.union_representatives TO authenticated;
GRANT ALL ON TABLE rh.union_representatives TO service_role;


--
-- Name: TABLE unions; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.unions TO anon;
GRANT ALL ON TABLE rh.unions TO authenticated;
GRANT ALL ON TABLE rh.unions TO service_role;


--
-- Name: TABLE units; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.units TO anon;
GRANT ALL ON TABLE rh.units TO authenticated;
GRANT ALL ON TABLE rh.units TO service_role;


--
-- Name: TABLE vacation_entitlements; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.vacation_entitlements TO anon;
GRANT ALL ON TABLE rh.vacation_entitlements TO authenticated;
GRANT ALL ON TABLE rh.vacation_entitlements TO service_role;


--
-- Name: TABLE vacation_periods; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.vacation_periods TO anon;
GRANT ALL ON TABLE rh.vacation_periods TO authenticated;
GRANT ALL ON TABLE rh.vacation_periods TO service_role;


--
-- Name: TABLE vacations; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.vacations TO anon;
GRANT ALL ON TABLE rh.vacations TO authenticated;
GRANT ALL ON TABLE rh.vacations TO service_role;


--
-- Name: TABLE work_schedules; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.work_schedules TO anon;
GRANT ALL ON TABLE rh.work_schedules TO authenticated;
GRANT ALL ON TABLE rh.work_schedules TO service_role;


--
-- Name: TABLE work_shifts; Type: ACL; Schema: rh; Owner: postgres
--

GRANT ALL ON TABLE rh.work_shifts TO anon;
GRANT ALL ON TABLE rh.work_shifts TO authenticated;
GRANT ALL ON TABLE rh.work_shifts TO service_role;


--
-- Name: TABLE buckets; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets TO anon;
GRANT ALL ON TABLE storage.buckets TO authenticated;
GRANT ALL ON TABLE storage.buckets TO service_role;
GRANT ALL ON TABLE storage.buckets TO postgres WITH GRANT OPTION;


--
-- Name: TABLE buckets_analytics; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets_analytics TO service_role;
GRANT ALL ON TABLE storage.buckets_analytics TO authenticated;
GRANT ALL ON TABLE storage.buckets_analytics TO anon;


--
-- Name: TABLE objects; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.objects TO anon;
GRANT ALL ON TABLE storage.objects TO authenticated;
GRANT ALL ON TABLE storage.objects TO service_role;
GRANT ALL ON TABLE storage.objects TO postgres WITH GRANT OPTION;


--
-- Name: TABLE prefixes; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.prefixes TO service_role;
GRANT ALL ON TABLE storage.prefixes TO authenticated;
GRANT ALL ON TABLE storage.prefixes TO anon;


--
-- Name: TABLE s3_multipart_uploads; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO anon;


--
-- Name: TABLE s3_multipart_uploads_parts; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads_parts TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO anon;


--
-- Name: TABLE secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.secrets TO service_role;


--
-- Name: TABLE decrypted_secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,REFERENCES,DELETE,TRUNCATE ON TABLE vault.decrypted_secrets TO postgres WITH GRANT OPTION;
GRANT SELECT,DELETE ON TABLE vault.decrypted_secrets TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON SEQUENCES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON FUNCTIONS TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON TABLES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: rh; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: rh; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: rh; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA rh GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO service_role;


--
-- Name: issue_graphql_placeholder; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop
         WHEN TAG IN ('DROP EXTENSION')
   EXECUTE FUNCTION extensions.set_graphql_placeholder();


ALTER EVENT TRIGGER issue_graphql_placeholder OWNER TO supabase_admin;

--
-- Name: issue_pg_cron_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_cron_access();


ALTER EVENT TRIGGER issue_pg_cron_access OWNER TO supabase_admin;

--
-- Name: issue_pg_graphql_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end
         WHEN TAG IN ('CREATE FUNCTION')
   EXECUTE FUNCTION extensions.grant_pg_graphql_access();


ALTER EVENT TRIGGER issue_pg_graphql_access OWNER TO supabase_admin;

--
-- Name: issue_pg_net_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_net_access();


ALTER EVENT TRIGGER issue_pg_net_access OWNER TO supabase_admin;

--
-- Name: pgrst_ddl_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_ddl_watch ON ddl_command_end
   EXECUTE FUNCTION extensions.pgrst_ddl_watch();


ALTER EVENT TRIGGER pgrst_ddl_watch OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_drop_watch ON sql_drop
   EXECUTE FUNCTION extensions.pgrst_drop_watch();


ALTER EVENT TRIGGER pgrst_drop_watch OWNER TO supabase_admin;

--
-- PostgreSQL database dump complete
--

\unrestrict lqGbnxpX7o51weGhpvaad4aqwRekvf2ptUlvVTSiNdtaWm6vXWqfh8n5ZUj0vrn

--
-- PostgreSQL database cluster dump complete
--

